// ==UserScript==
// @name         UFO
// @namespace    http://tampermonkey.net/
// @version      137
// @description  UFO
// @author       israeg, lvnton
// @match        https://outboundflow-iad.amazon.com/UFO*
// @grant        GM_xmlhttpRequest
// @connect      crisp-na.corp.amazon.com
// @connect      outboundflow-iad.amazon.com
// @connect      throughput-iad.iad.proxy.amazon.com
// @connect      https://throughput-iad.iad.proxy.amazon.com
// @connect      flow-sortation-na.amazon.com
// @connect      logistics.amazon.com
// @connect      https://rodeo-iad.amazon.com
// @connect      rodeo-iad.amazon.com
// @connect      https://sccwebsitena.last-mile.amazon.dev
// @connect      hooks.slack.com
// @downloadURL  https://axzile.corp.amazon.com/-/carthamus/download_script/ufo.user.js
// @updateURL    https://axzile.corp.amazon.com/-/carthamus/download_script/ufo.user.js
// @connect      *
// ==/UserScript==


(function() {
    'use strict';

    // Document setup
    document.title = "ùó®ùóôùó¢";

    // Favicon management - consolidated into single operation
    const existingFavicons = document.querySelectorAll('link[rel*="icon"]');
    existingFavicons.forEach(favicon => favicon.remove());

    const favicon = document.createElement('link');
    Object.assign(favicon, {
        rel: 'icon',
        type: 'image/png',
        href: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTR8YUoW2G4hY89QjTqksehrBto-nztlziFGg&s'
    });
    document.head.appendChild(favicon);

    // Clear body content
    document.body.innerHTML = '';

    // CSS injection - more efficient approach
    const style = document.createElement('style');
    style.textContent = `
  .no-settings {
    font-weight: bold;
    color: red;
  }
  .SelectedCPTSchedule td {
    border: 1px solid black;
    padding: 5px;
    text-align: center;
  }

  #tableContainer table,
  #fullTableContainer table,
  #nextCPTTableContainer table {
    font-size: 1.5em;
    width: 150%;
  }
  #tableContainer td,
  #fullTableContainer td,
  #nextCPTTableContainer td {
    padding: 10px;
  }
    /* UFO Master Layout CSS - Organized Container System */

/* Reset and base styles */
* {
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background-color: #f5f7fa;
    min-height: 100vh;
}

/* Main Grid Layout */
.ufo-layout {
    display: grid;
    grid-template-areas:
        "header header header header"
        "controls controls clock-info clock-info"
        "current-cpt next-cpt dispatch math"
        "plan-summary-1 plan-summary-1 plan-summary-2 plan-summary-2"
        "linehaul linehaul exsd exsd"
        "footer footer footer footer";
    grid-template-columns: 1fr 1fr 1fr 1fr;
    grid-template-rows: auto auto auto auto auto auto;
    gap: 20px;
    padding: 20px;
    max-width: 100vw;
    min-height: 100vh;
}

/* Header Section */
.ufo-header {
    grid-area: header;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
}

.ufo-header h1 {
    margin: 0;
    font-size: 2.5rem;
    font-weight: 700;
}

.ufo-header-controls {
    display: flex;
    gap: 15px;
    align-items: center;
}

.ufo-header button {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.2);
    color: white;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.ufo-header button:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
}

/* Controls Section */
.ufo-controls {
    grid-area: controls;
    background: white;
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.ufo-controls h3 {
    margin: 0 0 20px 0;
    color: #2c3e50;
    font-size: 1.5rem;
    border-bottom: 2px solid #ecf0f1;
    padding-bottom: 10px;
}

.control-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-bottom: 20px;
}

.control-item {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.control-item label {
    font-weight: 600;
    color: #34495e;
    font-size: 14px;
}

.control-item select,
.control-item input {
    padding: 12px;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 16px;
    transition: border-color 0.3s ease;
}

.control-item select:focus,
.control-item input:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

.update-button {
    padding: 12px 24px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.update-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
}

/* Clock & Info Section */
.ufo-clock-info {
    grid-area: clock-info;
    display: grid;
    grid-template-rows: auto auto auto;
    gap: 15px;
}

.clock-container,
.timestamp-container,
.cpt-info-container {
    background: white;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.clock-display {
    font-size: 2.5rem;
    font-weight: 700;
    color: #2c3e50;
    margin-bottom: 10px;
}

.timezone-label {
    color: #64748b;
    font-size: 14px;
}

/* CPT Sections */
.ufo-current-cpt {
    grid-area: current-cpt;
}

.ufo-next-cpt {
    grid-area: next-cpt;
}

.cpt-section {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    overflow: hidden;
}

.cpt-header {
    background: linear-gradient(135deg, #2193b0 0%, #6dd5ed 100%);
    color: white;
    padding: 20px;
    font-size: 1.25rem;
    font-weight: 600;
}

.cpt-content {
    padding: 20px;
}

.cpt-schedule-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-bottom: 20px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.cpt-schedule-table th,
.cpt-schedule-table td {
    padding: 12px;
    text-align: center;
    border-bottom: 1px solid #e2e8f0;
}

.cpt-schedule-table th {
    background-color: #f8fafc;
    font-weight: 600;
    color: #475569;
}

.production-graphic {
    margin-top: 20px;
}

.production-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.production-table th {
    background-color: #f8fafc;
    padding: 16px;
    font-weight: 600;
    color: #475569;
    border-bottom: 2px solid #e2e8f0;
}

.production-table td {
    padding: 12px;
    border-bottom: 1px solid #e2e8f0;
    text-align: center;
}

/* Dispatch Section */
.ufo-dispatch {
    grid-area: dispatch;
    background: white;
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

.ufo-dispatch h3 {
    margin: 0 0 20px 0;
    color: #2c3e50;
    font-size: 1.5rem;
    border-bottom: 2px solid #ecf0f1;
    padding-bottom: 10px;
}

.dispatch-table {
    width: 80%;
    border-collapse: separate;
    border-spacing: 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* Math Section */
.ufo-math {
    grid-area: math;
    background: white;
    padding: 25px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    max-height: 600px;
    overflow-y: auto;
}

.math-tables {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.math-table-section {
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    overflow: hidden;
}

.math-table-header {
    background-color: #f8fafc;
    padding: 12px 16px;
    font-weight: 600;
    color: #475569;
    border-bottom: 1px solid #e2e8f0;
}

.math-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
}

.math-table th,
.math-table td {
    padding: 8px 12px;
    border-bottom: 1px solid #e2e8f0;
    text-align: center;
}

/* Plan Summary Sections */
.ufo-plan-summary-1 {
    grid-area: plan-summary-1;
}

.ufo-plan-summary-2 {
    grid-area: plan-summary-2;
}

.plan-summary {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    overflow: hidden;
}

.plan-summary-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.plan-summary-content {
    padding: 20px;
}

.summary-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.summary-table th {
    background-color: #f8fafc;
    padding: 16px;
    font-weight: 600;
    color: #475569;
    border-bottom: 2px solid #e2e8f0;
    position: sticky;
    top: 0;
}

.summary-table td {
    padding: 12px;
    border-bottom: 1px solid #e2e8f0;
    text-align: center;
}

/* LineHaul & ExSD Section */
.ufo-linehaul {
    grid-area: linehaul;
}

.ufo-exsd {
    grid-area: exsd;
}

.data-section {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    overflow: hidden;
}

.data-section-header {
    background: linear-gradient(135deg, #2193b0 0%, #6dd5ed 100%);
    color: white;
    padding: 20px;
    font-size: 1.25rem;
    font-weight: 600;
}

.data-section-content {
    padding: 20px;
    max-height: 500px;
    overflow-y: auto;
}

/* Footer */
.ufo-footer {
    grid-area: footer;
    background: #2c3e50;
    color: white;
    padding: 20px;
    border-radius: 12px;
    text-align: center;
}

/* Responsive Design */
@media (max-width: 1600px) {
    .ufo-layout {
        grid-template-areas:
            "header header header"
            "controls clock-info math"
            "current-cpt current-cpt dispatch"
            "next-cpt next-cpt dispatch"
            "plan-summary-1 plan-summary-1 plan-summary-1"
            "plan-summary-2 plan-summary-2 plan-summary-2"
            "linehaul linehaul exsd"
            "footer footer footer";
        grid-template-columns: 1fr 1fr 1fr;
    }
}

@media (max-width: 1200px) {
    .ufo-layout {
        grid-template-areas:
            "header header"
            "controls clock-info"
            "current-cpt next-cpt"
            "plan-summary-1 plan-summary-2"
            "dispatch math"
            "linehaul exsd"
            "footer footer";
        grid-template-columns: 1fr 1fr;
    }
}

@media (max-width: 768px) {
    .ufo-layout {
        grid-template-areas:
            "header"
            "controls"
            "clock-info"
            "current-cpt"
            "next-cpt"
            "plan-summary-1"
            "plan-summary-2"
            "dispatch"
            "math"
            "linehaul"
            "exsd"
            "footer";
        grid-template-columns: 1fr;
        padding: 10px;
        gap: 15px;
    }

    .control-group {
        grid-template-columns: 1fr;
    }

    .ufo-header {
        flex-direction: column;
        gap: 15px;
        text-align: center;
    }

    .ufo-header-controls {
        flex-wrap: wrap;
        justify-content: center;
    }
}

/* Dark Mode Styles */
.dark-mode .ufo-layout {
    background-color: #1a202c;
}

.dark-mode .ufo-header {
    background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
}

.dark-mode .cpt-section,
.dark-mode .ufo-controls,
.dark-mode .ufo-dispatch,
.dark-mode .ufo-math,
.dark-mode .plan-summary,
.dark-mode .data-section {
    background: #2d3748;
    color: #e2e8f0;
}

.dark-mode .cpt-header,
.dark-mode .plan-summary-header,
.dark-mode .data-section-header {
    background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
}

.dark-mode .control-item select,
.dark-mode .control-item input {
    background: #4a5568;
    border-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .control-item select:focus,
.dark-mode .control-item input:focus {
    border-color: #63b3ed;
}

.dark-mode .cpt-schedule-table th,
.dark-mode .production-table th,
.dark-mode .summary-table th,
.dark-mode .math-table th {
    background-color: #4a5568;
    color: #e2e8f0;
}

.dark-mode .cpt-schedule-table td,
.dark-mode .production-table td,
.dark-mode .summary-table td,
.dark-mode .math-table td {
    border-color: #4a5568;
    color: #e2e8f0;
}

/* Utility Classes */
.card {
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    padding: 20px;
}

.card-header {
    margin: -20px -20px 20px -20px;
    padding: 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 12px 12px 0 0;
    font-weight: 600;
}

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
}

.btn-secondary {
    background: #f8fafc;
    color: #475569;
    border: 2px solid #e2e8f0;
}

.btn-secondary:hover {
    background: #e2e8f0;
}

/* Status Indicators */
.status-indicator {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
}

.status-success {
    background: #dcfce7;
    color: #166534;
}

.status-warning {
    background: #fef3c7;
    color: #92400e;
}

.status-error {
    background: #fee2e2;
    color: #991b1b;
}

.status-info {
    background: #dbeafe;
    color: #1e40af;
}

/* Loading States */
.loading {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid #f3f3f3;
    border-top: 3px solid #667eea;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Scroll Bars */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
`;
    document.head.appendChild(style);


    // Event listener management - using delegated event handling to prevent memory leaks
    function initializeEventListeners() {
        // Remove any existing listeners first to prevent duplicates
        const existingHandler = window.ufoEventHandler;
        if (existingHandler) {
            document.removeEventListener('change', existingHandler);
        }

        // Single delegated event handler for all change events
        window.ufoEventHandler = function(event) {
            const target = event.target;
            if (target.id === 'cptSelect' || target.id === 'riskModel') {
                updatePickRebinPackRecommendations();
            }
        };

        document.addEventListener('change', window.ufoEventHandler);
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeEventListeners);
    } else {
        initializeEventListeners();
    }

    // Global variables
    let userSelectedRiskModel = false;

    // Cleanup function for when the page unloads
    window.addEventListener('beforeunload', () => {
        if (window.ufoEventHandler) {
            document.removeEventListener('change', window.ufoEventHandler);
            window.ufoEventHandler = null;
        }
    });


// Optimized cell styling function
function applyCellStyling() {
    // More efficient selector and reduced DOM queries
    const cells = document.querySelectorAll('.SelectedCPTSchedule td');

    // Use a single loop with optimized text checking
    cells.forEach(cell => {
        const text = cell.textContent; // textContent is faster than innerText
        if (text.includes("Break") || text.includes("Downtime")) {
            // Apply styles in one operation using Object.assign
            Object.assign(cell.style, {
                backgroundColor: 'red',
                color: 'white'
            });
        }
    });
}

// Consolidated data state management
const appState = {
    dataLoaded: {
        schedule: false,
        cora: false,
        atrops: false
    },

    // Configuration objects initialized as frozen empty objects to prevent accidental mutations
    config: {
        site: Object.freeze({}),
        timeZones: Object.freeze({}),
        siteTimeZones: Object.freeze({}),
        complementaryStations: Object.freeze({}),
        defaultCPTs: Object.freeze([]),
        specialCPTs: Object.freeze({})
    },

    // Method to safely update data loaded state
    setDataLoaded(key, value) {
        if (this.dataLoaded.hasOwnProperty(key)) {
            this.dataLoaded[key] = Boolean(value);
        }
    },

    // Method to check if all data is loaded
    isAllDataLoaded() {
        return Object.values(this.dataLoaded).every(loaded => loaded === true);
    },

    // Method to safely update configuration
    updateConfig(configType, newConfig) {
        if (this.config.hasOwnProperty(configType)) {
            this.config[configType] = Object.freeze({ ...newConfig });
        }
    }
};

// Legacy global variables for compatibility (these reference the centralized state)
let dataLoaded = appState.dataLoaded;
let siteConfig = appState.config.site;
let timeZones = appState.config.timeZones;
let siteTimeZones = appState.config.siteTimeZones;
let complementaryStations = appState.config.complementaryStations;
let defaultCPTs = appState.config.defaultCPTs;
let specialCPTs = {
    'SNY1': ['01:35', '05:35', '10:25', '15:05'],
    'STX4': ['00:20', '06:20', '11:20', '14:20', '18:20', '20:20'],
    'SAZ2': ['00:20', '06:20', '11:20', '14:20', '18:20', '20:20']
};

// Configuration cache management
const CONFIG_CACHE = {
    key: 'ufo_site_config',
    timestampKey: 'ufo_site_config_timestamp',
    maxAge: 24 * 60 * 60 * 1000, // 24 hours in milliseconds

    // Check if cached data is still valid
    isValid() {
        const timestamp = localStorage.getItem(this.timestampKey);
        if (!timestamp) return false;

        const age = Date.now() - parseInt(timestamp);
        return age < this.maxAge;
    },

    // Get cached configuration
    get() {
        try {
            const cached = localStorage.getItem(this.key);
            return cached ? JSON.parse(cached) : null;
        } catch (error) {
            console.warn('Failed to parse cached config, will fetch fresh:', error);
            this.clear();
            return null;
        }
    },

    // Save configuration to cache
    set(config) {
        try {
            localStorage.setItem(this.key, JSON.stringify(config));
            localStorage.setItem(this.timestampKey, Date.now().toString());
            console.log('Site configuration cached successfully');
        } catch (error) {
            console.warn('Failed to cache configuration:', error);
            // Continue without caching if storage is full/unavailable
        }
    },

    // Clear cache
    clear() {
        localStorage.removeItem(this.key);
        localStorage.removeItem(this.timestampKey);
    },

    // Force refresh - clears cache and fetches new data
    forceRefresh() {
        this.clear();
        return fetchSiteConfiguration();
    }
};

// Enhanced function to fetch site configuration with invisible iframe authentication
function fetchSiteConfiguration() {
    // First, try to get from cache
    if (CONFIG_CACHE.isValid()) {
        const cached = CONFIG_CACHE.get();
        if (cached) {
            console.log('Using cached site configuration');
            console.log('Cached JSON config:', JSON.stringify(cached, null, 2));
            return Promise.resolve(cached);
        }
    }

    // Try direct fetch first
    console.log('Fetching fresh site configuration from network');
    return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
            method: "GET",
            url: "https://drive-render.corp.amazon.com/view/SSD%20Central%20Operations/Scripts/UFO/UFO_Site_list.json",
            headers: {
                "Accept": "application/json",
                "X-Requested-With": "XMLHttpRequest"
            },
            onload: function(response) {
                console.log('HTTP Response Status:', response.status);
                console.log('Raw Response Text:', response.responseText);

                if (response.status === 200) {
                    try {
                        const config = JSON.parse(response.responseText);
                        console.log('‚úÖ Site configuration fetched successfully!');
                        console.log('Fresh JSON config:', JSON.stringify(config, null, 2));
                        CONFIG_CACHE.set(config);
                        resolve(config);
                        return;
                    } catch (error) {
                        console.error('Error parsing JSON:', error);
                    }
                }

                // Direct fetch failed, use invisible iframe authentication
                console.warn('‚ùå Direct fetch failed, starting invisible authentication');
                authenticateWithInvisibleIframe(resolve, reject);
            },
            onerror: function(error) {
                console.error('Network error, starting invisible authentication:', error);
                authenticateWithInvisibleIframe(resolve, reject);
            }
        });
    });
}

function authenticateWithInvisibleIframe(resolve, reject, authRetryCount = 0, maxAuthRetries = 2) {
    console.log(`üîê Starting invisible iframe authentication (attempt ${authRetryCount + 1}/${maxAuthRetries + 1})...`);

    // Create invisible iframe
    const iframe = document.createElement('iframe');
    iframe.src = 'https://drive-render.corp.amazon.com/view/SSD%20Central%20Operations/Scripts/UFO/UFO_Site_list.json';
    iframe.style.cssText = `
        position: absolute;
        left: -9999px;
        top: -9999px;
        width: 1px;
        height: 1px;
        border: none;
        opacity: 0;
        pointer-events: none;
        visibility: hidden;
    `;

    // Optional: Add a small status indicator for debugging
    const statusIndicator = document.createElement('div');
    statusIndicator.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 123, 255, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        font-family: Arial, sans-serif;
        z-index: 10000;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    `;
    statusIndicator.textContent = `üîê Authenticating... (${authRetryCount + 1}/${maxAuthRetries + 1})`;

    // Add elements to page
    document.body.appendChild(iframe);
    document.body.appendChild(statusIndicator);

    let authCompleted = false;

    // Wait 5 seconds for authentication, then cleanup and refresh
    const authTimeout = setTimeout(() => {
        if (authCompleted) return;
        authCompleted = true;

        console.log(`‚úÖ Invisible authentication completed (attempt ${authRetryCount + 1})`);

        // Remove iframe and status
        document.body.removeChild(iframe);

        // Update status
        statusIndicator.textContent = '‚úÖ Authentication complete - Refreshing...';
        statusIndicator.style.background = 'rgba(40, 167, 69, 0.9)';

        // Remove status after brief delay and refresh
        setTimeout(() => {
            document.body.removeChild(statusIndicator);

            // Refresh page to verify authentication worked
            window.location.reload();
        }, 1500);

    }, 5000); // 5 second authentication window

    // Handle iframe load error with retry
    iframe.onerror = function() {
        if (authCompleted) return;
        authCompleted = true;

        console.error(`‚ùå Iframe failed to load (attempt ${authRetryCount + 1})`);
        clearTimeout(authTimeout);
        document.body.removeChild(iframe);

        // Retry authentication if attempts remaining
        if (authRetryCount < maxAuthRetries) {
            statusIndicator.textContent = `üîÑ Retrying authentication... (${authRetryCount + 2}/${maxAuthRetries + 1})`;
            statusIndicator.style.background = 'rgba(255, 193, 7, 0.9)';

            setTimeout(() => {
                document.body.removeChild(statusIndicator);
                authenticateWithInvisibleIframe(resolve, reject, authRetryCount + 1, maxAuthRetries);
            }, 2000);
            return;
        }

        // All authentication retries exhausted
        if (document.body.contains(statusIndicator)) {
            statusIndicator.textContent = '‚ùå Authentication failed - Please try manually';
            statusIndicator.style.background = 'rgba(220, 53, 69, 0.9)';

            setTimeout(() => {
                document.body.removeChild(statusIndicator);
                reject(new Error('Invisible authentication failed after retries'));
            }, 3000);
        }
    };

    // Handle successful iframe load (optional - mainly for debugging)
    iframe.onload = function() {
        console.log(`üì° Iframe loaded successfully (attempt ${authRetryCount + 1})`);
        // Don't do anything here - let the timeout handle completion
    };
}

// Add cache management UI to the header controls
function addCacheControls() {
    const headerControls = document.querySelector('.ufo-header-controls');
    if (!headerControls) return;

    // Add cache status indicator
    const cacheStatus = document.createElement('span');
    cacheStatus.id = 'cacheStatus';
    cacheStatus.style.cssText = `
        color: rgba(255, 255, 255, 0.8);
        font-size: 12px;
        margin-right: 10px;
    `;

    // Add force refresh button
    const forceRefreshBtn = document.createElement('button');
    forceRefreshBtn.textContent = 'Force Refresh Config';
    forceRefreshBtn.title = 'Clear cache and fetch fresh configuration';
    forceRefreshBtn.addEventListener('click', async () => {
        forceRefreshBtn.disabled = true;
        forceRefreshBtn.textContent = 'Refreshing...';

        try {
            await CONFIG_CACHE.forceRefresh();
            updateCacheStatus();
            // Reload the page to apply new config
            location.reload();
        } catch (error) {
            console.error('Force refresh failed:', error);
            forceRefreshBtn.textContent = 'Refresh Failed';
            setTimeout(() => {
                forceRefreshBtn.disabled = false;
                forceRefreshBtn.textContent = 'Force Refresh Config';
            }, 2000);
        }
    });

    headerControls.appendChild(cacheStatus);
    headerControls.appendChild(forceRefreshBtn);

    updateCacheStatus();
}

// Update cache status display
function updateCacheStatus() {
    const statusElement = document.getElementById('cacheStatus');
    if (!statusElement) return;

    const timestamp = localStorage.getItem(CONFIG_CACHE.timestampKey);
    if (!timestamp) {
        statusElement.textContent = 'Config: Not cached';
        return;
    }

    const age = Date.now() - parseInt(timestamp);
    const hours = Math.floor(age / (1000 * 60 * 60));
    const minutes = Math.floor((age % (1000 * 60 * 60)) / (1000 * 60));

    if (CONFIG_CACHE.isValid()) {
        statusElement.textContent = `Config: Cached (${hours}h ${minutes}m ago)`;
        statusElement.style.color = 'rgba(255, 255, 255, 0.8)';
    } else {
        statusElement.textContent = `Config: Expired (${hours}h ${minutes}m ago)`;
        statusElement.style.color = '#ffeb3b';
    }
}

// Initialize cache controls when UI is ready
document.addEventListener('DOMContentLoaded', () => {
    // Add controls after a short delay to ensure header exists
    setTimeout(addCacheControls, 500);
});

// Function to create the site selector dropdown options
function createSiteOptions(siteTimeZones) {
    let options = '<option value="" disabled selected>Select a site</option>';

    // Sort sites alphabetically
    const sortedSites = Object.keys(siteTimeZones).sort();

    sortedSites.forEach(site => {
        const timezone = siteTimeZones[site];
        options += `<option value="${site}">${site} (${timezone})</option>`;
    });

    return options;
}

// Function to get CPT options for a specific site
function getCPTOptions(site, defaultCPTs, specialCPTs) {
    const cpts = specialCPTs && specialCPTs[site] ? specialCPTs[site] : defaultCPTs;
    let options = '';

    cpts.forEach(cpt => {
        options += `<option value="${cpt}">${cpt}</option>`;
    });

    return options;
}

// Function to initialize the site configuration
async function initializeSiteConfig() {
    try {
        const config = await fetchSiteConfiguration();

        // Update centralized state using the appState we created earlier
        appState.config.site = Object.freeze(config);
        appState.updateConfig('timeZones', config.timeZones || {});
        appState.updateConfig('siteTimeZones', config.siteTimeZones || {});
        appState.updateConfig('complementaryStations', config.complementaryStations || {});
        appState.updateConfig('defaultCPTs', config.defaultCPTs || []);
        appState.updateConfig('specialCPTs', config.specialCPTs || {});

        // Add PSSD site mapping configuration
        appState.updateConfig('siteDisplayNames', config.siteDisplayNames || {});
        appState.updateConfig('dataSourceMapping', config.dataSourceMapping || {});

        // Update legacy global variables for compatibility (these now reference the frozen state)
        siteConfig = appState.config.site;
        timeZones = appState.config.timeZones;
        siteTimeZones = appState.config.siteTimeZones;
        complementaryStations = appState.config.complementaryStations;
        defaultCPTs = appState.config.defaultCPTs;
        let specialCPTs = {
            'SNY1': ['01:35', '05:35', '10:25', '15:05'],
            'STX4': ['00:20', '06:20', '11:20', '14:20', '18:20', '20:20'],
            'SAZ2': ['00:20', '06:20', '11:20', '14:20', '18:20', '20:20']
        };

        console.log('Initialized site config:', appState.config.site);
        updateUIElements();
        return true;
    } catch (error) {
        console.error('Error initializing site configuration:', error);
        return false;
    }
}

// Helper function to get the actual site code (handles PSSD mapping)
function getActualSiteCode(selectedSite) {
    // Check if this is a PSSD site that needs mapping
    const dataSourceMapping = appState.config.dataSourceMapping || {};
    const actualSite = dataSourceMapping[selectedSite] || selectedSite;

    console.log(`Site mapping: ${selectedSite} -> ${actualSite}`);
    return actualSite;
}

// Helper function to get display name for a site
function getSiteDisplayName(selectedSite) {
    const siteDisplayNames = appState.config.siteDisplayNames || {};
    return siteDisplayNames[selectedSite] || selectedSite;
}

// Example usage in your site selection logic:
function handleSiteSelection(selectedSite) {
    // Get the actual site code for data fetching
    const actualSiteCode = getActualSiteCode(selectedSite);

    // Get the display name for UI
    const displayName = getSiteDisplayName(selectedSite);

    console.log(`Selected: ${selectedSite}`);
    console.log(`Actual site code for data: ${actualSiteCode}`);
    console.log(`Display name: ${displayName}`);

    // Use actualSiteCode when fetching data
    // Use selectedSite when getting CPTs (to preserve PSSD-specific schedules)
    // Use displayName for UI display

    return {
        selected: selectedSite,
        dataSource: actualSiteCode,
        displayName: displayName
    };
}

// Function to update UI elements after configuration is loaded
function updateUIElements() {
    // Keep original timing but add memory leak prevention
    setTimeout(() => {
        // Update site selector dropdown
        const siteSelector = document.getElementById('siteSelector');
        if (siteSelector) {
            siteSelector.innerHTML = createSiteOptions(siteTimeZones);

            // Remove any existing change listener to prevent duplicates
            if (siteSelector.ufoChangeHandler) {
                siteSelector.removeEventListener('change', siteSelector.ufoChangeHandler);
            }

            // Create and store new event listener
            siteSelector.ufoChangeHandler = function() {
                const selectedSite = this.value;
                const cptSelect = document.getElementById('cptSelect');
                if (cptSelect) {
                    cptSelect.innerHTML = getCPTOptions(selectedSite, defaultCPTs, specialCPTs);
                }
            };

            siteSelector.addEventListener('change', siteSelector.ufoChangeHandler);
        }

        // Update CPT selector with default options
        const cptSelector = document.getElementById('cptSelect');
        if (cptSelector) {
            cptSelector.innerHTML = getCPTOptions(null, defaultCPTs, specialCPTs);
        }
    }, 100);
}

// Function to create the UI container
function createUIContainer() {
    // Check if container already exists
    let container = document.getElementById('siteConfigContainer');
    if (container) {
        return; // Don't create duplicate
    }

    // Create container
    container = document.createElement('div');
    container.id = 'siteConfigContainer';
    container.style.position = 'fixed';
    container.style.top = '60px';
    container.style.left = '10px';
    container.style.backgroundColor = '#ffffff';
    container.style.padding = '20px';
    container.style.zIndex = '10000';
    container.style.width = '280px';
    container.style.fontSize = '24px';
    container.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
    container.style.borderRadius = '12px';
    container.style.backdropFilter = 'blur(10px)';
    container.style.transition = 'all 0.3s ease';
    container.style.opacity = '0';
    container.style.transform = 'translateY(-10px)';

    // Create the HTML structure
    container.innerHTML = `
        <h3>Select Site</h3>
        <select id="siteSelector" style="font-size: 20px;">
            <option value="" disabled selected>Loading sites...</option>
        </select>
        <br>
        <label for="cptSelect">What CPT?</label>
        <select id="cptSelect" style="font-size: 20px;">
            <option value="" disabled selected>Loading CPTs...</option>
        </select>
        <br>
        <label for="pickRate">What Pick Rate?</label>
        <input type="text" id="pickRate" value="300" style="font-size: 20px;">
        <br>
        <label for="packRate">What Pack Rate?</label>
        <input type="text" id="packRate" value="300" style="font-size: 20px;">
        <button id="updateRatesButton" style="font-size: 20px; margin-left: 10px;">Update Rates</button>
    `;

    // Add to page
    document.body.appendChild(container);

    // Animate in
    setTimeout(() => {
        container.style.opacity = '1';
        container.style.transform = 'translateY(0)';
    }, 100);
}

// Helper function to get site configuration data
function getSiteConfigData(siteName) {
    if (!siteTimeZones || !siteTimeZones[siteName]) {
        console.warn(`Site "${siteName}" not found. Using default data.`);
        return {
            timezone: 'EST',
            complementaryStation: null,
            cpts: defaultCPTs || ['00:20', '06:20', '11:20', '14:20', '18:20']
        };
    }
    const timezone = siteTimeZones[siteName];
    const complementaryStation = complementaryStations[siteName];

    // If site is in specialCPTs, use those times and add '20:20'
    // If not in specialCPTs, use defaultCPTs without '20:20'
    const baseCpts = specialCPTs && specialCPTs[siteName] ? specialCPTs[siteName] : defaultCPTs;
    const cpts = specialCPTs && specialCPTs[siteName] ? [...baseCpts, '20:20'] : baseCpts;

    return {
        timezone,
        complementaryStation,
        cpts
    };
}

// Main initialization function
async function initializeUI() {
    try {
        // First create the UI container
        createUIContainer();

        // Then initialize the configuration
        const success = await initializeSiteConfig();

        if (success) {
            console.log('UI initialized successfully with fetched site configuration');
        } else {
            throw new Error('Failed to load site configuration');
        }

    } catch (error) {
        console.error('Failed to initialize UI:', error);

        // Show error message
        const container = document.getElementById('siteConfigContainer');
        if (container) {
            container.innerHTML = `
                <h3>Configuration Error</h3>
                <p>Failed to load site configuration:</p>
                <p><strong>${error.message}</strong></p>
                <p>Please check the JSON file URL and network connection.</p>
            `;
            Object.assign(container.style, {
                backgroundColor: '#ffebee',
                color: '#c62828',
                border: '2px solid #e57373'
            });
        }
    }
}

// Wait for page to load before initializing
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeUI);
} else {
    initializeUI();
}

// Utility function to create styled containers with consistent properties
function createStyledContainer(id, styles = {}) {
    // Check if container already exists to prevent duplicates
    let container = document.getElementById(id);
    if (container) {
        return container;
    }

    container = document.createElement('div');
    container.id = id;

    // Base styles that are common across containers
    const baseStyles = {
        position: 'fixed',
        zIndex: '10000',
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
        backgroundColor: 'white',
        boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
        borderRadius: '12px',
        transition: 'all 0.3s ease',
        padding: '15px 20px'
    };

    // Merge base styles with custom styles
    Object.assign(container.style, baseStyles, styles);

    return container;
}

// Reusable hover effect function
function addHoverEffect(element) {
    element.addEventListener('mouseover', () => {
        element.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.15)';
    });

    element.addEventListener('mouseout', () => {
        element.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
    });
}

// Create elongation div
const elongationDiv = createStyledContainer('pageElongation', {
    position: 'static',
    height: '3000px',
    backgroundColor: 'transparent',
    boxShadow: 'none',
    borderRadius: '0',
    padding: '0'
});
document.body.appendChild(elongationDiv);

// Create clock container
const clockContainer = createStyledContainer('clockContainer', {
    top: '60px',
    right: '10px',
    whiteSpace: 'nowrap',
    fontSize: '3em',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
});
addHoverEffect(clockContainer);
document.body.appendChild(clockContainer);

// Create CPT info container
const cptInfoContainer = createStyledContainer('cptInfoContainer', {
    top: '130px',
    right: '10px',
    fontSize: '2em',
    opacity: '0',
    transform: 'translateY(-10px)'
});

cptInfoContainer.innerHTML = `
    <div style="
        margin: -15px -20px 10px -20px;
        padding: 15px 20px;
        background-color: #f8fafc;
        border-bottom: 2px solid #e2e8f0;
        border-radius: 12px 12px 0 0;
        font-weight: 500;
    ">Current CPT: N/A</div>
    <div style="
        color: #2d3748;
        font-weight: 500;
    ">Processing Time Left for CPT: N/A</div>
`;

addHoverEffect(cptInfoContainer);

// Animate CPT info container
setTimeout(() => {
    Object.assign(cptInfoContainer.style, {
        opacity: '1',
        transform: 'translateY(0)'
    });
}, 100);

document.body.appendChild(cptInfoContainer);

// Create next CPT info container
const nextCPTInfoTableContainer = createStyledContainer('nextCPTInfoTableContainer', {
    top: '900px',
    right: '10px',
    fontSize: '2em',
    width: 'auto'
});
addHoverEffect(nextCPTInfoTableContainer);
document.body.appendChild(nextCPTInfoTableContainer);

// Create timestamp container
const timestampContainer = createStyledContainer('timestampContainer', {
    top: '70px',
    left: '50%',
    transform: 'translateX(-50%)',
    zIndex: '10001',
    fontSize: '1.5em',
    display: 'flex',
    alignItems: 'center',
    backdropFilter: 'blur(10px)',
    background: 'linear-gradient(to right, #4CAF50 0%, #4CAF50 100%)',
    backgroundSize: '0% 100%',
    backgroundRepeat: 'no-repeat',
    color: 'black',
    fontWeight: 'bold',
    padding: '12px 20px'
});
document.body.appendChild(timestampContainer);

// Timer management
let refreshTimerInterval = null;

// Cleanup function for page unload
window.addEventListener('beforeunload', () => {
    if (refreshTimerInterval) {
        clearInterval(refreshTimerInterval);
        refreshTimerInterval = null;
    }
});

function startRefreshTimer() {
    if (refreshTimerInterval) {
        clearInterval(refreshTimerInterval);
        refreshTimerInterval = null;
    }

    const timestampContainer = document.getElementById('timestampContainer');
    if (!timestampContainer) return;

    const duration = 600; // 10 minutes in seconds
    let startTime = Date.now();

    // Complete the startRefreshTimer function
function updateProgressBar() {
    const elapsed = (Date.now() - startTime) / 1000;
    const progress = (elapsed / duration) * 100;

    if (progress >= 100) {
        startTime = Date.now();
        const refreshButton = document.getElementById('refreshButton');
        if (refreshButton) {
            refreshButton.click();
        }
    } else {
        timestampContainer.style.backgroundSize = `${progress}% 100%`;
    }
}

timestampContainer.style.background = 'linear-gradient(to right, #4CAF50 0%, #4CAF50 100%)';
timestampContainer.style.backgroundSize = '0% 100%';
timestampContainer.style.backgroundRepeat = 'no-repeat';
refreshTimerInterval = setInterval(updateProgressBar, 1000);
}

// Create refresh button - keeping original structure but consolidating styles
let refreshButton = document.createElement('button');
refreshButton.id = 'refreshButton';
refreshButton.textContent = 'Refresh';

// Consolidate button styles
Object.assign(refreshButton.style, {
    padding: '8px 16px',
    marginRight: '15px',
    border: 'none',
    borderRadius: '8px',
    backgroundColor: '#2193b0',
    color: 'white',
    fontSize: '16px',
    cursor: 'pointer',
    transition: 'all 0.3s ease',
    fontWeight: '500'
});

refreshButton.addEventListener('mouseover', () => {
    refreshButton.style.backgroundColor = '#1a7a8c';
    refreshButton.style.transform = 'translateY(-1px)';
});

refreshButton.addEventListener('mouseout', () => {
    refreshButton.style.backgroundColor = '#2193b0';
    refreshButton.style.transform = 'translateY(0)';
});

refreshButton.addEventListener('mousedown', () => {
    refreshButton.style.transform = 'translateY(1px)';
});

refreshButton.addEventListener('mouseup', () => {
    refreshButton.style.transform = 'translateY(-1px)';
});

let timestampText = document.createElement('span');
timestampText.id = 'timestampText';
timestampText.textContent = 'Last Refresh: Not yet refreshed';
Object.assign(timestampText.style, {
    color: '#4a5568',
    fontWeight: '500'
});

timestampContainer.addEventListener('mouseover', () => {
    timestampContainer.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.15)';
});

timestampContainer.addEventListener('mouseout', () => {
    timestampContainer.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
});

timestampContainer.appendChild(refreshButton);
timestampContainer.appendChild(timestampText);

Object.assign(timestampContainer.style, {
    opacity: '0',
    transform: 'translate(-50%, -10px)'
});

setTimeout(() => {
    Object.assign(timestampContainer.style, {
        opacity: '1',
        transform: 'translate(-50%, 0)'
    });
}, 100);

document.body.appendChild(timestampContainer);

let currentCPTInfoBox = document.createElement('div');
currentCPTInfoBox.id = 'currentCPTInfoBox';

// Consolidate currentCPTInfoBox styles
Object.assign(currentCPTInfoBox.style, {
    position: 'fixed',
    left: '10px',
    fontSize: '20px',
    top: '380px',
    padding: '20px',
    backgroundColor: '#ffffff',
    boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
    borderRadius: '12px',
    minWidth: '200px',
    transition: 'all 0.3s ease',
    opacity: '0',
    transform: 'translateY(-10px)',
    backdropFilter: 'blur(10px)'
});

currentCPTInfoBox.addEventListener('mouseover', () => {
    currentCPTInfoBox.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.15)';
});

currentCPTInfoBox.addEventListener('mouseout', () => {
    currentCPTInfoBox.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
});

setTimeout(() => {
    Object.assign(currentCPTInfoBox.style, {
        opacity: '1',
        transform: 'translateY(0)'
    });
}, 100);

document.body.appendChild(currentCPTInfoBox);

let nextCPTInfoBox = document.createElement('div');
nextCPTInfoBox.id = 'nextCPTInfoBox';

// Consolidate nextCPTInfoBox styles
Object.assign(nextCPTInfoBox.style, {
    position: 'fixed',
    left: '10px',
    fontSize: '20px',
    top: '700px',
    padding: '20px',
    backgroundColor: '#ffffff',
    boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
    borderRadius: '12px',
    minWidth: '200px',
    transition: 'all 0.3s ease',
    opacity: '0',
    transform: 'translateY(-10px)',
    backdropFilter: 'blur(10px)'
});

nextCPTInfoBox.addEventListener('mouseover', () => {
    nextCPTInfoBox.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.15)';
});

nextCPTInfoBox.addEventListener('mouseout', () => {
    nextCPTInfoBox.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
});

setTimeout(() => {
    Object.assign(nextCPTInfoBox.style, {
        opacity: '1',
        transform: 'translateY(0)'
    });
}, 100);

document.body.appendChild(nextCPTInfoBox);

let maxWallsContainer = document.createElement('div');

// Consolidate maxWallsContainer styles
Object.assign(maxWallsContainer.style, {
    position: 'fixed',
    top: '60px',
    left: '330px',
    backgroundColor: 'white',
    border: '1px solid black',
    padding: '10px',
    zIndex: '10000',
    width: '130px',
    fontSize: '24px',
    boxSizing: 'border-box'
});

maxWallsContainer.innerHTML = `
    <label for="maxWalls">Max Walls:</label>
    <select id="maxWalls" style="font-size: 20px; width: 100%; box-sizing: border-box;">
        ${Array.from({length: 30}, (_, i) => i + 1).map(num =>
            `<option value="${num}">${num}</option>`
        ).join('')}
    </select>
`;

document.body.appendChild(maxWallsContainer);

const settingsStyle = document.createElement('style');
settingsStyle.textContent = `
    #settingsButton {
        position: fixed;
        top: 10px;
        left: 270px;
        z-index: 10001;
        padding: 5px 10px;
        font-size: 16px;
    }
    #settingsPopup {
        display: none;
        position: fixed;
        top: 50px;
        left: 270px;
        background-color: white;
        border: 1px solid black;
        padding: 15px;
        z-index: 10002;
    }
    #planningRiskMultiplier {
        width: 60px;
        margin-right: 10px;
    }
`;
document.head.appendChild(settingsStyle);

function createSettingsButton() {
    // Check if button already exists to prevent duplicates
    if (document.getElementById('settingsButton')) {
        return;
    }

    const settingsButton = document.createElement('button');
    settingsButton.id = 'settingsButton';
    settingsButton.textContent = 'Current CPT Settings';

    // Consolidate button styles
    Object.assign(settingsButton.style, {
        position: 'fixed',
        top: '10px',
        left: '270px',
        zIndex: '10001',
        padding: '5px 10px',
        fontSize: '16px'
    });

    document.body.appendChild(settingsButton);
    addMathTablesButton();

    // Check if popup already exists to prevent duplicates
    let settingsPopup = document.getElementById('settingsPopup');
    if (!settingsPopup) {
        settingsPopup = document.createElement('div');
        settingsPopup.id = 'settingsPopup';
        settingsPopup.innerHTML = `
            <label for="planningRiskMultiplier">Planning risk multiplier:</label>
            <input type="number" id="planningRiskMultiplier" min="1.1" max="1.8" step="0.05" value="1.2">
            <br><br>
            <label for="riskModel">Current CPT Risk Model:</label>
            <select id="riskModel">
                <option value="CORA">CORA</option>
                <option value="ATROPS">ATROPS</option>
                <option value="MIXED">MIXED</option>
                <option value="Low Backlog">Low Backlog</option>
            </select>
            <br><br>
            <button id="saveSettings">Save</button>
        `;
        document.body.appendChild(settingsPopup);
    }

    // Initialize event listeners only once
    initializeSettingsEventListeners(settingsButton, settingsPopup);

    // Load saved values
    loadSavedSettings();
}

// Separate function to handle event listeners for better organization
function initializeSettingsEventListeners(settingsButton, settingsPopup) {
    // Remove any existing listeners to prevent duplicates
    if (settingsButton.ufoClickHandler) {
        settingsButton.removeEventListener('click', settingsButton.ufoClickHandler);
    }

    // Settings button click handler
    settingsButton.ufoClickHandler = () => {
        settingsPopup.style.display = 'block';
    };
    settingsButton.addEventListener('click', settingsButton.ufoClickHandler);

    // Risk model change listener
    const riskModelSelect = settingsPopup.querySelector('#riskModel');
    if (riskModelSelect && !riskModelSelect.ufoChangeHandler) {
        riskModelSelect.ufoChangeHandler = function() {
            userSelectedRiskModel = true;
            localStorage.setItem('userSelectedRiskModel', 'true');
        };
        riskModelSelect.addEventListener('change', riskModelSelect.ufoChangeHandler);
    }

    // Save settings button
    const saveButton = settingsPopup.querySelector('#saveSettings');
    if (saveButton && !saveButton.ufoClickHandler) {
        saveButton.ufoClickHandler = () => {
            const multiplier = document.getElementById('planningRiskMultiplier').value;
            const riskModel = document.getElementById('riskModel').value;

            // Save to localStorage
            localStorage.setItem('planningRiskMultiplier', multiplier);
            localStorage.setItem('currentCPTRiskModel', riskModel);

            // Hide popup and update
            settingsPopup.style.display = 'none';
            createAndUpdateMathTable();
            updateRiskModel();
        };
        saveButton.addEventListener('click', saveButton.ufoClickHandler);
    }

    // Click outside to close - use named function for easier cleanup
    if (!document.ufoSettingsClickOutside) {
        document.ufoSettingsClickOutside = (event) => {
            if (!settingsPopup.contains(event.target) && event.target !== settingsButton) {
                settingsPopup.style.display = 'none';
            }
        };
        document.addEventListener('click', document.ufoSettingsClickOutside);
    }
}

// Separate function for loading saved settings
function loadSavedSettings() {
    // Load saved multiplier
    const savedMultiplier = localStorage.getItem('planningRiskMultiplier');
    const multiplierInput = document.getElementById('planningRiskMultiplier');
    if (savedMultiplier && multiplierInput) {
        multiplierInput.value = savedMultiplier;
    }

    // Load saved risk model
    const savedRiskModel = localStorage.getItem('currentCPTRiskModel');
    const riskModelSelect = document.getElementById('riskModel');
    if (savedRiskModel && riskModelSelect) {
        riskModelSelect.value = savedRiskModel;
    }

    // Load user selection state
    userSelectedRiskModel = localStorage.getItem('userSelectedRiskModel') === 'true';
}

// Cleanup function for settings (call on page unload)
function cleanupSettings() {
    // Remove click outside listener
    if (document.ufoSettingsClickOutside) {
        document.removeEventListener('click', document.ufoSettingsClickOutside);
        document.ufoSettingsClickOutside = null;
    }

    // Clean up button listeners
    const settingsButton = document.getElementById('settingsButton');
    if (settingsButton && settingsButton.ufoClickHandler) {
        settingsButton.removeEventListener('click', settingsButton.ufoClickHandler);
        settingsButton.ufoClickHandler = null;
    }

    // Clean up risk model listener
    const riskModelSelect = document.getElementById('riskModel');
    if (riskModelSelect && riskModelSelect.ufoChangeHandler) {
        riskModelSelect.removeEventListener('change', riskModelSelect.ufoChangeHandler);
        riskModelSelect.ufoChangeHandler = null;
    }

    // Clean up save button listener
    const saveButton = document.getElementById('saveSettings');
    if (saveButton && saveButton.ufoClickHandler) {
        saveButton.removeEventListener('click', saveButton.ufoClickHandler);
        saveButton.ufoClickHandler = null;
    }
}

// Add to main cleanup on page unload
window.addEventListener('beforeunload', cleanupSettings);

function updateCPTDisplay(container, cpt, timeLeft, isNext = false) {
    try {
        // Validate inputs
        if (!container) {
            console.error('updateCPTDisplay: Container parameter is required');
            return false;
        }

        if (!cpt || typeof cpt !== 'string') {
            console.error('updateCPTDisplay: Valid CPT parameter is required');
            return false;
        }

        if (!timeLeft || typeof timeLeft !== 'string') {
            console.error('updateCPTDisplay: Valid timeLeft parameter is required');
            return false;
        }

        // Sanitize inputs to prevent XSS
        const sanitizedCpt = String(cpt).replace(/[<>&"]/g, (char) => {
            const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
            return entities[char] || char;
        });

        const sanitizedTimeLeft = String(timeLeft).replace(/[<>&"]/g, (char) => {
            const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
            return entities[char] || char;
        });

        container.innerHTML = `
            <div style="
                margin: -15px -20px 10px -20px;
                padding: 15px 20px;
                background-color: #f8fafc;
                border-bottom: 2px solid #e2e8f0;
                border-radius: 12px 12px 0 0;
                font-weight: 500;
                margin-right: 80px;
                max-width: calc(100% - 60px);
                position: relative;
                z-index: 1000;
            ">${isNext ? 'Next' : 'Current'} CPT: ${sanitizedCpt}</div>
            <div style="
                color: #2d3748;
                font-weight: 500;
                margin-right: 80px;
                padding-right: 20px;
                max-width: calc(100% - 80px);
                position: relative;
                z-index: 1000;
            ">Processing Time Left for CPT: ${sanitizedTimeLeft}</div>
        `;

        return true;

    } catch (error) {
        console.error('updateCPTDisplay: Unexpected error:', error);
        return false;
    }
}

function addMathTablesButton() {
    // Check if button already exists to prevent duplicates
    if (document.getElementById('mathTablesButton')) {
        return;
    }

    const mathButton = document.createElement('button');
    mathButton.id = 'mathTablesButton';
    mathButton.textContent = "Plan's Math";

    // Consolidate styles
    Object.assign(mathButton.style, {
        position: 'fixed',
        top: '10px',
        left: '30px',
        zIndex: '10001',
        padding: '5px 10px',
        fontSize: '16px'
    });

    // Store click handler for cleanup
    mathButton.ufoClickHandler = showMathTablesPopup;
    mathButton.addEventListener('click', mathButton.ufoClickHandler);

    document.body.appendChild(mathButton);
}

// Cleanup function for math tables button
function cleanupMathTablesButton() {
    const mathButton = document.getElementById('mathTablesButton');
    if (mathButton && mathButton.ufoClickHandler) {
        mathButton.removeEventListener('click', mathButton.ufoClickHandler);
        mathButton.ufoClickHandler = null;
    }
}

function showMathTablesPopup() {
    // Check if popup already exists to prevent duplicates
    const existingPopup = document.querySelector('.math-tables-popup');
    if (existingPopup) {
        existingPopup.remove();
    }

    const popup = document.createElement('div');
    popup.className = 'math-tables-popup'; // Use class for identification

    // Consolidate popup styles
    Object.assign(popup.style, {
        position: 'fixed',
        left: '50%',
        top: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: 'white',
        padding: '30px',
        border: '2px solid black',
        borderRadius: '8px',
        zIndex: '10002',
        maxHeight: '90vh',
        overflowY: 'auto',
        minWidth: '900px',
        maxWidth: '1200px',
        boxShadow: '0 4px 8px rgba(0,0,0,0.2)',
        animation: 'fadeIn 0.3s ease-in-out'
    });

    const title = document.createElement('h2');
    title.textContent = 'CPT Math Tables';
    Object.assign(title.style, {
        marginBottom: '20px',
        borderBottom: '2px solid #ccc',
        paddingBottom: '10px',
        textAlign: 'center',
        color: '#2c3e50',
        fontSize: '24px'
    });

    const closeButton = document.createElement('button');
    closeButton.textContent = '‚úï';
    Object.assign(closeButton.style, {
        position: 'absolute',
        right: '15px',
        top: '15px',
        border: 'none',
        background: 'none',
        fontSize: '24px',
        cursor: 'pointer',
        color: '#666',
        padding: '5px',
        lineHeight: '1',
        transition: 'all 0.2s ease'
    });

    // Use addEventListener instead of onmouseover for better memory management
    closeButton.addEventListener('mouseover', () => {
        Object.assign(closeButton.style, {
            color: '#000',
            transform: 'scale(1.1)'
        });
    });

    closeButton.addEventListener('mouseout', () => {
        Object.assign(closeButton.style, {
            color: '#666',
            transform: 'scale(1)'
        });
    });

    const tableContainer = document.createElement('div');
    Object.assign(tableContainer.style, {
        display: 'flex',
        flexDirection: 'column',
        gap: '30px',
        padding: '20px'
    });

    // Create headers with shared styling function
    function createSectionHeader(text, borderColor) {
        const header = document.createElement('h3');
        header.textContent = text;
        Object.assign(header.style, {
            color: '#2c3e50',
            marginBottom: '15px',
            fontSize: '20px',
            borderLeft: `4px solid ${borderColor}`,
            paddingLeft: '10px'
        });
        return header;
    }

    const currentHeader = createSectionHeader('Current CPT Math Table', '#3498db');
    const nextHeader = createSectionHeader('Next CPT Math Table', '#e74c3c');
    const nextNextHeader = createSectionHeader('CPT+2 Math Table', '#2ecc71');

    // Create dividers with shared styling
    function createDivider() {
        const divider = document.createElement('hr');
        Object.assign(divider.style, {
            margin: '30px 0',
            border: 'none',
            borderTop: '1px solid #eee'
        });
        return divider;
    }

    const divider1 = createDivider();
    const divider2 = createDivider();

    // Get original tables and clone their content
    const tableIds = ['mathTableContainer', 'nextCPTMathTableContainer', 'nextNextCPTMathTableContainer'];
    const displayContainers = tableIds.map(id => {
        const originalTable = document.getElementById(id);
        const container = document.createElement('div');
        if (originalTable) {
            container.innerHTML = originalTable.innerHTML;

            // Style the cloned table
            const table = container.querySelector('table');
            if (table) {
                Object.assign(table.style, {
                    width: '100%',
                    marginBottom: '20px',
                    fontSize: '14px'
                });

                // Style headers
                table.querySelectorAll('th').forEach(header => {
                    Object.assign(header.style, {
                        backgroundColor: '#f2f2f2',
                        padding: '10px',
                        border: '1px solid #ddd'
                    });
                });

                // Style cells
                table.querySelectorAll('td').forEach(cell => {
                    Object.assign(cell.style, {
                        padding: '8px',
                        border: '1px solid #ddd'
                    });
                });
            }
        }
        return container;
    });

    // Append all elements to table container
    tableContainer.appendChild(currentHeader);
    tableContainer.appendChild(displayContainers[0]);
    tableContainer.appendChild(divider1);
    tableContainer.appendChild(nextHeader);
    tableContainer.appendChild(displayContainers[1]);
    tableContainer.appendChild(divider2);
    tableContainer.appendChild(nextNextHeader);
    tableContainer.appendChild(displayContainers[2]);

    popup.appendChild(closeButton);
    popup.appendChild(title);
    popup.appendChild(tableContainer);

    document.body.appendChild(popup);

    // Store original overflow for restoration
    const originalStyle = document.body.style.overflow;
    document.body.style.overflow = 'hidden';

    // Cleanup function with proper event listener removal
    const cleanup = () => {
        popup.remove();
        document.body.style.overflow = originalStyle;

        // Remove event listeners
        document.removeEventListener('keydown', escapeHandler);
    };

    // Named function for easier cleanup
    const escapeHandler = (e) => {
        if (e.key === 'Escape') cleanup();
    };

    // Event listeners
    closeButton.addEventListener('click', cleanup);
    popup.addEventListener('click', (e) => {
        if (e.target === popup) cleanup();
    });
    document.addEventListener('keydown', escapeHandler);

    // Add animation styles only once
    addPopupAnimationStyles();
}

// Separate function to add animation styles (prevents duplicates)
function addPopupAnimationStyles() {
    if (!document.querySelector('#popupAnimation')) {
        const style = document.createElement('style');
        style.id = 'popupAnimation';
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translate(-50%, -48%); }
                to { opacity: 1; transform: translate(-50%, -50%); }
            }
        `;
        document.head.appendChild(style);
    }
}

// Create ExSD Box with duplicate prevention
function createExSDBox() {
    // Check if box already exists
    if (document.getElementById('exSDBox')) {
        return;
    }

    const exSDBox = document.createElement('div');
    exSDBox.id = 'exSDBox';

    Object.assign(exSDBox.style, {
        position: 'fixed',
        left: '300px',
        top: '360px',
        padding: '10px',
        width: '350px',
        backgroundColor: 'white'
    });

    document.body.appendChild(exSDBox);
}

// Create ExSD styles with duplicate prevention
function createExSDStyles() {
    if (!document.querySelector('#exSDStyles')) {
        const exSDStyle = document.createElement('style');
        exSDStyle.id = 'exSDStyles';
        exSDStyle.textContent = `
            #exSDBox {
                font-family: Arial, sans-serif;
                font-size: 15px;
                background-color: transparent !important;
            }
            #exSDBox table {
                margin-bottom: 20px;
                border: 2px solid #666;
                width: 100%;
                background-color: rgba(255, 255, 255, 0.7);
            }
            #exSDBox td, #exSDBox th {
                border: 1px solid #ccc;
                padding: 3px 5px;
            }
            #exSDBox h3 {
                font-weight: bold;
                margin: 15px 0 10px 0;
                font-size: 15px;
            }
            #exSDBox td:first-child {
                max-width: 120px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            #exSDBox .category-header {
                background-color: rgba(240, 240, 240, 0.7);
                padding: 4px 6px;
                margin-top: 12px;
                margin-bottom: 8px;
                font-weight: bold;
                font-size: 20px;
            }
        `;
        document.head.appendChild(exSDStyle);
    }
}

// Create table container with duplicate prevention
function createTableContainer() {
    if (document.getElementById('tableContainer')) {
        return;
    }

    const tableContainer = document.createElement('div');
    tableContainer.id = 'tableContainer';
    Object.assign(tableContainer.style, {
        marginTop: '320px',
        width: '33%'
    });
    document.body.appendChild(tableContainer);
}

// Initialize all components
createExSDBox();
createExSDStyles();
createSettingsButton();
createTableContainer();

// Global variables
let nextCPTRiskModel = 'MIXED';


// Function to update the clock based on selected site
function updateClock() {
    const siteSelector = document.getElementById('siteSelector');
    const cptSelect = document.getElementById('cptSelect');
    const clockContainer = document.getElementById('clockContainer');
    const cptInfoContainer = document.getElementById('cptInfoContainer');

    // Early return if required elements don't exist
    if (!siteSelector || !cptSelect || !clockContainer || !cptInfoContainer) {
        return;
    }

    const site = siteSelector.value;
    if (!site) {
        return;
    }

    // Get timezone with safety checks
    const siteTimezone = siteTimeZones[site];
    if (!siteTimezone || !timeZones[siteTimezone]) {
        console.warn(`Timezone not found for site: ${site}`);
        return;
    }

    const timeZone = timeZones[siteTimezone];
    const now = new Date(new Date().toLocaleString("en-US", { timeZone: timeZone }));

    // Format time efficiently
    const options = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
    const timeString = new Intl.DateTimeFormat('en-US', options).format(now);

    // Update clock content more efficiently
    clockContainer.innerHTML = `
        <div style="
            display: flex;
            align-items: center;
            padding: 5px 15px;
            color: #2d3748;
            font-weight: 500;
        ">Time (${timeZone}): ${timeString}</div>
    `;

    let currentCPT = cptSelect.value;
    if (!currentCPT) {
        return;
    }

    let cptTime = parseCPTTime(currentCPT, now);
    let timeLeft = new Date(cptTime - now);

    // Calculate time left in minutes
    const minutesLeft = Math.floor(timeLeft / 60000);

    // Auto-select next CPT if needed
    if (minutesLeft <= 30 && !manualCPTSelected) {
        selectNextCPT();
        // Update currentCPT and cptTime after selection
        currentCPT = cptSelect.value;
        cptTime = parseCPTTime(currentCPT, now);
        timeLeft = new Date(cptTime - now);
    }

    // Format time left string efficiently
    const timeLeftString = [
        timeLeft.getUTCHours(),
        timeLeft.getUTCMinutes(),
        timeLeft.getUTCSeconds()
    ].map(val => String(val).padStart(2, '0')).join(':');

    updateCPTDisplay(cptInfoContainer, currentCPT, timeLeftString);
    updateCPTInfo(now);
}

// Initialize clock hover effects only once
function initializeClockHoverEffects() {
    const clockContainer = document.getElementById('clockContainer');
    if (!clockContainer || clockContainer.ufoHoverInitialized) {
        return;
    }

    // Mark as initialized to prevent duplicate listeners
    clockContainer.ufoHoverInitialized = true;

    clockContainer.addEventListener('mouseover', () => {
        clockContainer.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.15)';
    });

    clockContainer.addEventListener('mouseout', () => {
        clockContainer.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
    });
}

// Call this once during initialization instead of inline
initializeClockHoverEffects();


function selectNextCPT() {
    const cptSelect = document.getElementById('cptSelect');

    // Safety checks
    if (!cptSelect || !cptSelect.options || cptSelect.options.length === 0) {
        console.warn('CPT selector not found or has no options');
        return false;
    }

    const currentIndex = cptSelect.selectedIndex;

    // Handle case where no option is currently selected
    if (currentIndex === -1) {
        cptSelect.selectedIndex = 0;
    } else {
        const nextIndex = (currentIndex + 1) % cptSelect.options.length;
        cptSelect.selectedIndex = nextIndex;
    }

    // Trigger change event to update related components
    try {
        cptSelect.dispatchEvent(new Event('change', { bubbles: true }));
        return true;
    } catch (error) {
        console.error('Failed to dispatch change event:', error);
        return false;
    }
}

// Function to convert military (24-hour) time to 12-hour AM/PM format
function militaryTo12Hour(militaryTime) {
    if (!militaryTime) return ''; // Add this check
    let [hours, minutes] = militaryTime.split(':').map(Number);
    let period = hours >= 12 ? 'PM' : 'AM';
    // Adjust hours to 12-hour format
    hours = hours % 12 || 12;
    return `${hours}:${minutes.toString().padStart(2, '0')} ${period}`;
}

function getSelectedCPT() {
    const cptElement = document.getElementById('cptSelect');
    if (!cptElement || !cptElement.value) {
        return ''; // or return a default value
    }
    return militaryTo12Hour(cptElement.value);
}

// Clock interval management to prevent memory leaks
let clockInterval = null;

function startClockUpdate() {
    // Clear any existing interval first
    if (clockInterval) {
        clearInterval(clockInterval);
    }

    // Start new interval
    clockInterval = setInterval(updateClock, 1000);
}

function stopClockUpdate() {
    if (clockInterval) {
        clearInterval(clockInterval);
        clockInterval = null;
    }
}

// Initialize refresh button with safety checks
function initializeRefreshButton() {
    const refreshBtn = document.getElementById('refreshButton');
    if (!refreshBtn) {
        console.warn('Refresh button not found');
        return;
    }

    // Remove existing listener if any to prevent duplicates
    if (refreshBtn.ufoRefreshHandler) {
        refreshBtn.removeEventListener('click', refreshBtn.ufoRefreshHandler);
    }

    // Create and store new handler
    refreshBtn.ufoRefreshHandler = function() {
        startRefreshTimer();
        refreshData();
        updateTimestamp();
        showLoadingGif();
        showLoadingGifForNextCPT();
    };

    refreshBtn.addEventListener('click', refreshBtn.ufoRefreshHandler);
}

// Initialize clock and refresh button
startClockUpdate();
initializeRefreshButton();

// Cleanup function for page unload
function cleanupClockAndRefresh() {
    stopClockUpdate();

    const refreshBtn = document.getElementById('refreshButton');
    if (refreshBtn && refreshBtn.ufoRefreshHandler) {
        refreshBtn.removeEventListener('click', refreshBtn.ufoRefreshHandler);
        refreshBtn.ufoRefreshHandler = null;
    }
}

// Add to main cleanup
window.addEventListener('beforeunload', cleanupClockAndRefresh);


// Function to clear old data with safety checks
function clearOldData() {
    const containers = ['tableContainer', 'fullTableContainer'];

    containers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = '';
        } else {
            console.warn(`Container '${containerId}' not found for clearing`);
        }
    });

    // Reset data loaded states
    if (typeof appState !== 'undefined') {
        // Use centralized state if available
        appState.setDataLoaded('schedule', false);
        appState.setDataLoaded('cora', false);
        appState.setDataLoaded('atrops', false);
    } else {
        // Fallback to legacy global state
        dataLoaded.schedule = false;
        dataLoaded.cora = false;
        dataLoaded.atrops = false;
    }

    // Clear global data
    globalData.schedule = null;
    globalData.cora = null;
    globalData.atrops = null;
}

// Enhanced global data management with better structure
let globalData = {
    schedule: null,
    cora: null,
    atrops: null,

    // Method to safely set data
    setData(type, data) {
        if (this.hasOwnProperty(type)) {
            this[type] = data;

            // Update corresponding data loaded state
            if (typeof appState !== 'undefined') {
                appState.setDataLoaded(type, data !== null);
            } else if (typeof dataLoaded !== 'undefined') {
                dataLoaded[type] = data !== null;
            }
        } else {
            console.warn(`Unknown data type: ${type}`);
        }
    },

    // Method to safely get data
    getData(type) {
        if (this.hasOwnProperty(type)) {
            return this[type];
        } else {
            console.warn(`Unknown data type: ${type}`);
            return null;
        }
    },

    // Method to check if data exists
    hasData(type) {
        return this.hasOwnProperty(type) && this[type] !== null;
    },

    // Method to clear all data
    clearAll() {
        this.schedule = null;
        this.cora = null;
        this.atrops = null;

        // Update data loaded states
        if (typeof appState !== 'undefined') {
            appState.setDataLoaded('schedule', false);
            appState.setDataLoaded('cora', false);
            appState.setDataLoaded('atrops', false);
        } else if (typeof dataLoaded !== 'undefined') {
            dataLoaded.schedule = false;
            dataLoaded.cora = false;
            dataLoaded.atrops = false;
        }
    }
};

function refreshData() {
    const siteSelector = document.getElementById('siteSelector');

    // Keep original structure but add basic safety check
    if (!siteSelector) {
        console.log("Site selector not found, refreshData function aborted");
        return;
    }

    let currentSite = siteSelector.value;
    if (currentSite) {
        clearAllTables();
        showLoadingGif();
        showLoadingGifForNextCPT();
        updateNextCPTContainerPosition();
        manualCPTSelected = false;
        selectedCPTTime = null;
        initializeDispatchRecommendation();
        updateMaxWalls(currentSite);
        updateSiteHeader(currentSite);
        fetchProblemSolveData(currentSite);
        fetchAndUpdateHeldData(currentSite);
        updateDispatchTableFromSettings();

        Promise.all([
            fetchScheduleData(currentSite, 'tableContainer'),
            fetchTableData(`https://outboundflow-iad.amazon.com/${currentSite}/cora?durationOfRiskWindowInDays=21&tableSelector=exsd`, 'tableContainer', true),
            fetchATROPSData(`https://atrops-web-na.amazon.com/new_caps/fetch_data?utf8=%E2%9C%93&warehouse_ids=${complementaryStations[currentSite]}&processing_capability_names=&warehouse_cycle_names=&condition_names=&shipping_lanes=&ship_methods=&sort_codes=&destination_warehouse_ids=&ship_option_groups=&cap_type=pickup&forecast_start_date=2019-12-03&forecast_end_date=2019-12-05&hard_caps=on&soft_caps=on&show_min_target=on&show_negative_troe_offsets=on&slam_counts=on&schedule_counts=on&future_slam=on&future_schedule=on&next_pickup_count=5&packages=on&cubic_feet=on&on_road_time=on&ACS2=on&resource_utilization_graphs=on&graph_days=2&graph_height=250&graph_width=1000&timezone=Default&type=submit`, 'tableContainer'),
            fetchRTSData(currentSite).then(rtsVolume => updateRTSVolume(rtsVolume)),
            fetchAndDisplayOutboundPlanning(currentSite)
        ]).then(() => {
            setTimeout(() => {
                if (dataLoaded.schedule && dataLoaded.cora && dataLoaded.atrops) {
                    updateCPTBasedOnSiteTime();
                    loadRelevantScheduleColumn();
                    updateCPTInfoBoxes();
                    updateProcessingTimeLeft();
                    createAndUpdateMathTable();
                    updatePickRebinPackRecommendations();
                    updateMaxWalls();
                    // Remove duplicate call to createAndUpdateMathTable()
                    createAndUpdateNextCPTMathTable();
                    createAndUpdateNextNextCPTMathTable();
                    fetchAndDisplayRodeoInfo();
                    fetchAndDisplayNextCPTRodeoInfo();
                    startRefreshTimer();
                } else {
                    handleDataLoadError();
                }
            }, 4000);
        }).catch(error => {
            console.error('Error in promise chain:', error);
            handleDataLoadError();
        });
    } else {
        console.log("No site selected, refreshData function aborted");
    }
}

function createInfoTables() {
    // Find logic table element with safety check
    const logicTable = document.querySelector('.table.table-condensed');
    if (logicTable) {
        constructLogicTable(logicTable, 'tableContainer');
    } else {
        console.warn('Logic table (.table.table-condensed) not found');
    }

    // Find ATROPS elements with safety check
    const atropsElements = document.querySelectorAll('.pagediv.report-div');
    if (atropsElements.length > 0) {
        constructAtropsLogicTable(atropsElements, 'tableContainer');
    } else {
        console.warn('ATROPS elements (.pagediv.report-div) not found');
    }
}

// Global retry tracking variables
let dataLoadRetryCount = 0;
const maxDataLoadRetries = 3;
let retryTimeoutId = null;

function handleDataLoadError(autoRetry = true) {
    // Clear any existing retry timeout
    if (retryTimeoutId) {
        clearTimeout(retryTimeoutId);
        retryTimeoutId = null;
    }

    // Check if we should auto-retry
    if (autoRetry && dataLoadRetryCount < maxDataLoadRetries) {
        dataLoadRetryCount++;
        const retryDelay = 2000 * dataLoadRetryCount; // 2s, 4s, 6s delays

        console.log(`Data load failed, auto-retrying in ${retryDelay/1000}s (attempt ${dataLoadRetryCount}/${maxDataLoadRetries})`);

        // Show retry message
        const retryMessage = `
            <div style="
                padding: 20px;
                background-color: #fef3c7;
                border: 2px solid #f59e0b;
                border-radius: 8px;
                color: #92400e;
                text-align: center;
                font-family: Arial, sans-serif;
            ">
                <h3 style="margin-top: 0; color: #78350f;">üîÑ Retrying Data Load</h3>
                <p>Attempt ${dataLoadRetryCount} of ${maxDataLoadRetries} failed.</p>
                <p>Automatically retrying in <span id="retry-countdown">${retryDelay/1000}</span> seconds...</p>
                <div style="
                    width: 100%;
                    height: 6px;
                    background-color: #fbbf24;
                    border-radius: 3px;
                    margin: 10px 0;
                    overflow: hidden;
                ">
                    <div id="retry-progress" style="
                        height: 100%;
                        background-color: #f59e0b;
                        width: 0%;
                        transition: width ${retryDelay}ms linear;
                    "></div>
                </div>
                <button
                    onclick="retryDataLoadNow()"
                    style="
                        margin-top: 10px;
                        padding: 8px 16px;
                        background-color: #f59e0b;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: 500;
                    "
                    onmouseover="this.style.backgroundColor='#d97706'"
                    onmouseout="this.style.backgroundColor='#f59e0b'"
                >
                    Retry Now
                </button>
                <button
                    onclick="cancelAutoRetry()"
                    style="
                        margin: 10px 0 0 10px;
                        padding: 8px 16px;
                        background-color: #6b7280;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: 500;
                    "
                    onmouseover="this.style.backgroundColor='#4b5563'"
                    onmouseout="this.style.backgroundColor='#6b7280'"
                >
                    Cancel Auto-Retry
                </button>
            </div>
        `;

        // Display retry message in containers
        const containerIds = ['tableContainer', 'fullTableContainer', 'nextCPTTableContainer'];
        containerIds.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML = retryMessage;
            }
        });

        // Start countdown and progress bar
        let countdown = retryDelay / 1000;
        const countdownElement = document.getElementById('retry-countdown');
        const progressElement = document.getElementById('retry-progress');

        if (progressElement) {
            // Start progress bar animation
            setTimeout(() => {
                progressElement.style.width = '100%';
            }, 100);
        }

        // Update countdown every second
        const countdownInterval = setInterval(() => {
            countdown--;
            if (countdownElement) {
                countdownElement.textContent = countdown;
            }

            if (countdown <= 0) {
                clearInterval(countdownInterval);
            }
        }, 1000);

        // Schedule the retry
        retryTimeoutId = setTimeout(() => {
            clearInterval(countdownInterval);
            console.log(`Executing auto-retry attempt ${dataLoadRetryCount}`);

            // Reset data loaded states before retry
            if (typeof dataLoaded !== 'undefined') {
                dataLoaded.schedule = false;
                dataLoaded.cora = false;
                dataLoaded.atrops = false;
            }

            // Attempt to reload data - you'll need to call your specific data loading function here
            // This should be replaced with your actual data loading function
            if (typeof refreshData === 'function') {
                refreshData();
            } else if (typeof loadAllData === 'function') {
                loadAllData();
            } else if (typeof initializeData === 'function') {
                initializeData();
            } else {
                console.warn('No data loading function found to retry with');
                // Fall back to showing manual retry error
                handleDataLoadError(false);
            }
        }, retryDelay);

    } else {
        // Max retries reached or auto-retry disabled, show manual retry error
        if (dataLoadRetryCount >= maxDataLoadRetries) {
            console.error(`Data load failed after ${maxDataLoadRetries} automatic retry attempts`);
        }

        const errorMessage = `
            <div style="
                padding: 20px;
                background-color: #fee2e2;
                border: 2px solid #fca5a5;
                border-radius: 8px;
                color: #991b1b;
                text-align: center;
                font-family: Arial, sans-serif;
            ">
                <h3 style="margin-top: 0; color: #7f1d1d;">‚ö†Ô∏è Data Load Error</h3>
                ${dataLoadRetryCount >= maxDataLoadRetries ?
                    `<p><strong>Failed after ${maxDataLoadRetries} automatic retry attempts.</strong></p>` :
                    '<p>Unable to load data from one or more sources.</p>'
                }
                <p>This could be due to:</p>
                <ul style="text-align: left; margin: 10px 0;">
                    <li>Network connectivity issues</li>
                    <li>Server unavailability</li>
                    <li>Site configuration problems</li>
                    <li>Temporary service outages</li>
                    ${dataLoadRetryCount >= maxDataLoadRetries ? '<li>Persistent server or authentication issues</li>' : ''}
                </ul>
                <button
                    onclick="manualRetryData()"
                    style="
                        margin-top: 10px;
                        padding: 8px 16px;
                        background-color: #dc2626;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: 500;
                    "
                    onmouseover="this.style.backgroundColor='#b91c1c'"
                    onmouseout="this.style.backgroundColor='#dc2626'"
                >
                    Try Again Manually
                </button>
                ${dataLoadRetryCount >= maxDataLoadRetries ? `
                <button
                    onclick="resetRetryCount()"
                    style="
                        margin: 10px 0 0 10px;
                        padding: 8px 16px;
                        background-color: #059669;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: 500;
                    "
                    onmouseover="this.style.backgroundColor='#047857'"
                    onmouseout="this.style.backgroundColor='#059669'"
                >
                    Reset & Enable Auto-Retry
                </button>
                ` : ''}
            </div>
        `;

        const containerIds = ['tableContainer', 'fullTableContainer', 'nextCPTTableContainer'];
        containerIds.forEach(containerId => {
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML = errorMessage;
            } else {
                console.warn(`Container '${containerId}' not found when trying to display error message`);
            }
        });

        // Also log the error for debugging
        console.error('Data load error occurred - multiple data sources failed to load');

        // Reset data loaded states
        if (typeof dataLoaded !== 'undefined') {
            dataLoaded.schedule = false;
            dataLoaded.cora = false;
            dataLoaded.atrops = false;
        }

        // Stop any running refresh timer
        if (typeof refreshTimerInterval !== 'undefined' && refreshTimerInterval) {
            clearInterval(refreshTimerInterval);
            refreshTimerInterval = null;
        }
    }
}

// Helper functions for the retry UI
function retryDataLoadNow() {
    if (retryTimeoutId) {
        clearTimeout(retryTimeoutId);
        retryTimeoutId = null;
    }

    console.log('Manual retry triggered during auto-retry countdown');

    // Reset data loaded states
    if (typeof dataLoaded !== 'undefined') {
        dataLoaded.schedule = false;
        dataLoaded.cora = false;
        dataLoaded.atrops = false;
    }

    // Call data loading function
    if (typeof refreshData === 'function') {
        refreshData();
    } else if (typeof loadAllData === 'function') {
        loadAllData();
    } else if (typeof initializeData === 'function') {
        initializeData();
    } else {
        console.warn('No data loading function found');
        handleDataLoadError(false);
    }
}

function cancelAutoRetry() {
    if (retryTimeoutId) {
        clearTimeout(retryTimeoutId);
        retryTimeoutId = null;
    }

    console.log('Auto-retry cancelled by user');
    handleDataLoadError(false); // Show manual retry error
}

function manualRetryData() {
    console.log('Manual retry triggered');

    // Reset data loaded states
    if (typeof dataLoaded !== 'undefined') {
        dataLoaded.schedule = false;
        dataLoaded.cora = false;
        dataLoaded.atrops = false;
    }

    // Call data loading function (same as refreshData)
    if (typeof refreshData === 'function') {
        refreshData();
    } else if (typeof loadAllData === 'function') {
        loadAllData();
    } else if (typeof initializeData === 'function') {
        initializeData();
    } else {
        console.warn('No data loading function found');
    }
}

function resetRetryCount() {
    dataLoadRetryCount = 0;
    console.log('Retry count reset, auto-retry re-enabled');

    // Reset data loaded states
    if (typeof dataLoaded !== 'undefined') {
        dataLoaded.schedule = false;
        dataLoaded.cora = false;
        dataLoaded.atrops = false;
    }

    // Immediately try again with auto-retry enabled
    manualRetryData();
}

function updateSiteHeader(site) {
    // Cleanup existing elements in one operation
    const elementsToRemove = ['#siteHeader', '#lagrangeUpdateButton'];
    elementsToRemove.forEach(selector => {
        const element = document.querySelector(selector);
        if (element) {
            element.remove();
        }
    });

    const currentRiskModel = getCurrentCPTRiskModel();
    const header = document.createElement('h1');
    header.id = 'siteHeader';
    header.textContent = `${site} Site Plan (Current: ${currentRiskModel})`;

    // Consolidate styles with Object.assign
    Object.assign(header.style, {
        position: 'fixed',
        top: '0',
        left: '0',
        width: '100%',
        backgroundColor: 'Darkblue',
        color: 'White',
        textAlign: 'center',
        padding: '10px 0',
        zIndex: '10001',
        margin: '0'
    });

    document.body.insertBefore(header, document.body.firstChild);

    // Create fresh button
    addLagrangeUpdateButton();
    adjustFixedElementPositions();
    adjustTimestampPosition();
}

function updateRiskModel() {
    const riskModelElement = document.getElementById('riskModel');
    const siteSelector = document.getElementById('siteSelector');

    // Safety checks for required elements
    if (!riskModelElement) {
        console.warn('Risk model element not found');
        return;
    }

    if (!siteSelector) {
        console.warn('Site selector element not found');
        return;
    }

    const riskModel = riskModelElement.value;
    const selectedSite = siteSelector.value;

    // Validate risk model value
    if (!riskModel) {
        console.warn('No risk model selected');
        return;
    }

    // Save to localStorage
    try {
        localStorage.setItem('riskModel', riskModel);
    } catch (error) {
        console.warn('Failed to save risk model to localStorage:', error);
    }

    // Update header if site is selected
    if (selectedSite) {
        updateSiteHeader(selectedSite);
    }

    // Update dependent components with error handling
    try {
        createAndUpdateMathTable();
    } catch (error) {
        console.error('Failed to update math table:', error);
    }

    try {
        updatePickRebinPackRecommendations();
    } catch (error) {
        console.error('Failed to update pick/rebin/pack recommendations:', error);
    }

    try {
        addDarkModeToggle();
    } catch (error) {
        console.error('Failed to add dark mode toggle:', error);
    }
}

    function updateOutboundTotals(table) {
    try {
        if (!table || !table.rows) {
            console.warn('updateOutboundTotals: Invalid table provided');
            return false;
        }

        // Find the totals row
        let totalsRow = null;
        for (let i = 0; i < table.rows.length; i++) {
            const row = table.rows[i];
            if (row && row.cells[0]) {
                const cellText = (row.cells[0].textContent || '').trim();
                if (cellText === 'Outbound Totals') {
                    totalsRow = row;
                    break;
                }
            }
        }

        if (!totalsRow) {
            console.warn('updateOutboundTotals: Totals row not found');
            return false;
        }

        // Calculate totals for each column
        for (let col = 1; col < totalsRow.cells.length; col++) {
            let columnTotal = 0;

            // Sum all rows except header and totals
            for (let row = 0; row < table.rows.length; row++) {
                const currentRow = table.rows[row];
                if (currentRow === totalsRow) continue; // Skip totals row
                if (row === 0) continue; // Skip header row

                if (currentRow && currentRow.cells[col]) {
                    const cellText = (currentRow.cells[col].textContent || '').trim();
                    const value = parseFloat(cellText);

                    if (!isNaN(value) && isFinite(value)) {
                        columnTotal += value;
                    }
                }
            }

            if (totalsRow.cells[col]) {
                totalsRow.cells[col].textContent = columnTotal;
            }
        }

        return true;
    } catch (error) {
        console.error('updateOutboundTotals: Error updating totals:', error);
        return false;
    }
}


function adjustTimestampPosition() {
    const header = document.getElementById('siteHeader');
    const timestampContainer = document.getElementById('timestampContainer');

    // Safety checks
    if (!header || !timestampContainer) {
        if (!header) console.warn('Site header not found for timestamp positioning');
        if (!timestampContainer) console.warn('Timestamp container not found for positioning');
        return;
    }

    const currentHeaderHeight = header.offsetHeight;
    const newTopPosition = currentHeaderHeight + 10;

    // Only update if position actually changed (performance optimization)
    if (timestampContainer.style.top !== newTopPosition + 'px') {
        timestampContainer.style.top = newTopPosition + 'px';

        // Update global tracking variable
        lastHeaderHeight = currentHeaderHeight;

        console.log(`Timestamp position adjusted to ${newTopPosition}px (header height: ${currentHeaderHeight}px)`);
    }
}

// Enhanced version that can be called on window resize
function adjustTimestampPositionOnResize() {
    const header = document.getElementById('siteHeader');

    if (header) {
        const currentHeaderHeight = header.offsetHeight;

        // Only adjust if header height actually changed
        if (currentHeaderHeight !== lastHeaderHeight) {
            adjustTimestampPosition();
        }
    }
}

// Track header height for comparison
let lastHeaderHeight = 0;

function adjustFixedElementPositions() {
    const header = document.getElementById('siteHeader');

    // Safety check for header existence
    if (!header) {
        console.warn('Site header not found for fixed element positioning');
        return;
    }

    const currentHeaderHeight = header.offsetHeight;

    // Only proceed if header height has actually changed
    if (currentHeaderHeight === lastHeaderHeight) {
        return;
    }

    lastHeaderHeight = currentHeaderHeight;

    // More efficient selector - target specific fixed elements we know about
    const knownFixedElementIds = [
        'clockContainer',
        'timestampContainer',
        'cptInfoContainer',
        'siteConfigContainer',
        'currentCPTInfoBox',
        'nextCPTInfoBox',
        'maxWallsContainer'
    ];

    // Process known elements first (more reliable)
    knownFixedElementIds.forEach(id => {
        const element = document.getElementById(id);
        if (element && element.id !== 'siteHeader') {
            adjustElementPosition(element, currentHeaderHeight);
        }
    });

    // Fallback: find any other fixed elements by style
    const allFixedElements = document.querySelectorAll('[style*="position: fixed"], [style*="position:fixed"]');
    allFixedElements.forEach(element => {
        // Skip if already processed or is the header itself
        if (element.id && (knownFixedElementIds.includes(element.id) || element.id === 'siteHeader')) {
            return;
        }

        // Double-check it's actually fixed positioned
        if (window.getComputedStyle(element).position === 'fixed') {
            adjustElementPosition(element, currentHeaderHeight);
        }
    });
}

// Helper function to adjust individual element position
function adjustElementPosition(element, headerHeight) {
    try {
        let originalTop = element.getAttribute('data-original-top');

        // Store original position if not already stored
        if (!originalTop) {
            const computedStyle = window.getComputedStyle(element);
            originalTop = computedStyle.top;

            // Only store if it's a valid value
            if (originalTop && originalTop !== 'auto') {
                element.setAttribute('data-original-top', originalTop);
            } else {
                // Use current position as fallback
                originalTop = '0px';
                element.setAttribute('data-original-top', originalTop);
            }
        }

        // Calculate new position
        const originalTopValue = parseInt(originalTop) || 0;
        const newTop = originalTopValue + headerHeight;

        // Only update if the value actually changed
        if (element.style.top !== `${newTop}px`) {
            element.style.top = `${newTop}px`;
        }

    } catch (error) {
        console.warn(`Failed to adjust position for element:`, element, error);
    }
}

// Alternative function for when you want to reset all positions
function resetFixedElementPositions() {
    const elementsWithOriginalTop = document.querySelectorAll('[data-original-top]');

    elementsWithOriginalTop.forEach(element => {
        try {
            const originalTop = element.getAttribute('data-original-top');
            if (originalTop) {
                element.style.top = originalTop;
            }
        } catch (error) {
            console.warn('Failed to reset element position:', element, error);
        }
    });

    // Reset tracking variable
    lastHeaderHeight = 0;
}

function updateTimestamp() {
    const timestampElement = document.getElementById('timestampText');

    // Safety check for element existence
    if (!timestampElement) {
        console.warn('Timestamp element not found');
        return;
    }

    const now = new Date();
    const options = {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    };

    try {
        const timestamp = new Intl.DateTimeFormat('en-US', options).format(now);

        // Use textContent instead of innerHTML for better performance and security
        timestampElement.innerHTML = `<strong>Last Refresh: ${timestamp}</strong>`;

    } catch (error) {
        console.error('Failed to format timestamp:', error);
        // Fallback to basic timestamp if Intl formatting fails
        timestampElement.innerHTML = `<strong>Last Refresh: ${now.toLocaleString()}</strong>`;
    }
}
    // Function to calculate the difference between two times in minutes
    function getMinutesDifference(startTime, endTime) {
        const parseTime = (timeString) => {
            let [time, modifier] = timeString.split(' ');
            let [hours, minutes] = time.split(':').map(Number);

            if (modifier === 'PM' && hours !== 12) hours += 12;
            if (modifier === 'AM' && hours === 12) hours = 0;

            return { hours, minutes };
        };

        const start = parseTime(startTime);
        const end = parseTime(endTime);

        let startMinutes = start.hours * 60 + start.minutes;
        let endMinutes = end.hours * 60 + end.minutes;

        if (endMinutes < startMinutes) endMinutes += 24 * 60; // Handle crossing midnight

        return endMinutes - startMinutes;
    }

function determineBlockType(startTime, endTime, minutes) {
    const siteSelector = document.getElementById('siteSelector');

    // Minimal safety check - keep original logic otherwise
    if (!siteSelector) {
        return minutes <= 30 ? "Break" : "Production";
    }

    const selectedSite = siteSelector.value;

    // Helper function to convert time string to minutes since midnight
    function timeToMinutes(timeStr) {
        const [time, period] = timeStr.split(' ');
        let [hours, minutes] = time.split(':').map(Number);
        if (period === 'PM' && hours !== 12) hours += 12;
        if (period === 'AM' && hours === 12) hours = 0;
        return hours * 60 + minutes;
    }

    // Special case for SNY1
    if (selectedSite === 'SNY1') {
        const startMinutes = timeToMinutes(startTime);
        const endMinutes = timeToMinutes(endTime);
        // 04:00 PM to 11:15 PM
        if (startMinutes === timeToMinutes("04:00 PM") &&
            endMinutes === timeToMinutes("11:15 PM")) {
            return "Downtime";
        }
        // 07:30 AM to 09:45 AM
        if (startMinutes === timeToMinutes("07:30 AM") &&
            endMinutes === timeToMinutes("09:45 AM")) {
            return "Downtime";
        }
    }

    // Special cases for SFL8, SFL7, and SNJ2
    if (['SFL8', 'SFL7', 'SNJ2'].includes(selectedSite)) {
        const currentDate = new Date();
        const dayOfWeek = currentDate.getDay();
        // Convert times to minutes for comparison
        const startMinutes = timeToMinutes(startTime);
        const endMinutes = timeToMinutes(endTime);
        // 06:30 AM = 390 minutes, 08:30 AM = 510 minutes
        const isDowntimeWindow = startMinutes === 390 && endMinutes === 510;
        // Different day checks for each site
        if (isDowntimeWindow) {
            if (['SFL8', 'SFL7'].includes(selectedSite)) {
                // Monday through Thursday for SFL8 and SFL7
                if (dayOfWeek >= 1 && dayOfWeek <= 4) {
                    return "Downtime";
                }
            } else if (selectedSite === 'SNJ2') {
                // Monday, Tuesday, and Thursday for SNJ2
                if (dayOfWeek === 1 || dayOfWeek === 2 || dayOfWeek === 4) {
                    return "Downtime";
                }
            }
        }
    }

    // Standard downtime windows
    if ((startTime === "07:00 PM" && endTime === "08:00 PM") ||
        (startTime === "08:00 PM" && endTime === "09:00 PM")) {
        return "Downtime";
    }

    // Default logic
    return minutes <= 30 ? "Break" : "Production";
}

   // Function to create the GIF modal
function createGifModal(onConfirm, onCancel) {
    // Check if modal already exists to prevent duplicates
    const existingModal = document.querySelector('.gif-modal-background');
    if (existingModal) {
        existingModal.remove();
    }

    const modalBackground = document.createElement('div');
    modalBackground.className = 'gif-modal-background'; // Add class for identification

    // Consolidate styles
    Object.assign(modalBackground.style, {
        position: 'fixed',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
        backgroundColor: 'rgba(0,0,0,0.5)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: '10000'
    });

    const modal = document.createElement('div');
    Object.assign(modal.style, {
        backgroundColor: 'white',
        padding: '20px',
        borderRadius: '10px',
        textAlign: 'center',
        width: '300px'
    });

    const gif = document.createElement('img');
    gif.src = 'https://media.tenor.com/aqWYkmGPhUcAAAAj/you-sure-about-that-i-think-you-should-leave-with-tim-robinson.gif';
    gif.style.width = '100%';
    gif.alt = 'Confirmation GIF'; // Add alt text for accessibility

    modal.appendChild(gif);

    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '20px';

    // Create buttons with better styling and event handling
    const yesButton = document.createElement('button');
    yesButton.textContent = 'Yes';
    Object.assign(yesButton.style, {
        marginRight: '10px',
        padding: '8px 16px',
        backgroundColor: '#22c55e',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer'
    });

    const noButton = document.createElement('button');
    noButton.textContent = 'No';
    Object.assign(noButton.style, {
        padding: '8px 16px',
        backgroundColor: '#ef4444',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer'
    });

    // Cleanup function to remove modal safely
    function closeModal() {
        if (modalBackground && modalBackground.parentNode) {
            modalBackground.parentNode.removeChild(modalBackground);
        }
    }

    // Event handlers with proper cleanup
    yesButton.addEventListener('click', function() {
        if (typeof onConfirm === 'function') {
            onConfirm();
        }
        closeModal();
    });

    noButton.addEventListener('click', function() {
        if (typeof onCancel === 'function') {
            onCancel();
        }
        closeModal();
    });

    // Close modal when clicking background
    modalBackground.addEventListener('click', function(event) {
        if (event.target === modalBackground) {
            if (typeof onCancel === 'function') {
                onCancel();
            }
            closeModal();
        }
    });

    // Close modal with Escape key
    function handleKeyDown(event) {
        if (event.key === 'Escape') {
            if (typeof onCancel === 'function') {
                onCancel();
            }
            closeModal();
            document.removeEventListener('keydown', handleKeyDown);
        }
    }

    document.addEventListener('keydown', handleKeyDown);

    buttonContainer.appendChild(yesButton);
    buttonContainer.appendChild(noButton);
    modal.appendChild(buttonContainer);
    modalBackground.appendChild(modal);
    document.body.appendChild(modalBackground);
}

function toggleBlockType(cell, currentType, isNextCPT = false) {
    // Validate inputs
    if (!cell) {
        console.warn('No cell provided to toggleBlockType');
        return;
    }

    createGifModal(
        () => {
            const types = ['Break', 'Production', 'Downtime'];
            const currentIndex = types.indexOf(currentType);
            const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % types.length;
            const newType = types[nextIndex];

            // Update cell content and data
            cell.textContent = newType;
            cell.dataset.blockType = newType;

            // Apply styling based on block type
            applyBlockTypeStyles(cell, newType);

            // Update all related components
            updateAllProductionComponents(isNextCPT);
        },
        () => {
            console.log('User canceled the toggle.');
        }
    );
}

// Helper function to apply consistent styling based on block type
function applyBlockTypeStyles(cell, blockType) {
    if (!cell) return;

    const styles = {
        'Production': {
            backgroundColor: 'yellow',
            color: 'black'
        },
        'Break': {
            backgroundColor: 'red',
            color: 'white'
        },
        'Downtime': {
            backgroundColor: 'gray',
            color: 'white'
        }
    };

    const style = styles[blockType];
    if (style) {
        Object.assign(cell.style, style);
    } else {
        console.warn(`Unknown block type: ${blockType}`);
    }
}

// Helper function to update all production-related components
function updateAllProductionComponents(isNextCPT) {
    try {
        // Update production graphics
        updateProductionGraphic();
        updateNextCPTProductionGraphic();
        updatePlanSummary1();

        // Update time calculations
        if (isNextCPT) {
            const cptSelect = document.getElementById('cptSelect');
            if (cptSelect && cptSelect.value) {
                updateNextCPTInfo(getNextCPT(cptSelect.value));
            } else {
                console.warn('CPT select element not found or has no value');
            }
        } else {
            updateProcessingTimeLeft();
        }
    } catch (error) {
        console.error('Error updating production components:', error);
    }
}


function updateProductionGraphic() {
    const scheduleTable = document.querySelector('#SelectedCPTSchedule');
    const productionGraphic = document.getElementById('productionGraphic');

    // Safety checks for required elements
    if (!scheduleTable) {
        console.warn('Selected CPT schedule table not found');
        return;
    }

    if (!productionGraphic) {
        console.warn('Production graphic element not found');
        return;
    }

    // Call the update function with validated elements
    try {
        updateGraphicBasedOnSchedule(scheduleTable, productionGraphic);
    } catch (error) {
        console.error('Error updating production graphic:', error);
    }
}

function updateNextCPTProductionGraphic() {
    const nextCPTProductionTable = document.getElementById('nextCPTProductionGraphicTable');
    if (!nextCPTProductionTable) {
        console.error('Next CPT Production table not found');
        return;
    }

    const nextCPTScheduleTable = document.querySelector('#NextCPTSchedule');
    if (!nextCPTScheduleTable) {
        console.error('Next CPT Schedule table not found');
        return;
    }

    let productionWindows;
    try {
        productionWindows = getProductionWindows(nextCPTScheduleTable);
    } catch (error) {
        console.error('Error getting production windows:', error);
        return;
    }

    // Validate table structure
    if (!nextCPTProductionTable.rows || nextCPTProductionTable.rows.length === 0) {
        console.error('Next CPT Production table has no rows');
        return;
    }

    // Update header row with production windows
    const headerRow = nextCPTProductionTable.rows[0];
    if (headerRow && headerRow.cells) {
        for (let i = 1; i < headerRow.cells.length; i++) {
            const cell = headerRow.cells[i];
            if (!cell) continue;

            if (i - 1 < productionWindows.length) {
                cell.textContent = productionWindows[i - 1].timeWindow;
                cell.style.display = '';
            } else {
                cell.style.display = 'none';
            }
        }
    }

    // Update other rows
    for (let i = 1; i < nextCPTProductionTable.rows.length; i++) {
        const row = nextCPTProductionTable.rows[i];
        if (!row || !row.cells) continue;

        for (let j = 1; j < row.cells.length; j++) {
            const cell = row.cells[j];
            if (!cell) continue;

            if (j - 1 < productionWindows.length) {
                cell.style.display = '';
            } else {
                cell.style.display = 'none';
            }
        }
    }

    // Update dependent components with error handling
    try {
        updatePlanSummary1();
    } catch (error) {
        console.error('Error updating plan summary 1:', error);
    }

    try {
        updatePlanSummary2();
    } catch (error) {
        console.error('Error updating plan summary 2:', error);
    }

    try {
        updateOutboundTotals(nextCPTProductionTable);
    } catch (error) {
        console.error('Error updating outbound totals:', error);
    }
}

function updateGraphicBasedOnSchedule(scheduleTable, productionGraphic) {
    if (!scheduleTable || !productionGraphic) return;

    // Validate table structure before accessing rows
    if (!scheduleTable.rows || scheduleTable.rows.length < 3 ||
        !scheduleTable.rows[0] || !scheduleTable.rows[2]) {
        console.warn('Schedule table does not have expected structure');
        return;
    }

    if (!productionGraphic.rows || productionGraphic.rows.length === 0) {
        console.warn('Production graphic table has no rows');
        return;
    }

    const productionWindows = [];
    const headerCells = scheduleTable.rows[0].cells;
    const typeCells = scheduleTable.rows[2].cells;

    for (let i = 0; i < headerCells.length; i++) {
        if (typeCells[i] && typeCells[i].textContent.trim() === 'Production') {
            productionWindows.push(headerCells[i].textContent);
        }
    }

    // Update header row
    const headerRow = productionGraphic.rows[0];
    if (headerRow && headerRow.cells) {
        for (let i = 1; i < headerRow.cells.length; i++) {
            if (i - 1 < productionWindows.length) {
                headerRow.cells[i].textContent = productionWindows[i - 1];
                headerRow.cells[i].style.display = '';
            } else {
                headerRow.cells[i].style.display = 'none';
            }
        }
    }

    // Update other rows
    for (let i = 1; i < productionGraphic.rows.length; i++) {
        const row = productionGraphic.rows[i];
        if (row && row.cells) {
            for (let j = 1; j < row.cells.length; j++) {
                if (j - 1 < productionWindows.length) {
                    row.cells[j].style.display = '';
                } else {
                    row.cells[j].style.display = 'none';
                }
            }
        }
    }

    updateOutboundTotals(productionGraphic);
}


function updateProcessingTimeLeft() {
    const table = document.getElementById('SelectedCPTSchedule');
    if (!table) return;

    // Validate table structure
    if (!table.rows || table.rows.length < 3) {
        console.warn('Selected CPT schedule table does not have expected structure');
        return;
    }

    let totalProcessingTime = 0;
    const timeRow = table.rows[0];
    const typeRow = table.rows[2];
    const currentTime = new Date();

    // Validate rows exist and have cells
    if (!timeRow || !typeRow || !timeRow.cells || !typeRow.cells) {
        console.warn('Table rows or cells are missing');
        return;
    }

    for (let i = 0; i < timeRow.cells.length; i++) {
        // Safety check for cell existence
        if (!timeRow.cells[i] || !typeRow.cells[i]) {
            continue;
        }

        const timeCell = timeRow.cells[i].textContent;
        const blockType = typeRow.cells[i].textContent;

        // Validate time cell format
        if (!timeCell || !timeCell.includes(' to ')) {
            continue;
        }

        const [startTime, endTime] = timeCell.split(' to ');

        if (blockType === 'Production') {
            try {
                const start = parseTime(startTime);
                const end = parseTime(endTime);

                // Validate parsed times
                if (!start || !end || isNaN(start.getTime()) || isNaN(end.getTime())) {
                    console.warn(`Invalid time format in cell ${i}: ${timeCell}`);
                    continue;
                }

                if (currentTime < end) {
                    const blockStart = currentTime > start ? currentTime : start;
                    totalProcessingTime += (end - blockStart) / (1000 * 60); // Convert to minutes
                }
            } catch (error) {
                console.warn(`Error parsing time for cell ${i}: ${timeCell}`, error);
                continue;
            }
        }
    }

    const hours = Math.floor(totalProcessingTime / 60);
    const minutes = Math.floor(totalProcessingTime % 60);
    const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;

    // Safely get CPT value and update display
    const cptSelect = document.getElementById('cptSelect');
    const cptInfoContainer = document.getElementById('cptInfoContainer');

    if (cptSelect && cptInfoContainer) {
        const cpt = cptSelect.value || 'N/A';
        updateCPTDisplay(cptInfoContainer, cpt, timeString);
    } else {
        console.warn('CPT select or info container elements not found');
    }
}

function parseTime(timeString) {
    const [time, period] = timeString.split(' ');
    let [hours, minutes] = time.split(':').map(Number);
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;
    const now = new Date();
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes);
}

function fetchScheduleData(siteCode, containerId) {
    return new Promise((resolve, reject) => {
        const scheduleUrl = `https://throughput-iad.iad.proxy.amazon.com/${siteCode}/granular/`;

        GM_xmlhttpRequest({
            method: "GET",
            url: scheduleUrl,
            onload: function(response) {
                try {
                    processScheduleResponse(response, containerId, resolve, reject);
                } catch (error) {
                    console.error('Error processing schedule response:', error);
                    displayErrorMessage(containerId, 'Error processing schedule data.');
                    reject(error);
                }
            },
            onerror: function(error) {
                console.error('Network error fetching schedule:', error);
                displayErrorMessage(containerId, 'Network error fetching schedule data.');
                reject(error);
            }
        });
    });
}

// Helper function to process the schedule response
function processScheduleResponse(response, containerId, resolve, reject) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(response.responseText, 'text/html');

    // Find the script tag that contains "modelAndView"
    const scriptTags = doc.querySelectorAll('script');
    let scriptContent = null;

    for (const script of scriptTags) {
        if (script.textContent.includes('modelAndView')) {
            scriptContent = script.textContent;
            break;
        }
    }

    if (!scriptContent) {
        displayErrorMessage(containerId, 'No script tag containing modelAndView found.');
        reject('No script tag containing modelAndView found');
        return;
    }

    const modelAndViewMatch = scriptContent.match(/var\s+modelAndView\s*=\s*(\{[\s\S]*?\});/);

    if (!modelAndViewMatch || !modelAndViewMatch[1]) {
        displayErrorMessage(containerId, 'No modelAndView object found.');
        reject('No modelAndView object found');
        return;
    }

    try {
        // Safely parse the extracted modelAndView string using eval
        const parsedObject = eval('(' + modelAndViewMatch[1] + ')');
        const localTimeSchedule = parsedObject.LocalTimeSchedule;

        if (!localTimeSchedule) {
            displayErrorMessage(containerId, 'LocalTimeSchedule not found in the modelAndView object.');
            reject('LocalTimeSchedule not found');
            return;
        }

        createScheduleTable(localTimeSchedule, containerId);
        dataLoaded.schedule = true;
        resolve();

    } catch (error) {
        console.error('Error parsing modelAndView:', error);
        displayErrorMessage(containerId, 'Error parsing modelAndView object.');
        reject(error);
    }
}

// Helper function to create the schedule table
function createScheduleTable(localTimeSchedule, containerId) {
    // Process the LocalTimeSchedule
    const cleanedSchedule = localTimeSchedule
        .split(', ')
        .slice(1) // Remove the first time window
        .map(timeWindow => timeWindow.replace(/\d{2}\/\d{2}\s+/g, ''));

    // Detect duplicates and stop when a duplicate is found
    const seen = new Set();
    const uniqueSchedule = [];

    for (const time of cleanedSchedule) {
        if (seen.has(time)) {
            break;
        }
        seen.add(time);
        uniqueSchedule.push(time);
    }

    // Create table structure
    const table = document.createElement('table');
    table.classList.add('SiteSchedule');
    Object.assign(table.style, {
        width: '100%',
        borderCollapse: 'collapse'
    });

    // Create rows
    const timeRow = document.createElement('tr');
    const durationRow = document.createElement('tr');
    const blockTypeRow = document.createElement('tr');

    // Add the schedule twice (back-to-back)
    addScheduleBlock(uniqueSchedule, timeRow, durationRow, blockTypeRow);
    addScheduleBlock(uniqueSchedule, timeRow, durationRow, blockTypeRow);

    // Append rows to table
    table.appendChild(timeRow);
    table.appendChild(durationRow);
    table.appendChild(blockTypeRow);

    // Display the table in the container
    const container = document.getElementById(containerId);
    if (container) {
        container.appendChild(table);
    } else {
        console.error(`Container ${containerId} not found`);
    }
}

// Helper function to add schedule blocks to table rows
function addScheduleBlock(schedule, timeRow, durationRow, blockTypeRow) {
    schedule.forEach(time => {
        const [startTime, endTime] = time.split(' to ');

        // Create time cell
        const timeCell = createTableCell(time, {
            fontWeight: 'bold',
            backgroundColor: 'lightblue'
        });
        timeRow.appendChild(timeCell);

        // Create duration cell
        const minutes = getMinutesDifference(startTime, endTime);
        const durationCell = createTableCell(`${minutes} minutes`);
        durationRow.appendChild(durationCell);

        // Create block type cell
        const blockType = determineBlockType(startTime, endTime, minutes);
        const blockTypeCell = createBlockTypeCell(blockType);
        blockTypeRow.appendChild(blockTypeCell);
    });
}

// Helper function to create standardized table cells
function createTableCell(content, additionalStyles = {}) {
    const cell = document.createElement('td');

    Object.assign(cell.style, {
        border: '1px solid black',
        padding: '10px',
        ...additionalStyles
    });

    cell.textContent = content;
    return cell;
}

// Helper function to create block type cells with click handlers
function createBlockTypeCell(blockType) {
    const cell = createTableCell(blockType);
    cell.dataset.blockType = blockType;

    // Apply block type styling
    if (blockType === "Break" || blockType === "Downtime") {
        Object.assign(cell.style, {
            backgroundColor: 'red',
            color: 'white',
            fontWeight: 'bold'
        });
    } else if (blockType === "Production") {
        cell.style.fontWeight = 'bold';
    }

    // Add click event to toggle between types
    cell.addEventListener('click', () => {
        toggleBlockType(cell, cell.dataset.blockType);
    });

    return cell;
}

// Helper function to display error messages
function displayErrorMessage(containerId, message) {
    const container = document.getElementById(containerId);
    if (container) {
        const errorElement = document.createElement('p');
        errorElement.textContent = message;
        errorElement.style.color = 'red';
        container.appendChild(errorElement);
    }
}

function fetchTableData(url, containerId, updateLogic) {
    return new Promise((resolve, reject) => {
        // Validate inputs
        if (!url || !containerId) {
            const error = 'URL and container ID are required';
            console.error(error);
            reject(error);
            return;
        }

        GM_xmlhttpRequest({
            method: "GET",
            url: url,
            onload: function(response) {
                try {
                    processTableResponse(response, containerId, resolve, reject);
                } catch (error) {
                    console.error('Error processing table response:', error);
                    displayTableError(containerId, 'Error processing table data.');
                    reject(error);
                }
            },
            onerror: function(error) {
                console.error('Network error fetching table data:', error);
                displayTableError(containerId, 'Network error fetching table data.');
                reject(error);
            }
        });
    });
}

// Helper function to process the table response
function processTableResponse(response, containerId, resolve, reject) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(response.responseText, 'text/html');

    const table = doc.querySelector('.table.table-condensed.table-bordered.table-striped-by-column.rotate-table');

    if (!table) {
        displayTableError(containerId, 'No table found.');
        reject('No table found');
        return;
    }

    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Container ${containerId} not found`);
        reject(`Container ${containerId} not found`);
        return;
    }

    try {
        // Process and add the table
        const transposedTable = transposeTable(table);
        formatTableCells(transposedTable);
        container.appendChild(transposedTable);

        // Construct logic table
        constructLogicTable(transposedTable, containerId);

        // Update data state
        dataLoaded.cora = true;

        // Update math table
        createAndUpdateMathTable();

        resolve();

    } catch (error) {
        console.error('Error processing table operations:', error);
        displayTableError(containerId, 'Error processing table operations.');
        reject(error);
    }
}

// Helper function to display table-specific error messages
function displayTableError(containerId, message) {
    const container = document.getElementById(containerId);
    if (container) {
        container.innerHTML = `<p style="color: red; padding: 10px;">${message}</p>`;
    } else {
        console.error(`Cannot display error - container ${containerId} not found: ${message}`);
    }
}


function fetchATROPSData(url, containerId) {
    const stationMatch = url.match(/warehouse_ids=([^&]+)/);
    const complementaryStation = stationMatch ? stationMatch[1] : '';

    console.log('Starting ATROPS fetch for station:', complementaryStation);

    return new Promise((resolve, reject) => {
        if (!complementaryStation) {
            console.error('No warehouse ID found in URL');
            reject(new Error('No warehouse ID found'));
            return;
        }

        // Add delay before making the request
        setTimeout(() => {
            try {
                // Get date range
                const today = new Date();
                const endDate = new Date(today);
                endDate.setDate(endDate.getDate() + 1);

                const startDate = today.toISOString().split('.')[0];
                const endDateStr = endDate.toISOString().split('.')[0];

                // Construct CRISP URL
                const crispUrl = `https://crisp-na.corp.amazon.com/transportation/capacity-dashboard?` +
                    `timeRangeStart=${encodeURIComponent(startDate)}` +
                    `&timeRangeEnd=${encodeURIComponent(endDateStr)}` +
                    `&zoneId=UTC` +
                    `&pickupSourceWarehouses=${complementaryStation}` +
                    `&pickupShipMethods=AMZL_US_RUSH_SD` +
                    `&constraints=HardCap&constraints=SoftCap` +
                    `&units=PkgCount`;

                console.log('Requesting CRISP URL:', crispUrl);

                // Make the request
                GM_xmlhttpRequest({
                    method: 'GET',
                    url: crispUrl,
                    headers: {
                        "Content-Type": "application/json",
                        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
                    },
                    onload: function(response) {
                        console.log('Response received, status:', response.status);

                        if (response.status !== 200) {
                            console.error('Bad response status:', response.status);
                            reject(new Error(`Bad response status: ${response.status}`));
                            return;
                        }

                        try {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(response.responseText, 'text/html');

                            // Check if CRISP data is available
                            if (!response.responseText.includes('standardPickupResources')) {
                                console.warn('CRISP data not available, falling back to cached data');
                                reject(new Error('CRISP data not available'));
                                return;
                            }

                            // Find the table
                            const table = doc.querySelector('table#standardPickupResources');
                            if (!table) {
                                console.error('Table not found in response');
                                console.log('Response HTML:', response.responseText.substring(0, 500) + '...');
                                reject(new Error('Table not found'));
                                return;
                            }

                            // Create ATROPS table
                            const atropsTable = document.createElement('table');
                            atropsTable.className = 'Atrops-table';
                            atropsTable.style.width = '100%';
                            atropsTable.style.borderCollapse = 'collapse';
                            atropsTable.style.marginTop = '20px';
                            atropsTable.style.fontSize = '12px';
                            atropsTable.style.backgroundColor = '#ffffff';

                            // Add header
                            const headerRow = atropsTable.insertRow();
                            ['CPT', '% Schedule', 'Cap', 'Schedule'].forEach(text => {
                                const th = document.createElement('th');
                                th.textContent = text;
                                th.style.border = '1px solid black';
                                th.style.padding = '8px';
                                th.style.backgroundColor = '#f0f0f0';
                                headerRow.appendChild(th);
                            });

                            // Process rows
                            const rows = Array.from(table.querySelectorAll('tbody tr:not(.dtrg-group)'));
                            console.log(`Processing ${rows.length} rows`);

                            let processedRows = 0;
    rows.forEach((row, index) => {
        const timeCell = row.querySelector('td[data-order]');
        const constraintCell = row.cells[12];

        if (timeCell && constraintCell && constraintCell.textContent.trim() === 'Soft cap') {
            try {
                const timeText = timeCell.textContent.trim();
                // Extract just the time portion (HH:mm) without any conversion
                const cptTime = timeText.split(' ')[3]?.slice(0, 5);

                if (!cptTime) {
                    console.warn(`Invalid time format in row ${index}`);
                    return;
                }

                const newRow = atropsTable.insertRow();

                // Get cell values with error handling
                const schedulePercent = row.cells[18]?.querySelector('.a-progress-prompt')?.textContent.replace('%', '') || '0';
                const cap = row.cells[13]?.textContent.trim() || '0';
                const schedule = row.cells[17]?.textContent.trim() || '0';

                // Log processed data for verification
                console.log('Processed CPT data:', {
                    cptTime,
                    schedulePercent,
                    cap,
                    schedule
                });

                [cptTime, schedulePercent, cap, schedule].forEach(text => {
                    const cell = newRow.insertCell();
                    cell.textContent = text;
                    cell.style.border = '1px solid black';
                    cell.style.padding = '8px';
                });

                processedRows++;
            } catch (rowError) {
                console.error(`Error processing row ${index}:`, rowError);
            }
        }
    });
                            console.log(`Successfully processed ${processedRows} rows`);

                            // Create container and add table
                            const atropsDiv = document.createElement('div');
                            atropsDiv.style.margin = '10px';
                            atropsDiv.style.padding = '10px';
                            atropsDiv.style.border = '1px solid purple';
                            atropsDiv.innerHTML = '<h3>Formatted ATROPS Table:</h3>';
                            atropsDiv.appendChild(atropsTable);

                            // Get container and find existing ATROPS table if any
                            const container = document.getElementById(containerId);
                            if (!container) {
                                throw new Error(`Container ${containerId} not found`);
                            }

                            // Remove only the existing ATROPS table if it exists
                            const existingAtropsTable = container.querySelector('.Atrops-table');
                            if (existingAtropsTable) {
                                existingAtropsTable.parentElement.remove();
                            }

                            // Append the new table
                            container.appendChild(atropsDiv);

                            dataLoaded.atrops = true;
                            resolve();

                        } catch (parseError) {
                            console.error('Error processing response:', parseError);
                            reject(parseError);
                        }
                    },
                    onerror: function(error) {
                        console.error('Request failed:', error);
                        reject(error);
                    }
                });

            } catch (error) {
                console.error('Setup error:', error);
                reject(error);
            }
        }, 2000); // 2-second delay before making the request
    });
}

// Function to transpose the table (flip X and Y axes)
function transposeTable(table) {
    // Validate input
    if (!table || !table.rows || table.rows.length === 0) {
        console.warn('Invalid table provided to transposeTable');
        return null;
    }

    const rows = Array.from(table.rows);

    // Check if all rows have cells
    if (!rows[0] || !rows[0].cells || rows[0].cells.length === 0) {
        console.warn('Table has no cells to transpose');
        return null;
    }

    const transposedTable = document.createElement('table');
    transposedTable.className = table.className;

    // Consolidate table styles
    Object.assign(transposedTable.style, {
        width: 'auto'
    });

    const maxCells = rows[0].cells.length;

    try {
        for (let i = 0; i < maxCells; i++) {
            const newRow = transposedTable.insertRow();

            for (let j = 0; j < rows.length; j++) {
                const newCell = newRow.insertCell();

                // Safety check for cell existence
                if (rows[j] && rows[j].cells && rows[j].cells[i]) {
                    newCell.innerHTML = rows[j].cells[i].innerHTML;
                } else {
                    newCell.innerHTML = ''; // Empty cell for missing data
                }

                // Consolidate cell styles
                Object.assign(newCell.style, {
                    whiteSpace: 'nowrap',
                    padding: '5px',
                    textAlign: 'center'
                });
            }
        }

        return transposedTable;

    } catch (error) {
        console.error('Error during table transposition:', error);
        return null;
    }
}

// Function to format the table cells
function formatTableCells(table) {
    // Validate input
    if (!table) {
        console.warn('No table provided to formatTableCells');
        return;
    }

    const cells = table.querySelectorAll('td, th');

    // Check if any cells were found
    if (cells.length === 0) {
        console.warn('No cells found in table to format');
        return;
    }

    // Apply formatting to each cell
    cells.forEach(cell => {
        Object.assign(cell.style, {
            minWidth: '100px',
            wordWrap: 'break-word',
            border: '1px solid black'
        });
    });

    // Set table layout
    table.style.tableLayout = 'auto';
}

// Function to construct the Logic Table
function constructLogicTable(transposedTable, containerId) {
    // Enhanced input validation
    if (!transposedTable) {
        console.error('Transposed table is null');
        return;
    }

    if (!transposedTable.rows || transposedTable.rows.length < 11) {
        console.error('Transposed table does not have enough rows for logic table construction');
        return;
    }

    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Container ${containerId} not found`);
        return;
    }

    // Create logic table with consolidated styles
    const logicTable = document.createElement('table');
    logicTable.className = 'CORA-table';
    Object.assign(logicTable.style, {
        borderCollapse: 'collapse',
        width: '100%',
        marginTop: '20px'
    });

    // Create header row with helper function
    createLogicTableHeader(logicTable);

    // Validate first row structure
    const firstRow = transposedTable.rows[0];
    if (!firstRow || !firstRow.cells) {
        console.error('First row of transposed table is invalid');
        return;
    }

    // Process data rows
    try {
        for (let i = 1; i < firstRow.cells.length; i++) {
            const cptCell = extractCPTCell(firstRow.cells[i]);

            if (cptCell) {
                createLogicDataRow(logicTable, transposedTable, i, cptCell);
            }
        }

        container.appendChild(logicTable);

    } catch (error) {
        console.error('Error constructing logic table:', error);
    }
}

// Helper function to create the header row
function createLogicTableHeader(logicTable) {
    const headerRow = logicTable.insertRow();
    const headers = ['CORA', 'A', 'D', 'E', 'I', 'J'];

    headers.forEach(headerText => {
        const headerCell = headerRow.insertCell();
        headerCell.innerHTML = headerText;
        headerCell.style.backgroundColor = 'lightblue';
    });
}

// Helper function to extract CPT cell data safely
function extractCPTCell(cell) {
    if (!cell || !cell.innerText) {
        return null;
    }

    const lines = cell.innerText.split('\n');
    return lines[1]?.trim() || null;
}

// Helper function to create a data row
function createLogicDataRow(logicTable, transposedTable, columnIndex, cptCell) {
    const logicRow = logicTable.insertRow();

    // Create CPT cell
    const cptCellElem = logicRow.insertCell();
    cptCellElem.innerHTML = cptCell;
    cptCellElem.style.backgroundColor = 'lightcoral';

    // Define the row indices we need to extract data from
    const dataRowIndices = [1, 4, 5, 9, 10]; // A, D, E, I, J

    // Create data cells
    dataRowIndices.forEach(rowIndex => {
        const dataCell = logicRow.insertCell();

        // Safety check for row and cell existence
        if (transposedTable.rows[rowIndex] &&
            transposedTable.rows[rowIndex].cells &&
            transposedTable.rows[rowIndex].cells[columnIndex]) {
            dataCell.innerHTML = transposedTable.rows[rowIndex].cells[columnIndex].innerHTML;
        } else {
            dataCell.innerHTML = ''; // Empty cell for missing data
            console.warn(`Missing data at row ${rowIndex}, column ${columnIndex}`);
        }
    });

    // Apply consistent styling to all cells in the row
    logicRow.querySelectorAll('td').forEach(cell => {
        Object.assign(cell.style, {
            border: '1px solid black',
            padding: '5px',
            fontSize: '1.2em'
        });
    });
}

// Function to construct ATROPS Logic Table
function constructAtropsLogicTable(reportDivs, containerId) {
    // Remove setTimeout and handle synchronously for better reliability
    // Validate inputs
    if (!reportDivs || reportDivs.length === 0) {
        console.warn('No report divs provided to constructAtropsLogicTable');
        return;
    }

    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Container ${containerId} not found`);
        return;
    }

    // Create ATROPS table with consolidated styles
    const atropsTable = document.createElement('table');
    atropsTable.className = 'Atrops-table';
    Object.assign(atropsTable.style, {
        borderCollapse: 'collapse',
        width: '100%',
        marginTop: '20px'
    });

    // Create header row
    createATROPSTableHeader(atropsTable);

    // Process report divs
    try {
        reportDivs.forEach(function(div) {
            if (!div) return;

            const table = div.querySelector('.simple.datatable.csv');
            if (!table) return;

            const rows = table.querySelectorAll('tbody tr');
            processATROPSTableRows(rows, atropsTable);
        });

        container.appendChild(atropsTable);

    } catch (error) {
        console.error('Error constructing ATROPS logic table:', error);
    }
}

// Helper function to create ATROPS table header
function createATROPSTableHeader(atropsTable) {
    const headerRow = atropsTable.insertRow();
    const headers = ['CPT', '% Schedule', 'Cap', 'Schedule'];

    headers.forEach(headerText => {
        const headerCell = headerRow.insertCell();
        headerCell.innerHTML = headerText;
        headerCell.style.backgroundColor = 'lightblue';
    });
}

// Helper function to process ATROPS table rows
function processATROPSTableRows(rows, atropsTable) {
    rows.forEach(function(row) {
        if (!row) return;

        // Check for the specific data value that identifies relevant rows
        const targetCell = row.querySelector('td[data-value="AMZL_US_RUSH_SD"]');
        if (!targetCell) return;

        try {
            const rowData = extractATROPSRowData(row);
            createATROPSDataRow(atropsTable, rowData);
        } catch (error) {
            console.warn('Error processing ATROPS row:', error);
        }
    });
}

// Helper function to extract data from ATROPS row
function extractATROPSRowData(row) {
    // Define column selectors for better maintainability
    const columnSelectors = {
        cpt: 'td:nth-child(23)',
        percentSchedule: 'td:nth-child(21)',
        cap: 'td:nth-child(18)',
        schedule: 'td:nth-child(19)'
    };

    const data = {};

    // Extract CPT with substring processing
    const cptCell = row.querySelector(columnSelectors.cpt);
    if (cptCell && cptCell.innerText && cptCell.innerText.length >= 17) {
        data.cpt = cptCell.innerText.substring(11, 17);
    } else {
        data.cpt = 'N/A';
    }

    // Extract other data fields
    ['percentSchedule', 'cap', 'schedule'].forEach(field => {
        const cell = row.querySelector(columnSelectors[field]);
        data[field] = cell ? cell.innerText : 'N/A';
    });

    return data;
}

// Helper function to create ATROPS data row
function createATROPSDataRow(atropsTable, rowData) {
    const logicRow = atropsTable.insertRow();

    // Insert data in the correct order
    const dataOrder = ['cpt', 'percentSchedule', 'cap', 'schedule'];

    dataOrder.forEach(field => {
        const cell = logicRow.insertCell();
        cell.innerHTML = rowData[field] || 'N/A';
    });

    // Apply consistent styling to all cells
    logicRow.querySelectorAll('td').forEach(cell => {
        Object.assign(cell.style, {
            border: '1px solid black',
            padding: '5px',
            textAlign: 'center',
            fontSize: '1.2em'
        });
    });
}

// Function to select the current CPT in the dropdown
function selectCurrentCPT() {
    const cptInfoContainer = document.getElementById('cptInfoContainer');
    const cptSelect = document.getElementById('cptSelect');

    // Validate required elements exist
    if (!cptInfoContainer) {
        console.warn('CPT info container not found');
        return;
    }

    if (!cptSelect) {
        console.warn('CPT select element not found');
        return;
    }

    // Safely extract CPT info with validation
    const containerText = cptInfoContainer.innerText;
    if (!containerText) {
        console.warn('No text found in CPT info container');
        return;
    }

    try {
        const lines = containerText.split('\n');
        if (lines.length === 0) {
            console.warn('No lines found in CPT info container text');
            return;
        }

        const firstLine = lines[0];
        const parts = firstLine.split(': ');

        if (parts.length < 2) {
            console.warn('CPT info format not as expected - missing colon separator');
            return;
        }

        const cptInfo = parts[1].trim();

        if (!cptInfo) {
            console.warn('No CPT info found after parsing');
            return;
        }

        // Validate that the CPT value exists in the dropdown options
        const options = Array.from(cptSelect.options);
        const matchingOption = options.find(option => option.value === cptInfo);

        if (matchingOption) {
            cptSelect.value = cptInfo;
            console.log(`Successfully selected CPT: ${cptInfo}`);
        } else {
            console.warn(`CPT value "${cptInfo}" not found in dropdown options`);
        }

    } catch (error) {
        console.error('Error parsing CPT info:', error);
    }
}

function updateCPTInfo(now) {
    const siteSelector = document.getElementById('siteSelector');
    const cptSelect = document.getElementById('cptSelect');
    // Validate required elements
    if (!siteSelector || !cptSelect || !siteSelector.value || !cptSelect.value) {
        console.warn('Required elements or values missing for CPT info update');
        return;
    }
    const selectedSite = siteSelector.value;

    // If site is in specialCPTs, use those times and add '20:20'
    // If not in specialCPTs, use default times without '20:20'
    const baseTimes = specialCPTs[selectedSite] || ['00:20', '06:20', '11:20', '14:20', '18:20'];
    const cptTimes = specialCPTs[selectedSite] ? [...baseTimes, '20:20'] : baseTimes;

    const selectedCPT = cptSelect.value;
    const currentCPTIndex = cptTimes.indexOf(selectedCPT);
    const nextCPT = cptTimes[(currentCPTIndex + 1) % cptTimes.length];
    try {
        const currentTimeLeft = calculateAdjustedTimeLeft(selectedCPT, '#SelectedCPTSchedule', now);
        const nextTimeLeft = calculateAdjustedTimeLeft(nextCPT, '#NextCPTSchedule', now);
        // Update displays
        updateCPTDisplay(document.getElementById('cptInfoContainer'), selectedCPT, currentTimeLeft);
        updateCPTDisplay(document.getElementById('nextCPTInfoTableContainer'), nextCPT, nextTimeLeft, true);
    } catch (error) {
        console.error('Error updating CPT info:', error);
    }
}

// Extracted and cleaned up time calculation function
function calculateAdjustedTimeLeft(targetCPT, scheduleTableId, now) {
    // Calculate base target time
    const targetTime = new Date(now);
    const [targetHours, targetMinutes] = targetCPT.split(':').map(Number);
    targetTime.setHours(targetHours, targetMinutes, 0, 0);

    if (targetTime <= now) {
        targetTime.setDate(targetTime.getDate() + 1);
    }

    let totalMinutes = (targetTime - now) / 60000; // Convert to minutes

    // Adjust for breaks and downtime
    const scheduleTable = document.querySelector(scheduleTableId);
    if (scheduleTable && scheduleTable.rows && scheduleTable.rows.length > 2) {
        totalMinutes = adjustForBreaksAndDowntime(scheduleTable, totalMinutes, targetTime, now);
    }

    // Ensure non-negative result
    totalMinutes = Math.max(0, totalMinutes);

    const adjustedHours = Math.floor(totalMinutes / 60);
    const adjustedMins = Math.floor(totalMinutes % 60);

    return `${String(adjustedHours).padStart(2, '0')}:${String(adjustedMins).padStart(2, '0')}`;
}

// Helper function to adjust time for breaks and downtime
function adjustForBreaksAndDowntime(scheduleTable, totalMinutes, targetTime, now) {
    const timeRow = scheduleTable.rows[0];
    const durationRow = scheduleTable.rows[1];
    const blockTypeRow = scheduleTable.rows[2];

    if (!timeRow || !durationRow || !blockTypeRow) {
        return totalMinutes;
    }

    for (let i = 0; i < durationRow.cells.length; i++) {
        if (!timeRow.cells[i] || !durationRow.cells[i] || !blockTypeRow.cells[i]) {
            continue;
        }

        const blockType = blockTypeRow.cells[i].innerText.trim();
        const durationText = durationRow.cells[i].innerText.trim();
        const durationMatch = durationText.match(/(\d+) minutes/);

        if (durationMatch && (blockType === "Break" || blockType === "Downtime")) {
            let duration = parseInt(durationMatch[1], 10);

            // Check if this is the last block before CPT
            const timeText = timeRow.cells[i].innerText;
            if (timeText.includes(' to ')) {
                const [, endTime] = timeText.split(' to ');
                const [endHours, endMinutes] = endTime.split(':').map(Number);
                const blockEndTime = new Date(targetTime);
                blockEndTime.setHours(endHours, endMinutes, 0, 0);

                if (blockEndTime > targetTime) {
                    // Adjust duration for the last block
                    duration = Math.min(duration, (targetTime - now) / 60000);
                }

                totalMinutes -= duration;

                // Stop processing once we reach or pass the CPT
                if (blockEndTime >= targetTime) {
                    break;
                }
            }
        }
    }

    return totalMinutes;
}

// Consolidated event listener setup to prevent duplicates
function setupCPTSelectEventListener() {
    const cptSelect = document.getElementById('cptSelect');
    if (!cptSelect) {
        console.warn('CPT select element not found for event listener setup');
        return;
    }

    // Remove existing listener if any
    if (cptSelect.ufoChangeHandler) {
        cptSelect.removeEventListener('change', cptSelect.ufoChangeHandler);
    }

    // Create consolidated change handler
    cptSelect.ufoChangeHandler = function() {
        manualCPTSelected = true;
        userSelectedRiskModel = false; // Reset risk model flag
        selectedCPTTime = null; // Reset selected time

        try {
            updateSelectedCPT();
            loadRelevantScheduleColumn();
            createAndUpdateMathTable();
            createAndUpdateNextNextCPTMathTable();
            updatePlanSummary3();
        } catch (error) {
            console.error('Error in CPT change handler:', error);
        }
    };

    cptSelect.addEventListener('change', cptSelect.ufoChangeHandler);
}

// Global variables for tracking state
let manualCPTSelected = false;
let selectedCPTTime = null;

// Initialize the event listener
setupCPTSelectEventListener();

function updateSelectedCPT() {
    const cptSelect = document.getElementById('cptSelect');
    const cptInfoContainer = document.getElementById('cptInfoContainer');

    // Validate required elements
    if (!cptSelect || !cptSelect.value) {
        console.warn('CPT select element not found or has no value');
        return;
    }

    if (!cptInfoContainer) {
        console.warn('CPT info container not found');
        return;
    }

    const selectedCPT = cptSelect.value;
    const now = new Date();

    try {
        // Parse the selected CPT time
        const [selectedHours, selectedMinutes] = selectedCPT.split(':').map(Number);
        selectedCPTTime = new Date(now);
        selectedCPTTime.setHours(selectedHours, selectedMinutes, 0, 0);

        // If the selected CPT time has already passed for today, set it for the next day
        if (selectedCPTTime <= now) {
            selectedCPTTime.setDate(selectedCPTTime.getDate() + 1);
        }

        // Calculate the time left until the selected CPT
        const timeLeft = new Date(selectedCPTTime - now);
        const timeLeftString = [
            timeLeft.getUTCHours(),
            timeLeft.getUTCMinutes(),
            timeLeft.getUTCSeconds()
        ].map(val => String(val).padStart(2, '0')).join(':');

        // Update the CPT info container
        cptInfoContainer.innerText = `Current CPT: ${selectedCPT}\nProcessing Time Left for CPT: ${timeLeftString}`;

        // Trigger table updates
        loadRelevantScheduleColumn();

    } catch (error) {
        console.error('Error updating selected CPT:', error);
    }
}

// Utility function to create styled containers with consistent behavior
function createCPTContainer(id, styles = {}) {
    // Check if container already exists
    if (document.getElementById(id)) {
        return document.getElementById(id);
    }

    const container = document.createElement('div');
    container.id = id;

    // Base styles for CPT containers
    const baseStyles = {
        position: 'fixed',
        backgroundColor: 'white',
        padding: '20px',
        zIndex: '10000',
        width: '40%',
        borderRadius: '12px',
        boxShadow: '0 4px 15px rgba(0, 0, 0, 0.1)',
        transition: 'all 0.3s ease',
        opacity: '0',
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
    };

    // Merge base styles with custom styles
    Object.assign(container.style, baseStyles, styles);

    // Add hover effects
    addCPTContainerHoverEffect(container);

    // Add to DOM
    document.body.appendChild(container);

    // Animate in
    setTimeout(() => {
        container.style.opacity = '1';
        // Handle transform based on existing transform
        const currentTransform = container.style.transform || '';
        if (currentTransform.includes('translateY(-10px)')) {
            container.style.transform = currentTransform.replace('translateY(-10px)', 'translateY(0)');
        }
    }, 100);

    return container;
}

// Helper function to add hover effects to CPT containers
function addCPTContainerHoverEffect(container) {
    container.addEventListener('mouseover', () => {
        container.style.boxShadow = '0 6px 20px rgba(0, 0, 0, 0.15)';
    });

    container.addEventListener('mouseout', () => {
        container.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.1)';
    });
}

// Create full table container
const fullTableContainer = createCPTContainer('fullTableContainer', {
    top: '120px',
    left: '55%',
    transform: 'translateX(-60%) translateY(-10px)'
});

// Create next CPT table container
const nextCPTTableContainer = createCPTContainer('nextCPTTableContainer', {
    top: '700px',
    left: '55%',
    transform: 'translateX(-60%) translateY(-10px)'
});


function updateNextCPTInfo(nextCPT) {
    // Validate input
    if (!nextCPT) {
        console.warn('No next CPT provided to updateNextCPTInfo');
        return;
    }

    const container = document.getElementById('nextCPTInfoTableContainer');
    if (!container) {
        console.warn('Next CPT info table container not found');
        return;
    }

    try {
        // Calculate next time left with current time
        const now = new Date();
        const nextTimeLeft = calculateAdjustedTimeLeft(nextCPT, '#NextCPTSchedule', now);

        // Create info display using updateCPTDisplay if available, otherwise fallback
        if (typeof updateCPTDisplay === 'function') {
            updateCPTDisplay(container, nextCPT, nextTimeLeft, true);
        } else {
            // Fallback to direct HTML creation
            const nextCPTInfoHTML = `
                <div style="
                    border: 1px solid black;
                    padding: 10px;
                    font-size: 28px;
                    line-height: 1.2;
                    border-radius: 8px;
                    background-color: #f8fafc;
                ">
                    <div style="font-weight: 600; margin-bottom: 8px;">Next CPT: ${nextCPT}</div>
                    <div>Processing Time Left: ${nextTimeLeft}</div>
                </div>
            `;
            container.innerHTML = nextCPTInfoHTML;
        }

    } catch (error) {
        console.error('Error updating next CPT info:', error);

        // Display error message in container
        container.innerHTML = `
            <div style="
                color: red;
                padding: 10px;
                border: 2px solid red;
                border-radius: 8px;
                background-color: #fee2e2;
            ">
                Error updating next CPT information
            </div>
        `;
    }
}

    function hideLoadingGifForNextCPT() {
    // Validate container exists
    if (typeof nextCPTTableContainer === 'undefined' || !nextCPTTableContainer) {
        console.warn('nextCPTTableContainer not found for loading gif removal');
        return;
    }

    const loadingGif = nextCPTTableContainer.querySelector('img[alt="Loading..."]');
    if (loadingGif) {
        loadingGif.remove();
    } else {
        console.log('No loading gif found to remove');
    }
}

// Function to set initial UFO planner display
function setInitialUFODisplay() {
    // Validate fullTableContainer exists
    if (typeof fullTableContainer === 'undefined' || !fullTableContainer) {
        console.error('fullTableContainer not found for initial display setup');
        return;
    }

    const initialDisplayHTML = `
        <div style="
            text-align: center;
            padding: 20px;
            color: #64748b;
            font-size: 25px;
            background: #f8fafc;
            border-radius: 8px;
            margin: 10px 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        ">
            <img src="https://i.gifer.com/origin/24/2432cf5ff737ad7d1794a29d042eb02e_w200.gif"
                 alt="Loading animation"
                 style="
                     width: 200px;
                     height: auto;
                     margin-bottom: 12px;
                     border-radius: 4px;
                     display: block;
                     margin-left: auto;
                     margin-right: auto;
                 "
                 onerror="this.style.display='none'; console.warn('Failed to load UFO animation');"
            >
            <p style="margin: 0; line-height: 1.4;">
                Please verify you are logged into Midway and then select a site to load UFO planner
            </p>
        </div>
    `;

    fullTableContainer.innerHTML = initialDisplayHTML;
}

// Initialize the display
setInitialUFODisplay();


// Function to get the current site time based on the selected site's time zone
function getCurrentSiteTime(siteTimeZone) {
    // Validate input
    if (!siteTimeZone || typeof siteTimeZone !== 'string') {
        console.warn('Invalid or missing site timezone provided');
        return new Date(); // Return local time as fallback
    }

    try {
        // Test if the timezone is valid by attempting to use it
        const testDate = new Date();
        testDate.toLocaleString("en-US", { timeZone: siteTimeZone });

        // If successful, return the site time
        return new Date(new Date().toLocaleString("en-US", { timeZone: siteTimeZone }));

    } catch (error) {
        console.warn(`Invalid timezone "${siteTimeZone}":`, error.message);
        console.log('Falling back to local time');
        return new Date(); // Return local time as fallback
    }
}

// Function to get the relevant time frame based on the site-specific current time
function getRelevantTimeFrame(schedule, siteTimeZone) {
    // Validate inputs
    if (!schedule || !Array.isArray(schedule) || schedule.length === 0) {
        console.warn('Invalid or empty schedule provided to getRelevantTimeFrame');
        return null;
    }

    if (!siteTimeZone) {
        console.warn('No site timezone provided to getRelevantTimeFrame');
        return null;
    }

    try {
        const currentSiteTime = getCurrentSiteTime(siteTimeZone);
        if (!currentSiteTime) {
            console.warn('Failed to get current site time');
            return null;
        }

        let relevantTimeFrame = null;

        for (const timeWindow of schedule) {
            if (!timeWindow || typeof timeWindow !== 'string') {
                console.warn('Invalid time window in schedule:', timeWindow);
                continue;
            }

            if (!timeWindow.includes(' to ')) {
                console.warn('Time window missing " to " separator:', timeWindow);
                continue;
            }

            try {
                const [startTime, endTime] = timeWindow.split(' to ');

                if (!startTime || !endTime) {
                    console.warn('Invalid start or end time in window:', timeWindow);
                    continue;
                }

                const startDateTime = parseTimeString(startTime, currentSiteTime);
                const endDateTime = parseTimeString(endTime, currentSiteTime);

                // Validate parsed times
                if (!startDateTime || !endDateTime ||
                    isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
                    console.warn('Failed to parse time window:', timeWindow);
                    continue;
                }

                // Check if current time falls within this window
                if (currentSiteTime >= startDateTime && currentSiteTime < endDateTime) {
                    relevantTimeFrame = timeWindow;
                    break; // Found match, exit loop
                }

            } catch (error) {
                console.warn('Error processing time window:', timeWindow, error);
                continue;
            }
        }

        return relevantTimeFrame;

    } catch (error) {
        console.error('Error in getRelevantTimeFrame:', error);
        return null;
    }
}

function parseTimeString(timeString, referenceDate) {
    // Validate inputs
    if (!timeString || typeof timeString !== 'string') {
        console.warn('Invalid timeString provided to parseTimeString:', timeString);
        return null;
    }

    if (!referenceDate || !(referenceDate instanceof Date) || isNaN(referenceDate.getTime())) {
        console.warn('Invalid referenceDate provided to parseTimeString:', referenceDate);
        return null;
    }

    // Validate timeString format
    const parts = timeString.split(' ');
    if (parts.length !== 2) {
        console.warn('TimeString must have format "HH:MM AM/PM":', timeString);
        return null;
    }

    const [time, modifier] = parts;

    // Validate modifier
    if (modifier !== 'AM' && modifier !== 'PM') {
        console.warn('Invalid time modifier (must be AM or PM):', modifier);
        return null;
    }

    // Validate time format
    if (!time.includes(':')) {
        console.warn('Time must include colon separator:', time);
        return null;
    }

    const timeParts = time.split(':');
    if (timeParts.length !== 2) {
        console.warn('Time must have format HH:MM:', time);
        return null;
    }

    let [hours, minutes] = timeParts.map(Number);

    // Validate parsed numbers
    if (isNaN(hours) || isNaN(minutes)) {
        console.warn('Hours and minutes must be valid numbers:', timeString);
        return null;
    }

    // Validate ranges
    if (hours < 1 || hours > 12) {
        console.warn('Hours must be between 1 and 12 for 12-hour format:', hours);
        return null;
    }

    if (minutes < 0 || minutes > 59) {
        console.warn('Minutes must be between 0 and 59:', minutes);
        return null;
    }

    try {
        // Convert to 24-hour format based on AM/PM
        if (modifier === 'PM' && hours !== 12) hours += 12;
        if (modifier === 'AM' && hours === 12) hours = 0;

        // Create new date based on reference date
        const date = new Date(referenceDate);
        date.setHours(hours, minutes, 0, 0);

        // Validate the resulting date
        if (isNaN(date.getTime())) {
            console.warn('Failed to create valid date from time string:', timeString);
            return null;
        }

        return date;

    } catch (error) {
        console.error('Error parsing time string:', timeString, error);
        return null;
    }
}


// Function to log site time and ensure it's being correctly retrieved
function getDisplayedSiteTime() {
    const clockContainer = document.getElementById('clockContainer');

    // Validate clock container exists
    if (!clockContainer) {
        console.warn('Clock container not found');
        return new Date(); // Return current time as fallback
    }

    const clockText = clockContainer.innerText;
    if (!clockText) {
        console.warn('No text found in clock container');
        return new Date(); // Return current time as fallback
    }

    // Validate expected format with colon separator
    if (!clockText.includes(': ')) {
        console.warn('Clock text does not contain expected format with ": ":', clockText);
        return new Date(); // Return current time as fallback
    }

    try {
        const parts = clockText.split(': ');
        if (parts.length < 2) {
            console.warn('Clock text format unexpected:', clockText);
            return new Date();
        }

        const siteTimeString = parts[1];
        if (!siteTimeString) {
            console.warn('No time string found after colon in clock text:', clockText);
            return new Date();
        }

        // Validate time format
        const timeParts = siteTimeString.split(':');
        if (timeParts.length !== 3) {
            console.warn('Site time string must have HH:MM:SS format:', siteTimeString);
            return new Date();
        }

        const [hours, minutes, seconds] = timeParts.map(Number);

        // Validate parsed numbers
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            console.warn('Invalid time components in site time string:', siteTimeString);
            return new Date();
        }

        // Validate time ranges
        if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59 || seconds < 0 || seconds > 59) {
            console.warn('Time components out of valid range:', { hours, minutes, seconds });
            return new Date();
        }

        // Create and validate site time
        const siteTime = new Date();
        siteTime.setHours(hours, minutes, seconds, 0);

        if (isNaN(siteTime.getTime())) {
            console.warn('Failed to create valid date from time components');
            return new Date();
        }

        return siteTime;

    } catch (error) {
        console.error('Error parsing displayed site time:', error);
        return new Date(); // Return current time as fallback
    }
}

// Function to calculate the remaining time for the active time block
function calculateTimeRemaining(startTime, endTime, currentTime) {
    // Validate inputs are Date objects
    if (!(startTime instanceof Date) || !(endTime instanceof Date) || !(currentTime instanceof Date)) {
        console.warn('Invalid Date objects provided to calculateTimeRemaining');
        return "00:00:00";
    }

    // Validate dates are not invalid
    if (isNaN(startTime.getTime()) || isNaN(endTime.getTime()) || isNaN(currentTime.getTime())) {
        console.warn('Invalid Date values provided to calculateTimeRemaining');
        return "00:00:00";
    }

    // Validate logical time order
    if (endTime <= startTime) {
        console.warn('End time must be after start time');
        return "00:00:00";
    }

    // If the current time has passed the block, return zero time left
    if (currentTime >= endTime) {
        return "00:00:00";
    }

    // If current time is before start time, calculate from start time
    const effectiveCurrentTime = currentTime < startTime ? startTime : currentTime;

    try {
        const timeLeft = new Date(endTime - effectiveCurrentTime);

        // Validate the calculated time difference
        if (isNaN(timeLeft.getTime())) {
            console.warn('Failed to calculate valid time difference');
            return "00:00:00";
        }

        const hours = timeLeft.getUTCHours();
        const minutes = timeLeft.getUTCMinutes();
        const seconds = timeLeft.getUTCSeconds();

        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

    } catch (error) {
        console.error('Error calculating time remaining:', error);
        return "00:00:00";
    }
}

// Function to update the time remaining in the active block dynamically for the new (filtered) table
function updateBlockTimeRemainingForNewTable(relevantColumnIndex) {
    const newTable = document.querySelector('#fullTableContainer .SiteSchedule');

    // Validate table exists and has required structure
    if (!newTable || !newTable.rows || newTable.rows.length < 2) {
        console.warn('New table not found or insufficient rows for time remaining update');
        return;
    }

    try {
        const siteTime = getDisplayedSiteTime();
        if (!siteTime) {
            console.warn('Failed to get site time for block update');
            return;
        }

        const timeRow = newTable.rows[0];
        if (!timeRow || !timeRow.cells || !timeRow.cells[0]) {
            console.warn('Time row or first cell not found');
            return;
        }

        // Get the active block (relevant time window)
        const timeWindow = timeRow.cells[0].innerText;
        if (!timeWindow || !timeWindow.includes(' to ')) {
            console.warn('Invalid time window format:', timeWindow);
            return;
        }

        const [startTimeString, endTimeString] = timeWindow.split(' to ');
        if (!startTimeString || !endTimeString) {
            console.warn('Failed to parse start/end times from window:', timeWindow);
            return;
        }

        // Parse times safely
        const startTime = parse12HourTimeToMinutes(startTimeString);
        const endTime = parse12HourTimeToMinutes(endTimeString);

        if (startTime === null || endTime === null) {
            console.warn('Failed to parse time strings:', startTimeString, endTimeString);
            return;
        }

        const currentTimeMinutes = siteTime.getHours() * 60 + siteTime.getMinutes();
        let adjustedEndTime = endTime;
        let adjustedCurrentTime = currentTimeMinutes;

        // Handle midnight crossing
        if (endTime < startTime) {
            if (currentTimeMinutes < startTime) {
                adjustedCurrentTime += 1440; // Add 24 hours worth of minutes
            }
            adjustedEndTime += 1440;
        }

        // Calculate time remaining
        const minutesRemaining = adjustedEndTime - adjustedCurrentTime;

        if (minutesRemaining > 0) {
            updateTimeDisplay(newTable, minutesRemaining);

            // Schedule next update with proper cleanup tracking
            scheduleNextUpdate(relevantColumnIndex);
        } else {
            // Time expired - refresh schedule
            handleTimeExpired();
        }

    } catch (error) {
        console.error('Error updating block time remaining:', error);
    }
}

// Helper function to update the time display
function updateTimeDisplay(table, minutesRemaining) {
    if (!table.rows[1] || !table.rows[1].cells || !table.rows[1].cells[0]) {
        console.warn('Cannot update time display - row/cell not found');
        return;
    }

    const hours = Math.floor(minutesRemaining / 60);
    const minutes = minutesRemaining % 60;
    const timeRemainingString = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

    table.rows[1].cells[0].innerText = `${timeRemainingString} left in block`;
}

// Helper function to handle time expiration
function handleTimeExpired() {
    try {
        loadRelevantScheduleColumn();
        updatePickRebinPackRecommendations();
        createAndUpdateMathTable();
    } catch (error) {
        console.error('Error handling time expiration:', error);
    }
}

// Global variable to track active timeout for cleanup
let blockUpdateTimeout = null;

// Helper function to schedule next update with proper cleanup
function scheduleNextUpdate(relevantColumnIndex) {
    // Clear any existing timeout to prevent accumulation
    if (blockUpdateTimeout) {
        clearTimeout(blockUpdateTimeout);
    }

    blockUpdateTimeout = setTimeout(() => {
        updateBlockTimeRemainingForNewTable(relevantColumnIndex);
    }, 1000);
}

// Cleanup function to stop block updates
function stopBlockTimeUpdates() {
    if (blockUpdateTimeout) {
        clearTimeout(blockUpdateTimeout);
        blockUpdateTimeout = null;
    }
}

// Add cleanup on page unload
window.addEventListener('beforeunload', stopBlockTimeUpdates);


// Function to parse a 12-hour time string (e.g., "11:30 PM") into a Date object using the site time as reference
function parse12HourTime(timeString, referenceDate) {
    // Validate inputs
    if (!timeString || typeof timeString !== 'string') {
        console.warn('Invalid timeString provided to parse12HourTime:', timeString);
        return null;
    }

    if (!referenceDate || !(referenceDate instanceof Date) || isNaN(referenceDate.getTime())) {
        console.warn('Invalid referenceDate provided to parse12HourTime:', referenceDate);
        return null;
    }

    // Validate timeString format
    const parts = timeString.trim().split(' ');
    if (parts.length !== 2) {
        console.warn('TimeString must have format "HH:MM AM/PM":', timeString);
        return null;
    }

    const [time, modifier] = parts;

    // Validate modifier
    if (modifier !== 'AM' && modifier !== 'PM') {
        console.warn('Invalid time modifier (must be AM or PM):', modifier);
        return null;
    }

    // Validate time format
    if (!time.includes(':')) {
        console.warn('Time must include colon separator:', time);
        return null;
    }

    const timeParts = time.split(':');
    if (timeParts.length !== 2) {
        console.warn('Time must have format HH:MM:', time);
        return null;
    }

    let [hours, minutes] = timeParts.map(Number);

    // Validate parsed numbers
    if (isNaN(hours) || isNaN(minutes)) {
        console.warn('Hours and minutes must be valid numbers:', timeString);
        return null;
    }

    // Validate ranges
    if (hours < 1 || hours > 12) {
        console.warn('Hours must be between 1 and 12 for 12-hour format:', hours);
        return null;
    }

    if (minutes < 0 || minutes > 59) {
        console.warn('Minutes must be between 0 and 59:', minutes);
        return null;
    }

    try {
        // Convert to 24-hour format based on AM/PM
        if (modifier === 'PM' && hours !== 12) hours += 12;
        if (modifier === 'AM' && hours === 12) hours = 0;

        // Create a new Date object using the reference date's year, month, and day
        const date = new Date(referenceDate);
        date.setHours(hours, minutes, 0, 0);

        // Validate the resulting date
        if (isNaN(date.getTime())) {
            console.warn('Failed to create valid date from time string:', timeString);
            return null;
        }

        return date;

    } catch (error) {
        console.error('Error parsing 12-hour time:', timeString, error);
        return null;
    }
}

// Function to convert a time string (e.g., "11:30 PM") into minutes since midnight
function convertToMinutesSinceMidnight(timeString) {
    let [time, period] = timeString.split(' ');
    let [hours, minutes] = time.split(':').map(Number);

    // Convert to 24-hour format
    if (period === 'PM' && hours !== 12) hours += 12;
    if (period === 'AM' && hours === 12) hours = 0;

    return hours * 60 + minutes;
}

function loadRelevantScheduleColumn() {
    const originalTable = document.querySelector('.SiteSchedule');
    let selectedSite = document.getElementById('siteSelector').value;
    let selectedCPT = document.getElementById('cptSelect').value;
    showLoadingGif();

    if (originalTable) {
        let siteTime = getDisplayedSiteTime();
        let currentMinutes = siteTime.getHours() * 60 + siteTime.getMinutes();
        let timeRow = originalTable.rows[0];
        let selectedCPTMinutes = convertToMinutesSinceMidnight(selectedCPT);

        function applyCommonCellStyles(cell, isPadded = true) {
            cell.style.cssText = `
                ${isPadded ? 'padding: 16px;' : ''}
                text-align: center;
                color: #1e293b;
                font-size: 16px;
            `;
        }

        function isCPTInTimeWindow(cptStartTime, cptEndTime) {
            let cptStartMinutes = convertToMinutesSinceMidnight(cptStartTime);
            let cptEndMinutes = convertToMinutesSinceMidnight(cptEndTime);
            if (cptEndMinutes < cptStartMinutes) cptEndMinutes += 1440;

            if ((selectedCPTMinutes === 20 || selectedCPTMinutes === 95) && cptEndMinutes > 1440) {
                cptStartMinutes -= 1440;
                cptEndMinutes -= 1440;
            }

            return cptStartMinutes <= selectedCPTMinutes && selectedCPTMinutes < cptEndMinutes;
        }

        let relevantColumnIndex = Array.from(timeRow.cells).findIndex(cell => {
            let [startTime, endTime] = cell.innerText.split(' to ');
            let startMinutes = convertToMinutesSinceMidnight(startTime);
            let endMinutes = convertToMinutesSinceMidnight(endTime);
            if (endMinutes < startMinutes) endMinutes += 1440;
            let adjustedCurrentMinutes = currentMinutes < startMinutes ? currentMinutes + 1440 : currentMinutes;
            return adjustedCurrentMinutes >= startMinutes && adjustedCurrentMinutes < endMinutes;
        });

        if (relevantColumnIndex !== -1) {
            let filteredTable = document.createElement('table');
            filteredTable.classList.add('SiteSchedule', 'SelectedCPTSchedule');
            filteredTable.id = 'SelectedCPTSchedule';
            filteredTable.style.cssText = `
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-top: 15px;
                background: white;
                box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                border-radius: 8px;
                overflow: hidden;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;

            let headerRow = filteredTable.insertRow();
            let currentIndex = relevantColumnIndex;

            do {
                let cell = headerRow.insertCell();
                cell.innerHTML = timeRow.cells[currentIndex].innerHTML;
                cell.style.cssText = `
                    padding: 16px;
                    text-align: center;
                    background-color: #f8fafc;
                    color: #1e293b;
                    font-weight: 700;
                    font-size: 22px;
                    border-bottom: 2px solid #e2e8f0;
                `;

                let [cptStartTime, cptEndTime] = timeRow.cells[currentIndex].innerText.split(' to ');
                if (isCPTInTimeWindow(cptStartTime, cptEndTime)) break;

                currentIndex = (currentIndex + 1) % timeRow.cells.length;
            } while (currentIndex !== relevantColumnIndex);

            const cellStyles = {
                'Production': { backgroundColor: '#BA8E23', hoverColor: '#fef08a' },
                'Break': { backgroundColor: '#cc1100', hoverColor: '#fecaca' },
                'Downtime': { backgroundColor: '#808080', hoverColor: '#cbd5e1' }
            };

            for (let rowIndex = 1; rowIndex < originalTable.rows.length; rowIndex++) {
                let row = originalTable.rows[rowIndex];
                let newRow = filteredTable.insertRow();

                currentIndex = relevantColumnIndex;
                do {
                    let cell = newRow.insertCell();
                    let originalContent = row.cells[currentIndex].innerHTML;

                    if (rowIndex === 2) {
                        let content = originalContent.includes("Production") ? "Production" :
                                      originalContent.includes("Break") ? "Break" : "Downtime";
                        cell.textContent = content;
                        applyCommonCellStyles(cell);
                        Object.assign(cell.style, {
                            fontWeight: '600',
                            cursor: 'pointer',
                            transition: 'all 0.2s ease',
                            backgroundColor: cellStyles[content].backgroundColor
                        });

                        cell.addEventListener('mouseover', () => {
                            cell.style.backgroundColor = cellStyles[content].hoverColor;
                        });

                        cell.addEventListener('mouseout', () => {
                            cell.style.backgroundColor = cellStyles[content].backgroundColor;
                        });

                        cell.addEventListener('click', function() {
                            toggleBlockType(this, this.textContent);
                        });
                    } else {
                        cell.innerHTML = originalContent;
                        applyCommonCellStyles(cell);
                        cell.style.borderBottom = '1px solid #e2e8f0';
                    }

                    let [cptStartTime, cptEndTime] = timeRow.cells[currentIndex].innerText.split(' to ');
                    if (isCPTInTimeWindow(cptStartTime, cptEndTime)) break;

                    currentIndex = (currentIndex + 1) % timeRow.cells.length;
                } while (currentIndex !== relevantColumnIndex);
            }

            fullTableContainer.innerHTML = '';
            fullTableContainer.appendChild(filteredTable);

            if (!document.getElementById('productionGraphic')) {
                createProductionGraphic('fullTableContainer');
            } else {
                updateProductionGraphic();
            }

            updateBlockTimeRemainingForNewTable(relevantColumnIndex);
            updateProcessingTimeLeft();
        } else {
            fullTableContainer.innerHTML = `
                <p style="
                    text-align: center;
                    padding: 20px;
                    color: #64748b;
                    font-size: 16px;
                    background: #f8fafc;
                    border-radius: 8px;
                    margin: 10px 0;
                ">No relevant time frame found. Please check the schedule.</p>`;
        }
    }
    loadNextCPTScheduleColumn();
}

function loadNextCPTScheduleColumn() {
    try {
        showLoadingGifForNextCPT();
        const originalTable = document.querySelector('.SiteSchedule');
        const siteSelector = document.getElementById('siteSelector');
        const cptSelect = document.getElementById('cptSelect');
        if (!originalTable || !siteSelector || !cptSelect) {
            throw new Error('Required DOM elements not found');
        }
        let selectedSite = siteSelector.value;
        let selectedCPT = cptSelect.value;

        // If site is in specialCPTs, use those times and add '20:20'
        // If not in specialCPTs, use default times without '20:20'
        const baseTimes = specialCPTs[selectedSite] || ['00:20', '06:20', '11:20', '14:20', '18:20'];
        const cptTimes = specialCPTs[selectedSite] ? [...baseTimes, '20:20'] : baseTimes;

        let currentCPTIndex = cptTimes.indexOf(selectedCPT);
        if (currentCPTIndex === -1) {
            throw new Error('Selected CPT not found in available times');
        }
        let nextCPTIndex = (currentCPTIndex + 1) % cptTimes.length;
        let nextCPT = cptTimes[nextCPTIndex];
        let timeRow = originalTable.rows[0];
        if (!timeRow || timeRow.cells.length === 0) {
            throw new Error('Invalid table structure');
        }
        let currentCPTColumns = new Set();
        let currentCPTTable = document.getElementById('SelectedCPTSchedule');
        if (currentCPTTable && currentCPTTable.rows[0]) {
            for (let i = 0; i < currentCPTTable.rows[0].cells.length; i++) {
                currentCPTColumns.add(currentCPTTable.rows[0].cells[i].innerText);
            }
        }
        let nextCPTColumnIndex = findNextAvailableColumn(timeRow, currentCPTColumns);
        if (nextCPTColumnIndex !== null) {
            let filteredTable = createNextCPTTable(originalTable, timeRow, nextCPTColumnIndex, nextCPT);
            displayNextCPTResults(filteredTable, nextCPT);
        } else {
            displayNoNextCPTMessage();
        }
        loadNextNextCPTScheduleColumn();
    } catch (error) {
        console.error('Error in loadNextCPTScheduleColumn:', error);
        setTimeout(() => {
            nextCPTTableContainer.innerHTML = `
                <p style="text-align: center; padding: 20px; color: #ef4444; font-size: 16px; background: #fef2f2; border-radius: 8px; margin: 10px 0;">
                    Error loading next CPT schedule. Please try again.
                </p>
            `;
            hideLoadingGifForNextCPT();
        }, 1000);
    }
}

function findNextAvailableColumn(timeRow, currentCPTColumns) {
    for (let i = 0; i < timeRow.cells.length; i++) {
        if (!currentCPTColumns.has(timeRow.cells[i].innerText)) {
            return i;
        }
    }
    return null;
}

function createNextCPTTable(originalTable, timeRow, startColumnIndex, nextCPT) {
    let filteredTable = document.createElement('table');
    filteredTable.classList.add('SiteSchedule');
    filteredTable.style.cssText = `
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-top: 15px;
        background: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        border-radius: 8px;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;
    filteredTable.id = 'NextCPTSchedule';
    filteredTable.classList.add('NextCPTSchedule');

    let nextCPTMinutes = convertToMinutesSinceMidnight(nextCPT);
    let columnsToInclude = getColumnsForCPT(timeRow, startColumnIndex, nextCPTMinutes);

    // Create header row
    let headerRow = filteredTable.insertRow();
    columnsToInclude.forEach(columnIndex => {
        let cell = headerRow.insertCell();
        cell.innerHTML = timeRow.cells[columnIndex].innerHTML;
        cell.style.cssText = `
            padding: 16px;
            text-align: center;
            background-color: #f8fafc;
            color: #1e293b;
            font-weight: 700;
            font-size: 22px;
            border-bottom: 2px solid #e2e8f0;
        `;
    });

    // Create data rows
    for (let rowIndex = 1; rowIndex < originalTable.rows.length; rowIndex++) {
        let row = originalTable.rows[rowIndex];
        let newRow = filteredTable.insertRow();

        columnsToInclude.forEach(columnIndex => {
            let cell = newRow.insertCell();
            let originalContent = row.cells[columnIndex].innerHTML;

            if (rowIndex === 2) {
                setupInteractiveCell(cell, originalContent);
            } else {
                cell.innerHTML = originalContent;
                cell.style.cssText = `
                    padding: 16px;
                    text-align: center;
                    color: #1e293b;
                    font-size: 16px;
                    border-bottom: 1px solid #e2e8f0;
                `;
            }
        });
    }

    return filteredTable;
}

function getColumnsForCPT(timeRow, startColumnIndex, nextCPTMinutes) {
    let columnsToInclude = [];
    let currentIndex = startColumnIndex;
    let maxIterations = timeRow.cells.length;
    let iterations = 0;

    while (iterations < maxIterations) {
        columnsToInclude.push(currentIndex);

        let cptTimeWindow = timeRow.cells[currentIndex].innerText;
        if (isTimeInCPTWindow(cptTimeWindow, nextCPTMinutes)) {
            break;
        }

        currentIndex = (currentIndex + 1) % timeRow.cells.length;
        iterations++;

        if (currentIndex === startColumnIndex && iterations > 0) {
            break;
        }
    }

    return columnsToInclude;
}

function isTimeInCPTWindow(timeWindow, targetMinutes) {
    let [startTime, endTime] = timeWindow.split(' to ');
    let startMinutes = convertToMinutesSinceMidnight(startTime);
    let endMinutes = convertToMinutesSinceMidnight(endTime);

    if (endMinutes < startMinutes) endMinutes += 1440;

    // Handle special cases for early morning times
    if ((targetMinutes === 20 || targetMinutes === 95) && endMinutes > 1440) {
        startMinutes -= 1440;
        endMinutes -= 1440;
    }

    return startMinutes <= targetMinutes && targetMinutes < endMinutes;
}

function setupInteractiveCell(cell, originalContent) {
    cell.textContent = originalContent.includes("Production") ? "Production" :
                      originalContent.includes("Break") ? "Break" : "Downtime";
    cell.style.cssText = `
        padding: 16px;
        text-align: center;
        font-weight: 600;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.2s ease;
        color: black;
    `;

    if (cell.textContent === "Production") {
        cell.style.backgroundColor = '#fef9c3';
    } else if (cell.textContent === "Break") {
        cell.style.backgroundColor = '#fee2e2';
    } else {
        cell.style.backgroundColor = '#e2e8f0';
    }

    // Use event delegation to avoid memory leaks
    cell.setAttribute('data-block-type', cell.textContent);
}

function displayNextCPTResults(filteredTable, nextCPT) {
    setTimeout(() => {
        nextCPTTableContainer.innerHTML = `
            <h3 style="
                color: #2c3e50;
                font-size: 24px;
                margin-bottom: 20px;
                padding-bottom: 10px;
                border-bottom: 2px solid #ecf0f1;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            ">Next CPT Schedule (${nextCPT})</h3>
        `;
        nextCPTTableContainer.appendChild(filteredTable);

        // Set up event delegation for interactive cells
        nextCPTTableContainer.addEventListener('click', handleCellClick);

        let productionGraphicContainer = document.createElement('div');
        productionGraphicContainer.id = 'nextCPTProductionGraphicContainer';
        nextCPTTableContainer.appendChild(productionGraphicContainer);

        createNextCPTProductionGraphic('nextCPTProductionGraphicContainer');
        updateNextCPTInfo(nextCPT);
        hideLoadingGifForNextCPT();
    }, 1000);
}

function displayNoNextCPTMessage() {
    setTimeout(() => {
        nextCPTTableContainer.innerHTML = `
            <p style="
                text-align: center;
                padding: 20px;
                color: #64748b;
                font-size: 16px;
                background: #f8fafc;
                border-radius: 8px;
                margin: 10px 0;
            ">No next CPT found or all CPTs are covered in the current table.</p>
        `;
        hideLoadingGifForNextCPT();
    }, 1000);
}

function handleCellClick(event) {
    const cell = event.target;
    const blockType = cell.getAttribute('data-block-type');
    if (blockType) {
        toggleBlockType(cell, blockType, true);
    }
}

function createProductionGraphic(containerId) {
    const container = document.getElementById(containerId);
    const pickRateElement = document.getElementById('pickRate');
    const packRateElement = document.getElementById('packRate');

    if (!container || !pickRateElement || !packRateElement) return;

    const table = createBaseTable();
    const rowConfigs = getRowConfigurations(pickRateElement.value, packRateElement.value);

    createHeaderRow(table);
    createTotalsRow(table);
    createDataRows(table, rowConfigs);

    container.appendChild(table);
    addEventListeners(table, pickRateElement, packRateElement);

    updateProductionGraphic();
    updateVNAPackRecommendations();
}

function createBaseTable() {
    try {
        // Remove existing table with same ID if it exists
        const existing = document.getElementById('productionGraphic');
        if (existing) {
            // Clean up any event listeners before removal
            const cells = existing.querySelectorAll('[data-has-listeners]');
            cells.forEach(cell => {
                cell.removeEventListener('click', cell._clickHandler);
                cell.removeEventListener('mouseover', cell._mouseoverHandler);
                cell.removeEventListener('mouseout', cell._mouseoutHandler);
            });
            existing.remove();
        }

        const table = document.createElement('table');
        if (!table) {
            throw new Error('Failed to create table element');
        }

        table.id = 'productionGraphic';
        table.style.cssText = `
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border-radius: 8px;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        `;

        // Add error handling attribute for debugging
        table.setAttribute('data-created-timestamp', Date.now());

        return table;

    } catch (error) {
        console.error('Error in createBaseTable:', error);
        // Return a basic fallback table
        const fallbackTable = document.createElement('table');
        fallbackTable.id = 'productionGraphic';
        fallbackTable.style.width = '100%';
        return fallbackTable;
    }
}

function getRowConfigurations(pickRate, packRate) {
    return [
        {
            name: 'Pick2Rebin Pick',
            defaultValue: 'X',
            isToggleable: true,
            defaultRate: pickRate,
            background: '#f0f9ff'
        },
        {
            name: 'Pick2Rebin Pack',
            defaultValue: 'X',
            isToggleable: true,
            defaultRate: packRate,
            background: '#f0f9ff'
        },
        {
            name: 'VNA Pick',
            defaultValue: 'X',
            isToggleable: true,
            defaultRate: 100,
            background: '#f3f4f6'
        },
        {
            name: 'VNA Pack',
            defaultValue: 'X',
            isToggleable: true,
            defaultRate: 100,
            background: '#f3f4f6'
        },
        {
            name: 'Outbound Problem Solve',
            defaultValue: 1,
            isToggleable: false,
            background: '#fef3c7'
        }
    ];
}

function createHeaderRow(table) {
    try {
        if (!table) {
            throw new Error('Table parameter is required');
        }

        const headerRow = table.insertRow();
        if (!headerRow) {
            throw new Error('Failed to create header row');
        }

        // Create recommendation cell
        const recommendationCell = headerRow.insertCell();
        if (!recommendationCell) {
            throw new Error('Failed to create recommendation cell');
        }

        recommendationCell.textContent = 'Recommendation';
        recommendationCell.style.cssText = `
            padding: 16px;
            background-color: #f8fafc;
            color: #1e293b;
            font-weight: 600;
            font-size: 16px;
            border-bottom: 2px solid #e2e8f0;
            text-align: left;
        `;

        // Define reusable header cell style
        const headerCellStyle = `
            padding: 16px;
            background-color: #f8fafc;
            color: #1e293b;
            font-weight: 600;
            font-size: 16px;
            border-bottom: 2px solid #e2e8f0;
            text-align: center;
            display: none;
        `;

        // Create 24 header cells efficiently
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < 24; i++) {
            const cell = headerRow.insertCell();
            if (!cell) {
                console.warn(`Failed to create header cell at index ${i}`);
                continue;
            }
            cell.style.cssText = headerCellStyle;
            cell.setAttribute('data-hour-index', i);
        }

        return headerRow;

    } catch (error) {
        console.error('Error in createHeaderRow:', error);
        // Return null to indicate failure, let caller handle
        return null;
    }
}

function createTotalsRow(table) {
    try {
        if (!table) {
            throw new Error('Table parameter is required');
        }

        const totalsRow = table.insertRow();
        if (!totalsRow) {
            throw new Error('Failed to create totals row');
        }

        // Create totals label cell
        const totalsLabelCell = totalsRow.insertCell();
        if (!totalsLabelCell) {
            throw new Error('Failed to create totals label cell');
        }

        totalsLabelCell.textContent = 'Outbound Totals';
        totalsLabelCell.style.cssText = `
            padding: 16px;
            background-color: #f8fafc;
            color: #1e293b;
            font-weight: 700;
            font-size: 16px;
            border-bottom: 2px solid #e2e8f0;
        `;

        // Define reusable totals cell style
        const totalsCellStyle = `
            padding: 16px;
            text-align: center;
            background-color: #f8fafc;
            color: #1e293b;
            font-weight: 700;
            font-size: 16px;
            border-bottom: 2px solid #e2e8f0;
            display: none;
        `;

        // Create 24 totals cells with error handling
        for (let i = 0; i < 24; i++) {
            const cell = totalsRow.insertCell();
            if (!cell) {
                console.warn(`Failed to create totals cell at index ${i}`);
                continue;
            }
            cell.style.cssText = totalsCellStyle;
            cell.setAttribute('data-totals-hour', i);
            cell.setAttribute('data-cell-type', 'totals');
        }

        return totalsRow;

    } catch (error) {
        console.error('Error in createTotalsRow:', error);
        return null;
    }
}

function createDataRows(table, rowConfigs) {
    try {
        if (!table) {
            throw new Error('Table parameter is required');
        }

        if (!Array.isArray(rowConfigs)) {
            throw new Error('rowConfigs must be an array');
        }

        const results = [];
        rowConfigs.forEach((config, index) => {
            try {
                if (!config || typeof config !== 'object') {
                    console.warn(`Invalid config at index ${index}:`, config);
                    return;
                }

                const requiredFields = ['name', 'defaultValue', 'isToggleable', 'defaultRate', 'background'];
                const missingFields = requiredFields.filter(field => config[field] === undefined);

                if (missingFields.length > 0) {
                    console.warn(`Config at index ${index} missing fields:`, missingFields);
                }

                const result = addCustomRow(
                    table,
                    config.name || `Row ${index}`,
                    new Array(24).fill(''),
                    config.defaultValue || 0,
                    config.isToggleable || false,
                    config.defaultRate || 0,
                    config.background || '#ffffff'
                );

                results.push(result);

            } catch (configError) {
                console.error(`Error processing config at index ${index}:`, configError);
            }
        });

        return results;

    } catch (error) {
        console.error('Error in createDataRows:', error);
        return [];
    }
}

function addEventListeners(table, pickRateElement, packRateElement) {
    try {
        if (!table) {
            throw new Error('Table parameter is required');
        }

        // Validate rate elements exist
        if (!pickRateElement) {
            console.warn('pickRateElement not provided or not found');
        } else {
            // Remove existing listeners to prevent duplicates
            const existingPickHandler = pickRateElement._pickRateHandler;
            if (existingPickHandler) {
                pickRateElement.removeEventListener('change', existingPickHandler);
            }

            // Create and store new handler
            const pickRateHandler = () => {
                try {
                    updateDefaultRates(table, 'Pick2Rebin Pick');
                } catch (error) {
                    console.error('Error in pick rate change handler:', error);
                }
            };

            pickRateElement._pickRateHandler = pickRateHandler;
            pickRateElement.addEventListener('change', pickRateHandler);
        }

        if (!packRateElement) {
            console.warn('packRateElement not provided or not found');
        } else {
            // Remove existing listeners to prevent duplicates
            const existingPackHandler = packRateElement._packRateHandler;
            if (existingPackHandler) {
                packRateElement.removeEventListener('change', existingPackHandler);
            }

            // Create and store new handler
            const packRateHandler = () => {
                try {
                    updateDefaultRates(table, 'Pick2Rebin Pack');
                } catch (error) {
                    console.error('Error in pack rate change handler:', error);
                }
            };

            packRateElement._packRateHandler = packRateHandler;
            packRateElement.addEventListener('change', packRateHandler);
        }

        // Add VNA rate change listeners with error handling
        try {
            addVNARateChangeListeners(table);
        } catch (vnaError) {
            console.error('Error adding VNA rate change listeners:', vnaError);
        }

        return true;

    } catch (error) {
        console.error('Error in addEventListeners:', error);
        return false;
    }
}


function parse12HourTimeToMinutes(timeString) {
    try {
        const [time, modifier] = timeString.split(' ');
        let [hours, minutes] = time.split(':').map(Number);

        if (isNaN(hours) || isNaN(minutes)) {
            throw new Error('Invalid time format');
        }

        hours = modifier === 'PM' && hours !== 12 ? hours + 12 :
               modifier === 'AM' && hours === 12 ? 0 : hours;

        return hours * 60 + minutes;
    } catch (error) {
        console.error('Error parsing time:', error);
        return 0;
    }
}

function createDebouncedFunctions(functions, wait = 250) {
    try {
        if (!functions || typeof functions !== 'object') {
            throw new Error('Functions parameter must be an object');
        }

        if (typeof wait !== 'number' || wait < 0) {
            console.warn('Invalid wait time, using default 250ms');
            wait = 250;
        }

        const result = {};
        const entries = Object.entries(functions);

        for (const [key, func] of entries) {
            if (typeof func !== 'function') {
                console.warn(`Skipping non-function property: ${key}`);
                continue;
            }
            result[key] = debounce(func, wait);
        }

        return result;

    } catch (error) {
        console.error('Error in createDebouncedFunctions:', error);
        return {};
    }
}

const debounce = (func, wait) => {
    if (typeof func !== 'function') {
        throw new Error('First argument must be a function');
    }

    let timeout;
    const debouncedFunction = (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            try {
                func.apply(null, args);
            } catch (error) {
                console.error('Error in debounced function:', error);
            }
        }, wait);
    };

    // Add cleanup method to prevent memory leaks
    debouncedFunction.cancel = () => {
        clearTimeout(timeout);
        timeout = null;
    };

    return debouncedFunction;
};

const debouncedUpdates = createDebouncedFunctions({
    updateSiteHeader,
    updateMaxWalls,
    refreshData,
    updateTimestamp,
    updateRTSVolume,
    updateCPTBasedOnSiteTime,
    fetchAndDisplayOutboundPlanning,
    fetchAndDisplayRodeoInfo,
    fetchAndDisplayNextCPTRodeoInfo,
    createSettingsButton2,
    attachSettingsButton2,
    updatePlanSummary1,
    updatePlanSummary2,
    updatePlanSummary3,
    updatePlanSummary4,
    updatePlanSummary5,
    updatePlanSummary6,
});

class SiteSelector {
    constructor() {
        try {
            this.selector = document.getElementById('siteSelector');
            if (!this.selector) {
                throw new Error('Site selector element not found');
            }
            this.isProcessing = false;
            this.currentOperations = new Set();
            this.setupEventListeners();
        } catch (error) {
            console.error('Error initializing SiteSelector:', error);
            throw error;
        }
    }

    setupEventListeners() {
        try {
            // Remove existing listener to prevent duplicates
            if (this.handleSiteChange) {
                this.selector.removeEventListener('change', this.handleSiteChange);
            }

            this.boundHandleSiteChange = this.handleSiteChange.bind(this);
            this.selector.addEventListener('change', this.boundHandleSiteChange);
        } catch (error) {
            console.error('Error setting up event listeners:', error);
        }
    }

    async handleSiteChange() {
        try {
            // Prevent concurrent operations
            if (this.isProcessing) {
                console.log('Site change already in progress, skipping');
                return;
            }

            this.isProcessing = true;
            const selectedSite = this.selector.value;

            if (!selectedSite) {
                this.clearSiteHeader();
                return;
            }

            this.initializeUIForChange(selectedSite);
            await this.executeMainOperations(selectedSite);
            this.updateSettings(selectedSite);

        } catch (error) {
            console.error('Error handling site change:', error);
            // Restore UI state on error
            this.hideLoadingIndicators();
        } finally {
            this.isProcessing = false;
            this.currentOperations.clear();
        }
    }

    clearSiteHeader() {
        try {
            const existingHeader = document.getElementById('siteHeader');
            if (existingHeader) {
                existingHeader.remove();
            }
        } catch (error) {
            console.error('Error clearing site header:', error);
        }
    }

    initializeUIForChange(selectedSite) {
        try {
            if (typeof updateSiteHeader === 'function') {
                updateSiteHeader(selectedSite);
            }

            this.showLoadingIndicators();
            this.clearContainers();
            this.resetGlobalState();
        } catch (error) {
            console.error('Error initializing UI for change:', error);
        }
    }

    showLoadingIndicators() {
        try {
            if (typeof showLoadingGif === 'function') {
                showLoadingGif();
            }
            if (typeof showLoadingGifForNextCPT === 'function') {
                showLoadingGifForNextCPT();
            }
        } catch (error) {
            console.error('Error showing loading indicators:', error);
        }
    }

    hideLoadingIndicators() {
        try {
            if (typeof hideLoadingGif === 'function') {
                hideLoadingGif();
            }
            if (typeof hideLoadingGifForNextCPT === 'function') {
                hideLoadingGifForNextCPT();
            }
        } catch (error) {
            console.error('Error hiding loading indicators:', error);
        }
    }

    clearContainers() {
        const containerIds = ['tableContainer', 'fullTableContainer', 'nextCPTTableContainer'];

        containerIds.forEach(id => {
            try {
                const container = document.getElementById(id);
                if (container) {
                    // Clean up any event listeners before clearing
                    const elementsWithListeners = container.querySelectorAll('[data-has-listeners]');
                    elementsWithListeners.forEach(element => {
                        if (element._eventListeners) {
                            Object.entries(element._eventListeners).forEach(([event, handler]) => {
                                element.removeEventListener(event, handler);
                            });
                        }
                    });
                    container.innerHTML = '';
                }
            } catch (error) {
                console.error(`Error clearing container ${id}:`, error);
            }
        });
    }

    resetGlobalState() {
        try {
            if (typeof manualCPTSelected !== 'undefined') {
                manualCPTSelected = false;
            }
            if (typeof selectedCPTTime !== 'undefined') {
                selectedCPTTime = null;
            }
            if (typeof initializeDispatchRecommendation === 'function') {
                initializeDispatchRecommendation();
            }
        } catch (error) {
            console.error('Error resetting global state:', error);
        }
    }

    async executeMainOperations(selectedSite) {
        try {
            // Cancel any previous debounced operations
            Object.values(debouncedUpdates).forEach(debouncedFunc => {
                if (debouncedFunc.cancel) {
                    debouncedFunc.cancel();
                }
            });

            const basicOpsPromise = this.executeBasicOperations();
            const rtsOpsPromise = this.executeRTSOperation(selectedSite);
            const tableLoadPromise = this.waitForTableToLoad();

            await Promise.allSettled([basicOpsPromise, rtsOpsPromise, tableLoadPromise]);

            // Only proceed if not cancelled
            if (!this.currentOperations.has('cancelled')) {
                this.executePostOperations(selectedSite);
            }

        } catch (error) {
            console.error('Error in site selection operations:', error);
            throw error;
        }
    }

    async executeBasicOperations() {
        const operations = [];

        try {
            if (typeof updateMaxWalls === 'function') {
                operations.push(Promise.resolve(updateMaxWalls(this.selector.value)));
            }
            if (typeof refreshData === 'function') {
                operations.push(Promise.resolve(refreshData()));
            }
            if (typeof updateTimestamp === 'function') {
                operations.push(Promise.resolve(updateTimestamp()));
            }

            return await Promise.allSettled(operations);
        } catch (error) {
            console.error('Error in basic operations:', error);
            throw error;
        }
    }

    async executeRTSOperation(selectedSite) {
        try {
            if (typeof fetchRTSData === 'function' && typeof updateRTSVolume === 'function') {
                const rtsVolume = await fetchRTSData(selectedSite);
                updateRTSVolume(rtsVolume);
            }
        } catch (error) {
            console.error('Error in RTS operation:', error);
            // Don't throw - this is non-critical
        }
    }

    async waitForTableToLoad() {
        try {
            if (typeof waitForTableToLoad === 'function') {
                return await waitForTableToLoad();
            }
        } catch (error) {
            console.error('Error waiting for table to load:', error);
            // Don't throw - this is non-critical
        }
    }

    executePostOperations(selectedSite) {
        try {
            if (typeof updateCPTBasedOnSiteTime === 'function') {
                updateCPTBasedOnSiteTime();
            }
            if (typeof fetchAndDisplayOutboundPlanning === 'function') {
                fetchAndDisplayOutboundPlanning(selectedSite);
            }

            setTimeout(() => {
                try {
                    if (typeof fetchAndDisplayRodeoInfo === 'function') {
                        fetchAndDisplayRodeoInfo();
                    }
                    if (typeof fetchAndDisplayNextCPTRodeoInfo === 'function') {
                        fetchAndDisplayNextCPTRodeoInfo();
                    }
                } catch (error) {
                    console.error('Error in delayed post operations:', error);
                }
            }, 1000);
        } catch (error) {
            console.error('Error in post operations:', error);
        }
    }

    updateSettings(selectedSite) {
        try {
            // Clean up existing settings button
            if (typeof settingsButton2 !== 'undefined' && settingsButton2) {
                if (settingsButton2.remove) {
                    settingsButton2.remove();
                }
                settingsButton2 = null;
            }

            setTimeout(() => {
                try {
                    if (typeof createSettingsButton2 === 'function') {
                        createSettingsButton2();
                    }
                    if (typeof attachSettingsButton2 === 'function') {
                        attachSettingsButton2();
                    }
                    if (typeof updatePlanSummary1 === 'function') {
                        updatePlanSummary1();
                    }
                    if (typeof updatePlanSummary2 === 'function') {
                        updatePlanSummary2();
                    }
                    if (typeof updatePlanSummary3 === 'function') {
                        updatePlanSummary3();
                    }
                } catch (error) {
                    console.error('Error in delayed settings update:', error);
                }
            }, 1000);
        } catch (error) {
            console.error('Error updating settings:', error);
        }
    }

    destroy() {
        try {
            // Cancel any pending debounced operations
            Object.values(debouncedUpdates).forEach(debouncedFunc => {
                if (debouncedFunc.cancel) {
                    debouncedFunc.cancel();
                }
            });

            // Remove event listeners
            if (this.selector && this.boundHandleSiteChange) {
                this.selector.removeEventListener('change', this.boundHandleSiteChange);
            }

            // Mark current operations as cancelled
            this.currentOperations.add('cancelled');
        } catch (error) {
            console.error('Error destroying SiteSelector:', error);
        }
    }
}

// Initialize the site selector with error handling
let siteSelector;
try {
    siteSelector = new SiteSelector();
} catch (error) {
    console.error('Failed to initialize SiteSelector:', error);
    // Could implement fallback functionality here
}


function updateCPTBasedOnSiteTime() {
    const siteSelector = document.getElementById('siteSelector');
    const cptSelect = document.getElementById('cptSelect');

    if (!isValidForUpdate(siteSelector, cptSelect)) return;

    const site = siteSelector.value;
    const currentTime = getSiteCurrentTime(site);
    const nextCPT = determineNextCPT(site, currentTime);

    updateCPTIfChanged(cptSelect, nextCPT);
}

function isValidForUpdate(siteSelector, cptSelect) {
    if (!siteSelector || !cptSelect) {
        console.error('Required elements not found');
        return false;
    }

    if (!siteSelector.value || manualCPTSelected) {
        return false;
    }

    return true;
}

function getSiteCurrentTime(site) {
    try {
        const timeZone = timeZones[siteTimeZones[site]];
        if (!timeZone) {
            throw new Error(`Invalid timezone for site: ${site}`);
        }

        return new Date(new Date().toLocaleString("en-US", { timeZone }));
    } catch (error) {
        console.error('Error getting site time:', error);
        return new Date(); // Fallback to local time
    }
}

function determineNextCPT(site, currentTime) {
    const currentHour = currentTime.getHours();
    const currentMinute = currentTime.getMinutes();

    // If site is in specialCPTs, use those times and add '20:20'
    // If not in specialCPTs, use default times without '20:20'
    const baseTimes = specialCPTs[site] || ['00:20', '06:20', '11:20', '14:20', '18:20'];
    const cptTimes = specialCPTs[site] ? [...baseTimes, '20:20'] : baseTimes;

    return findNextCPT(cptTimes, currentHour, currentMinute);
}

function findNextCPT(cptTimes, currentHour, currentMinute) {
    // Default to first CPT of next day if no later CPT is found
    let nextCPT = cptTimes[0];

    for (let cpt of cptTimes) {
        const [cptHour, cptMinute] = parseCPTTime(cpt);

        if (isTimeEarlier(currentHour, currentMinute, cptHour, cptMinute)) {
            nextCPT = cpt;
            break;
        }
    }

    return nextCPT;
}

function parseCPTTime(cpt) {
    try {
        const [cptHour, cptMinute] = cpt.split(':').map(Number);

        if (isNaN(cptHour) || isNaN(cptMinute)) {
            throw new Error(`Invalid CPT time format: ${cpt}`);
        }

        return [cptHour, cptMinute];
    } catch (error) {
        console.error('Error parsing CPT time:', error);
        return [0, 0]; // Fallback to midnight
    }
}

function isTimeEarlier(currentHour, currentMinute, targetHour, targetMinute) {
    return currentHour < targetHour ||
           (currentHour === targetHour && currentMinute < targetMinute);
}

function updateCPTIfChanged(cptSelect, nextCPT) {
    if (cptSelect.value !== nextCPT) {
        cptSelect.value = nextCPT;

        try {
            updateSelectedCPT();
            loadRelevantScheduleColumn();
        } catch (error) {
            console.error('Error updating CPT selection:', error);
        }
    }
}


function populateCPTDropdown() {
    const siteSelector = document.getElementById('siteSelector');
    const cptSelect = document.getElementById('cptSelect');
    const selectedSite = siteSelector.value;
    // Clear existing options
    cptSelect.innerHTML = '';

    // If site is in specialCPTs, use those times and add '20:20'
    // If not in specialCPTs, use default times without '20:20'
    const baseTimes = specialCPTs[selectedSite] || ['00:20', '06:20', '11:20', '14:20', '18:20'];
    const cptTimes = specialCPTs[selectedSite] ? [...baseTimes, '20:20'] : baseTimes;

    // Populate dropdown
    cptTimes.forEach(cpt => {
        const option = document.createElement('option');
        option.value = cpt;
        option.textContent = cpt;
        cptSelect.appendChild(option);
    });
    // Trigger CPT update
    updateCPTBasedOnSiteTime();
}

// Call this function when the site is changed
document.getElementById('siteSelector').addEventListener('change', populateCPTDropdown);


    // Update the 'waitForTableToLoad' function to wait until the schedule is fully loaded
function waitForTableToLoad(timeout = 15000) {
    return new Promise((resolve, reject) => {
        try {
            if (typeof timeout !== 'number' || timeout <= 0) {
                timeout = 15000;
            }

            let startTime = Date.now();
            let interval;

            const checkTable = () => {
                try {
                    const elapsed = Date.now() - startTime;
                    const originalTable = document.querySelector('.SiteSchedule');

                    // Enhanced table validation
                    if (originalTable &&
                        originalTable.rows &&
                        originalTable.rows.length > 1 &&
                        originalTable.rows[0] &&
                        originalTable.rows[0].cells &&
                        originalTable.rows[0].cells.length > 1) {

                        // Additional validation: check if table has meaningful content
                        const hasContent = Array.from(originalTable.rows).some(row =>
                            Array.from(row.cells).some(cell =>
                                cell.textContent && cell.textContent.trim().length > 0
                            )
                        );

                        if (hasContent) {
                            clearInterval(interval);
                            resolve(originalTable);
                            return;
                        }
                    }

                    if (elapsed >= timeout) {
                        clearInterval(interval);
                        reject(new Error(`Table failed to load within ${timeout}ms timeout. Found table: ${!!originalTable}, Rows: ${originalTable?.rows?.length || 0}`));
                        return;
                    }
                } catch (error) {
                    clearInterval(interval);
                    reject(new Error(`Error checking table load status: ${error.message}`));
                }
            };

            // Initial check
            checkTable();

            // Set up interval only if initial check didn't resolve
            interval = setInterval(checkTable, 500);

            // Cleanup function for promise rejection/resolution
            const cleanup = () => {
                if (interval) {
                    clearInterval(interval);
                    interval = null;
                }
            };

            // Ensure cleanup happens even if promise is abandoned
            setTimeout(() => {
                if (interval) {
                    cleanup();
                    reject(new Error('Promise abandoned - timeout cleanup'));
                }
            }, timeout + 1000);

        } catch (error) {
            reject(new Error(`Failed to initialize table load watcher: ${error.message}`));
        }
    });
}

// Enhanced image preloading with error handling and fallbacks
class ImagePreloader {
    constructor() {
        this.preloadedImages = new Map();
        this.loadingPromises = new Map();
    }

    preloadImage(src, key) {
        if (this.preloadedImages.has(key)) {
            return Promise.resolve(this.preloadedImages.get(key));
        }

        if (this.loadingPromises.has(key)) {
            return this.loadingPromises.get(key);
        }

        const promise = new Promise((resolve, reject) => {
            try {
                const img = new Image();

                const cleanup = () => {
                    img.onload = null;
                    img.onerror = null;
                    this.loadingPromises.delete(key);
                };

                img.onload = () => {
                    cleanup();
                    this.preloadedImages.set(key, img);
                    resolve(img);
                };

                img.onerror = (error) => {
                    cleanup();
                    console.error(`Failed to preload image ${key}:`, error);
                    reject(new Error(`Failed to load image: ${src}`));
                };

                // Set timeout for image loading
                setTimeout(() => {
                    if (!this.preloadedImages.has(key)) {
                        cleanup();
                        reject(new Error(`Image load timeout for: ${src}`));
                    }
                }, 10000);

                img.src = src;

            } catch (error) {
                this.loadingPromises.delete(key);
                reject(new Error(`Error creating image element: ${error.message}`));
            }
        });

        this.loadingPromises.set(key, promise);
        return promise;
    }

    getPreloadedImage(key) {
        return this.preloadedImages.get(key);
    }

    clearCache() {
        this.preloadedImages.clear();
        this.loadingPromises.clear();
    }
}

// Initialize image preloader
const imagePreloader = new ImagePreloader();

// Preload images with error handling
const initializeImagePreloading = async () => {
    try {
        const imageConfigs = [
            {
                key: 'loadingGif1',
                src: 'https://media.tenor.com/j91H7eyBWEcAAAAi/flying-saucer-joypixels.gif',
                fallback: null
            },
            {
                key: 'loadingGif2',
                src: 'https://cdn.dribbble.com/users/92954/screenshots/4006601/media/71bda56a3643a738bc2dfbf674033b90.gif',
                fallback: null
            }
        ];

        const preloadPromises = imageConfigs.map(async (config) => {
            try {
                await imagePreloader.preloadImage(config.src, config.key);
                console.log(`Successfully preloaded ${config.key}`);
            } catch (error) {
                console.warn(`Failed to preload ${config.key}, will load on demand:`, error.message);
                // Could implement fallback image loading here
            }
        });

        // Wait for all preloading attempts (success or failure)
        await Promise.allSettled(preloadPromises);

    } catch (error) {
        console.error('Error during image preloading initialization:', error);
    }
};

// Legacy support - maintain original variable names for backward compatibility
let preloadedGif, preloadedGif2;

const initializeLegacyImageSupport = async () => {
    try {
        await initializeImagePreloading();

        // Set legacy variables for backward compatibility
        preloadedGif = imagePreloader.getPreloadedImage('loadingGif1') || new Image();
        preloadedGif2 = imagePreloader.getPreloadedImage('loadingGif2') || new Image();

        // Fallback: set src directly if preloading failed
        if (!preloadedGif.complete) {
            preloadedGif.src = 'https://media.tenor.com/j91H7eyBWEcAAAAi/flying-saucer-joypixels.gif';
        }
        if (!preloadedGif2.complete) {
            preloadedGif2.src = 'https://cdn.dribbble.com/users/92954/screenshots/4006601/media/71bda56a3643a738bc2dfbf674033b90.gif';
        }

    } catch (error) {
        console.error('Error initializing legacy image support:', error);
        // Create fallback images
        preloadedGif = new Image();
        preloadedGif.src = 'https://media.tenor.com/j91H7eyBWEcAAAAi/flying-saucer-joypixels.gif';
        preloadedGif2 = new Image();
        preloadedGif2.src = 'https://cdn.dribbble.com/users/92954/screenshots/4006601/media/71bda56a3643a738bc2dfbf674033b90.gif';
    }
};

// Initialize on load
initializeLegacyImageSupport();

function showLoadingGif() {
    fullTableContainer.innerHTML = ''; // Clear any existing content

    // Create a container for the gif
    const gifContainer = document.createElement('div');
    gifContainer.style.width = '100%';
    gifContainer.style.overflow = 'hidden';
    gifContainer.style.position = 'relative';
    gifContainer.style.height = '300px'; // Adjust this based on your GIF's height

    // Create an image element for the loading gif
    const loadingGif = document.createElement('img');
    loadingGif.src = preloadedGif.src;
    loadingGif.style.position = 'absolute';
    loadingGif.style.height = '250px'; // Adjust this based on your preferred size
    loadingGif.style.left = '-200px'; // Start off-screen to the left

    gifContainer.appendChild(loadingGif);
    fullTableContainer.appendChild(gifContainer);

    // Start the animation
    animateGif(loadingGif);
}

function animateGif(gifElement) {
    try {
        if (!gifElement || !gifElement.parentElement) {
            console.error('Invalid gif element or missing parent container');
            return;
        }

        const container = gifElement.parentElement;
        const containerWidth = container.offsetWidth;
        const gifWidth = gifElement.offsetWidth;

        if (containerWidth === 0) {
            console.warn('Container width is 0, animation may not work properly');
        }

        let currentPosition = -gifWidth;
        let animationId;
        let isRunning = true;

        function move() {
            if (!isRunning || !gifElement.parentElement) {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                return;
            }

            currentPosition += 2; // Adjust this value to change speed
            gifElement.style.left = currentPosition + 'px';

            if (currentPosition > containerWidth) {
                // Reset position to start when gif leaves the screen
                currentPosition = -gifWidth;
            }

            animationId = requestAnimationFrame(move);
        }

        // Store stop function on element for cleanup
        gifElement._stopAnimation = () => {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        };

        move();
    } catch (error) {
        console.error('Error in animateGif:', error);
    }
}

function showLoadingGifForNextCPT() {
    try {
        if (!nextCPTTableContainer) {
            console.error('nextCPTTableContainer not found');
            return;
        }

        // Stop any existing animation
        const existingGif = nextCPTTableContainer.querySelector('img');
        if (existingGif && existingGif._stopAnimation) {
            existingGif._stopAnimation();
        }

        nextCPTTableContainer.innerHTML = ''; // Clear any existing content

        // Create a container for the gif
        const gifContainer = document.createElement('div');
        if (!gifContainer) {
            throw new Error('Failed to create gif container');
        }

        gifContainer.style.cssText = `
            width: 100%;
            overflow: hidden;
            position: relative;
            height: 200px;
        `;

        // Create an image element for the loading gif
        const loadingGif = document.createElement('img');
        if (!loadingGif) {
            throw new Error('Failed to create loading gif element');
        }

        // Use preloaded image or fallback
        loadingGif.src = preloadedGif2?.src || 'https://cdn.dribbble.com/users/92954/screenshots/4006601/media/71bda56a3643a738bc2dfbf674033b90.gif';
        loadingGif.style.cssText = `
            position: absolute;
            height: 240px;
            left: -200px;
        `;

        loadingGif.onerror = () => {
            console.error('Failed to load Next CPT loading gif');
            // Create fallback loading indicator
            const fallbackDiv = document.createElement('div');
            fallbackDiv.textContent = 'Loading...';
            fallbackDiv.style.cssText = `
                text-align: center;
                padding: 40px;
                color: #666;
                font-size: 18px;
            `;
            gifContainer.innerHTML = '';
            gifContainer.appendChild(fallbackDiv);
        };

        gifContainer.appendChild(loadingGif);
        nextCPTTableContainer.appendChild(gifContainer);

        // Start the animation
        loadingGif.onload = () => {
            try {
                animateNextCPTGif(loadingGif);
            } catch (animError) {
                console.error('Error starting Next CPT gif animation:', animError);
            }
        };

        // If image is already loaded (cached)
        if (loadingGif.complete) {
            loadingGif.onload();
        }

        // Update container position with error handling
        try {
            if (typeof updateNextCPTContainerPosition === 'function') {
                updateNextCPTContainerPosition();
            }
        } catch (positionError) {
            console.error('Error updating Next CPT container position:', positionError);
        }

    } catch (error) {
        console.error('Error in showLoadingGifForNextCPT:', error);

        // Fallback: show simple loading message
        if (nextCPTTableContainer) {
            nextCPTTableContainer.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #666; font-size: 18px;">
                    Loading Next CPT...
                </div>
            `;
        }
    }
}

function animateNextCPTGif(gifElement) {
    try {
        if (!gifElement || !gifElement.parentElement) {
            console.error('Invalid gif element or missing parent container');
            return;
        }

        const container = gifElement.parentElement;
        const containerWidth = container.offsetWidth;
        const gifWidth = gifElement.offsetWidth;

        if (containerWidth === 0) {
            console.warn('Container width is 0, animation may not work properly');
        }

        let currentPosition = -gifWidth;
        let animationId;
        let isRunning = true;

        function move() {
            if (!isRunning || !gifElement.parentElement) {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                return;
            }

            currentPosition += 3; // Adjust this value to change speed
            gifElement.style.left = currentPosition + 'px';

            if (currentPosition > containerWidth) {
                // Reset position to start when gif leaves the screen
                currentPosition = -gifWidth;
            }

            animationId = requestAnimationFrame(move);
        }

        // Store stop function on element for cleanup
        gifElement._stopAnimation = () => {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        };

        move();
    } catch (error) {
        console.error('Error in animateNextCPTGif:', error);
    }
}


function clearAllTables() {
    const containersToClean = ['tableContainer', 'fullTableContainer', 'nextCPTTableContainer'];
    containersToClean.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = '';
        }
    });
}


function updateInfoBox(boxElement, cpt, boxTitle) {
    try {
        // Validate inputs
        if (!boxElement) {
            console.error('updateInfoBox: boxElement is required');
            return false;
        }

        if (!cpt || typeof cpt !== 'string') {
            console.error('updateInfoBox: Valid cpt parameter is required');
            return false;
        }

        if (!boxTitle || typeof boxTitle !== 'string') {
            console.error('updateInfoBox: Valid boxTitle parameter is required');
            return false;
        }

        // Create header HTML with sanitized inputs
        const sanitizedCpt = cpt.replace(/[<>&"]/g, (char) => {
            const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
            return entities[char] || char;
        });

        const sanitizedTitle = boxTitle.replace(/[<>&"]/g, (char) => {
            const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
            return entities[char] || char;
        });

        const headerHTML = `
            <div style="
                background: linear-gradient(135deg, #2193b0, #6dd5ed);
                color: white;
                padding: 12px;
                border-radius: 8px 8px 0 0;
                margin: -20px -20px 15px -20px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <h3 style="
                    margin: 0;
                    font-size: 24px;
                    font-weight: 600;">${sanitizedTitle}:
                    <span style="font-weight: 500;">${sanitizedCpt}</span>
                </h3>
            </div>
        `;

        // Handle loading gif with fallback
        let loadingHTML;
        const hasValidGif = preloadedInfoBoxGif && preloadedInfoBoxGif.src && preloadedInfoBoxGif.complete;

        if (hasValidGif) {
            loadingHTML = `
                <div style="display: flex; justify-content: center; padding: 10px;">
                    <img src="${preloadedInfoBoxGif.src}" alt="Loading..." style="width:80px; height:auto;" id="loadingGif">
                </div>
            `;
        } else {
            console.warn('updateInfoBox: preloadedInfoBoxGif not available, using fallback');
            loadingHTML = `
                <div style="display: flex; justify-content: center; padding: 20px;">
                    <div style="
                        color: #666;
                        font-size: 18px;
                        display: flex;
                        align-items: center;
                        gap: 10px;">
                        <div style="
                            width: 20px;
                            height: 20px;
                            border: 3px solid #f3f3f3;
                            border-top: 3px solid #3498db;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                        "></div>
                        Loading...
                    </div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
        }

        // Set initial loading state
        boxElement.innerHTML = `${headerHTML}${loadingHTML}`;

        // Validate data fetching functions exist
        if (typeof getATROPSData !== 'function') {
            throw new Error('getATROPSData function is not available');
        }

        if (typeof getCORAData !== 'function') {
            throw new Error('getCORAData function is not available');
        }

        // Create timeout promise for data fetching
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Data fetch timeout')), 15000);
        });

        // Fetch data with timeout and error handling
        Promise.race([
            Promise.all([getATROPSData(cpt), getCORAData()]),
            timeoutPromise
        ])
            .then(([atropsData, coraData]) => {
                try {
                    // Remove loading indicator
                    const loadingElement = boxElement.querySelector('#loadingGif') || boxElement.querySelector('[style*="spin"]')?.parentElement;
                    if (loadingElement) {
                        loadingElement.remove();
                    }

                    // Validate received data
                    if (!atropsData && !coraData) {
                        throw new Error('No data received from either service');
                    }

                    if (!coraData || typeof coraData !== 'object' || !coraData[cpt]) {
                        console.warn(`CORA data not available for CPT: ${cpt}`);
                    }

                    if (!atropsData || typeof atropsData !== 'object') {
                        console.warn(`ATROPS data not available for CPT: ${cpt}`);
                    }

                    // Prepare data rows with safe value extraction
                    const getValue = (obj, prop, fallback = 'N/A') => {
                        try {
                            const value = obj && obj[prop];
                            return (value !== undefined && value !== null && value !== '') ? String(value) : fallback;
                        } catch (error) {
                            console.warn(`Error extracting ${prop}:`, error);
                            return fallback;
                        }
                    };

                    const dataRows = [
                        { label: 'Cap', value: getValue(atropsData, 'cap'), color: '#4CAF50' },
                        { label: 'Schedule', value: getValue(atropsData, 'schedule'), color: '#2196F3' },
                        { label: '% Schedule', value: getValue(atropsData, 'percentSchedule'), color: '#9C27B0' },
                        { label: 'Current Risk', value: getValue(coraData?.[cpt], 'currentRisk'), color: '#FF9800' },
                        { label: 'Current Backlog', value: getValue(coraData?.[cpt], 'currentBacklog'), color: '#E91E63' }
                    ];

                    // Generate data rows HTML with sanitization
                    const dataRowsHTML = dataRows.map(row => {
                        const sanitizedLabel = String(row.label).replace(/[<>&"]/g, (char) => {
                            const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
                            return entities[char] || char;
                        });

                        const sanitizedValue = String(row.value).replace(/[<>&"]/g, (char) => {
                            const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
                            return entities[char] || char;
                        });

                        return `
                            <div style="
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                                margin-bottom: 8px;
                                padding: 8px;
                                background: rgba(0,0,0,0.02);
                                transition: all 0.3s ease;
                                border-radius: 4px;">
                                <span style="
                                    color: ${row.color};
                                    font-weight: 600;
                                    font-size: 20px;
                                    margin-right: 15px;">${sanitizedLabel}:</span>
                                <span style="
                                    color: #333;
                                    font-weight: 500;
                                    font-size: 20px;">${sanitizedValue}</span>
                            </div>
                        `;
                    }).join('');

                    // Check if we have any meaningful data to display
                    const hasData = dataRows.some(row => row.value !== 'N/A');

                    if (!hasData) {
                        boxElement.innerHTML = `
                            ${headerHTML}
                            <div style="
                                color: #dc3545;
                                text-align: center;
                                font-size: 20px;
                                padding: 20px;
                                background: rgba(220, 53, 69, 0.1);
                                border-radius: 4px;
                                margin: 10px;">
                                No data available for CPT ${sanitizedCpt}
                            </div>`;
                        return;
                    }

                    // Update with successful data
                    boxElement.innerHTML = `
                        ${headerHTML}
                        <div style="padding: 0 5px;">
                            ${dataRowsHTML}
                        </div>
                    `;

                } catch (renderError) {
                    console.error('Error rendering data:', renderError);
                    boxElement.innerHTML = `
                        ${headerHTML}
                        <div style="
                            color: #dc3545;
                            text-align: center;
                            font-size: 20px;
                            padding: 20px;">
                            Error displaying data
                        </div>`;
                }
            })
            .catch(error => {
                console.error('Error fetching data for updateInfoBox:', error);

                // Determine error type for better user feedback
                let errorMessage = 'Error loading data';
                if (error.message.includes('timeout')) {
                    errorMessage = 'Request timed out. Please try again.';
                } else if (error.message.includes('not available')) {
                    errorMessage = 'Service temporarily unavailable';
                } else if (error.message.includes('Network')) {
                    errorMessage = 'Network error. Please check connection.';
                }

                boxElement.innerHTML = `
                    ${headerHTML}
                    <div style="
                        color: #dc3545;
                        text-align: center;
                        font-size: 20px;
                        padding: 20px;
                        background: rgba(220, 53, 69, 0.1);
                        border-radius: 4px;
                        margin: 10px;">
                        ${errorMessage}
                    </div>`;
            });

        return true;

    } catch (error) {
        console.error('Error in updateInfoBox:', error);

        // Fallback error display
        if (boxElement) {
            boxElement.innerHTML = `
                <div style="
                    color: #dc3545;
                    text-align: center;
                    font-size: 18px;
                    padding: 20px;
                    background: rgba(220, 53, 69, 0.1);
                    border-radius: 4px;">
                    Unable to load information
                </div>`;
        }

        return false;
    }
}

function getATROPSData1(cpt) {
    try {
        // Validate input parameter
        if (!cpt || typeof cpt !== 'string') {
            console.warn('getATROPSData1: Invalid or missing CPT parameter');
            return null;
        }

        // Normalize CPT for comparison
        const normalizedCpt = cpt.trim();
        if (!normalizedCpt) {
            console.warn('getATROPSData1: Empty CPT after trimming');
            return null;
        }

        // Find and validate ATROPS table
        const atropsTable = document.querySelector('.Atrops-table');
        if (!atropsTable) {
            console.warn('getATROPSData1: ATROPS table not found');
            return null;
        }

        if (!atropsTable.rows || atropsTable.rows.length === 0) {
            console.warn('getATROPSData1: ATROPS table has no rows');
            return null;
        }

        // Search through table rows
        for (let i = 0; i < atropsTable.rows.length; i++) {
            const row = atropsTable.rows[i];

            try {
                // Validate row structure
                if (!row || !row.cells || row.cells.length < 4) {
                    continue; // Skip malformed rows
                }

                // Check if first cell exists and get its content
                const firstCell = row.cells[0];
                if (!firstCell) {
                    continue;
                }

                const cellContent = firstCell.textContent || firstCell.innerText || '';
                const normalizedCellContent = cellContent.trim();

                // Match CPT (case-sensitive exact match)
                if (normalizedCellContent === normalizedCpt) {
                    // Extract data with safe cell access
                    const extractCellText = (cellIndex) => {
                        try {
                            const cell = row.cells[cellIndex];
                            if (!cell) return '';
                            return (cell.textContent || cell.innerText || '').trim();
                        } catch (error) {
                            console.warn(`getATROPSData1: Error extracting cell ${cellIndex}:`, error);
                            return '';
                        }
                    };

                    const result = {
                        cap: extractCellText(2),
                        schedule: extractCellText(3),
                        percentSchedule: extractCellText(1)
                    };

                    // Validate that we got meaningful data
                    const hasData = Object.values(result).some(value => value && value !== '');
                    if (!hasData) {
                        console.warn(`getATROPSData1: Found CPT ${cpt} but no data in cells`);
                        return null;
                    }

                    console.log(`getATROPSData1: Successfully found data for CPT ${cpt}`);
                    return result;
                }

            } catch (rowError) {
                console.warn(`getATROPSData1: Error processing row ${i}:`, rowError);
                continue; // Skip problematic row and continue
            }
        }

        // CPT not found
        console.log(`getATROPSData1: CPT ${cpt} not found in ATROPS table`);
        return null;

    } catch (error) {
        console.error('getATROPSData1: Unexpected error:', error);
        return null;
    }
}

function getCORAData1(retryCount = 3) {
    try {
        // Validate retry count parameter
        if (typeof retryCount !== 'number' || retryCount < 0) {
            console.warn('getCORAData1: Invalid retryCount, using default value 3');
            retryCount = 3;
        }

        // Find and validate CORA table
        const coraTable = document.querySelector('.CORA-table');
        if (!coraTable) {
            console.warn('getCORAData1: CORA table not found');
            return handleRetry(retryCount, 'Table not found');
        }

        if (!coraTable.rows || coraTable.rows.length === 0) {
            console.warn('getCORAData1: CORA table has no rows');
            return handleRetry(retryCount, 'Table has no rows');
        }

        if (coraTable.rows.length < 2) {
            console.warn('getCORAData1: CORA table has only header row');
            return handleRetry(retryCount, 'Table has insufficient data');
        }

        let coraData = {};
        let processedCount = 0;
        let skippedCount = 0;
        let duplicateCount = 0;

        // Start from row 1 to skip the header row
        for (let i = 1; i < coraTable.rows.length; i++) {
            try {
                const row = coraTable.rows[i];

                // Validate row structure
                if (!row || !row.cells || row.cells.length < 6) {
                    console.warn(`getCORAData1: Row ${i} has insufficient cells (${row?.cells?.length || 0}/6), skipping`);
                    skippedCount++;
                    continue;
                }

                // Extract and validate CPT
                const cptCell = row.cells[0];
                if (!cptCell) {
                    console.warn(`getCORAData1: Row ${i} has no CPT cell, skipping`);
                    skippedCount++;
                    continue;
                }

                const cpt = (cptCell.textContent || cptCell.innerText || '').trim();
                if (!cpt) {
                    console.warn(`getCORAData1: Row ${i} has empty CPT, skipping`);
                    skippedCount++;
                    continue;
                }

                // Check for duplicate CPT
                if (coraData.hasOwnProperty(cpt)) {
                    console.log(`getCORAData1: Skipping duplicate CPT ${cpt} at row ${i}`);
                    duplicateCount++;
                    continue;
                }

                // Safe cell content extraction
                const extractCellContent = (cellIndex, fallback = '') => {
                    try {
                        const cell = row.cells[cellIndex];
                        if (!cell) return fallback;
                        return (cell.textContent || cell.innerText || '').trim();
                    } catch (error) {
                        console.warn(`getCORAData1: Error extracting cell ${cellIndex} from row ${i}:`, error);
                        return fallback;
                    }
                };

                // Extract data from cells
                const rawColumnA = extractCellContent(1); // Current Backlog
                const rawColumnD = extractCellContent(2); // Max with planned Units
                const rawColumnE = extractCellContent(3); // Max with Predicted
                const rawColumnI = extractCellContent(4); // Current Risk
                const rawColumnJ = extractCellContent(5); // Predicted Risk

                // Clean and parse numeric data with enhanced validation
                const cleanNumericValue = (value, allowPercentage = false) => {
                    if (!value || typeof value !== 'string') return '';

                    // Keep percentage sign if allowed, otherwise remove all non-numeric except decimal and minus
                    const regex = allowPercentage ? /[^\d.%-]/g : /[^\d.-]/g;
                    return value.replace(regex, '');
                };

                const cleanedColumnA = cleanNumericValue(rawColumnA);
                const cleanedColumnE = cleanNumericValue(rawColumnE);
                const cleanedColumnJ = cleanNumericValue(rawColumnJ, true); // Allow percentage

                // Parse numeric values with error handling
                const parseIntSafe = (value, fallback = 0) => {
                    if (!value) return fallback;
                    const parsed = parseInt(value, 10);
                    return isNaN(parsed) ? fallback : parsed;
                };

                const parseFloatSafe = (value, fallback = 0) => {
                    if (!value) return fallback;
                    const parsed = parseFloat(value);
                    return isNaN(parsed) ? fallback : parsed;
                };

                // Build data object with validated values
                coraData[cpt] = {
                    currentBacklog: parseIntSafe(cleanedColumnA),
                    columnE: parseFloatSafe(cleanedColumnE),
                    currentRisk: rawColumnI || 'N/A', // Keep original format for display
                    // Additional metadata for debugging
                    _rowIndex: i,
                    _rawData: {
                        columnA: rawColumnA,
                        columnD: rawColumnD,
                        columnE: rawColumnE,
                        columnI: rawColumnI,
                        columnJ: rawColumnJ
                    }
                };

                processedCount++;

            } catch (rowError) {
                console.error(`getCORAData1: Error processing row ${i}:`, rowError);
                skippedCount++;
                continue;
            }
        }

        // Log processing summary
        console.log(`getCORAData1: Processing complete - Processed: ${processedCount}, Skipped: ${skippedCount}, Duplicates: ${duplicateCount}`);

        // Validate final result
        if (Object.keys(coraData).length === 0) {
            console.warn('getCORAData1: No valid data extracted from table');
            return handleRetry(retryCount, 'No valid data found');
        }

        return coraData;

        // Helper function for retry logic
        function handleRetry(remainingRetries, reason) {
            if (remainingRetries > 0) {
                console.log(`getCORAData1: ${reason}. Retrying... Attempts left: ${remainingRetries}`);
                return new Promise((resolve) => {
                    setTimeout(() => {
                        resolve(getCORAData1(remainingRetries - 1));
                    }, 1000);
                });
            } else {
                console.error(`getCORAData1: Failed after all retry attempts. Final reason: ${reason}`);
                return null;
            }
        }

    } catch (error) {
        console.error('getCORAData1: Unexpected error:', error);

        // Only retry if we have attempts left and it's not a fundamental error
        if (retryCount > 0 && !error.message.includes('Invalid retryCount')) {
            console.log(`getCORAData1: Retrying due to error. Attempts left: ${retryCount}`);
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(getCORAData1(retryCount - 1));
                }, 1000);
            });
        }

        return null;
    }
}



function adjustInitialPositioning() {
    try {
        // Find and validate header element
        const header = document.getElementById('siteHeader');
        if (!header) {
            console.warn('adjustInitialPositioning: Site header not found, skipping positioning adjustments');
            return false;
        }

        // Get header height with validation
        let headerHeight = 0;
        try {
            headerHeight = header.offsetHeight;

            // Fallback to computed style if offsetHeight is unreliable
            if (headerHeight === 0) {
                const computedStyle = window.getComputedStyle(header);
                const height = computedStyle.height;
                if (height && height !== 'auto') {
                    headerHeight = parseInt(height, 10) || 0;
                }
            }
        } catch (heightError) {
            console.error('adjustInitialPositioning: Error getting header height:', heightError);
            return false;
        }

        if (headerHeight === 0) {
            console.warn('adjustInitialPositioning: Site header has zero height, positioning adjustment may be incorrect');
            // Continue anyway - header might become visible later
        }

        // Find fixed position elements with improved selector
        let fixedElements;
        try {
            // Try multiple approaches to find fixed elements
            const styleAttrFixed = document.querySelectorAll('[style*="position: fixed"]');
            const computedFixed = Array.from(document.querySelectorAll('*')).filter(el => {
                try {
                    return window.getComputedStyle(el).position === 'fixed';
                } catch {
                    return false;
                }
            });

            // Combine both approaches and remove duplicates
            const allFixed = [...styleAttrFixed, ...computedFixed];
            fixedElements = Array.from(new Set(allFixed));

        } catch (selectorError) {
            console.error('adjustInitialPositioning: Error finding fixed elements:', selectorError);
            return false;
        }

        if (fixedElements.length === 0) {
            console.log('adjustInitialPositioning: No fixed position elements found');
            return true;
        }

        let adjustedCount = 0;
        let skippedCount = 0;
        let errorCount = 0;

        // Process each fixed element
        fixedElements.forEach((el, index) => {
            try {
                // Skip the header itself and elements without proper structure
                if (!el || el.id === 'siteHeader') {
                    skippedCount++;
                    return;
                }

                // Get current top position safely
                let currentTop = 0;
                try {
                    const computedStyle = window.getComputedStyle(el);
                    const computedTop = computedStyle.top;
                    const styleTop = el.style.top;

                    // Try different methods to get current top value
                    if (computedTop && computedTop !== 'auto') {
                        currentTop = parseInt(computedTop, 10) || 0;
                    } else if (styleTop) {
                        currentTop = parseInt(styleTop, 10) || 0;
                    }

                } catch (topError) {
                    console.warn(`adjustInitialPositioning: Error getting top value for element ${index}:`, topError);
                    currentTop = 0; // Use default
                }

                // Check if element needs adjustment
                const needsAdjustment = currentTop < headerHeight;
                const isAlreadyAdjusted = Math.abs(currentTop - headerHeight) < 5; // 5px tolerance

                if (needsAdjustment && !isAlreadyAdjusted) {
                    // Calculate new position
                    const newTop = currentTop + headerHeight;

                    // Validate new position is reasonable
                    if (newTop >= 0 && newTop < window.innerHeight * 2) {
                        el.style.top = newTop + 'px';
                        adjustedCount++;

                        console.log(`adjustInitialPositioning: Adjusted element ${el.id || el.className || 'unnamed'} from ${currentTop}px to ${newTop}px`);
                    } else {
                        console.warn(`adjustInitialPositioning: Calculated position ${newTop}px seems unreasonable for element`, el);
                        skippedCount++;
                    }
                } else {
                    skippedCount++;
                }

            } catch (elementError) {
                console.error(`adjustInitialPositioning: Error processing element ${index}:`, elementError);
                errorCount++;
            }
        });

        // Log summary
        console.log(`adjustInitialPositioning: Complete - Adjusted: ${adjustedCount}, Skipped: ${skippedCount}, Errors: ${errorCount}`);

        return adjustedCount > 0 || errorCount === 0;

    } catch (error) {
        console.error('adjustInitialPositioning: Unexpected error:', error);
        return false;
    }
}

// Enhanced version that can be called with options
function adjustInitialPositioningAdvanced(options = {}) {
    const {
        headerSelector = '#siteHeader',
        excludeSelectors = [],
        tolerance = 5,
        maxReasonableTop = null,
        dryRun = false
    } = options;

    try {
        const header = document.querySelector(headerSelector);
        if (!header) {
            console.warn(`adjustInitialPositioningAdvanced: Header not found with selector: ${headerSelector}`);
            return false;
        }

        const headerHeight = header.offsetHeight;
        const maxTop = maxReasonableTop || (window.innerHeight * 2);

        const fixedElements = Array.from(document.querySelectorAll('*')).filter(el => {
            try {
                if (!el || el === header) return false;

                // Check if element should be excluded
                if (excludeSelectors.some(selector => el.matches && el.matches(selector))) {
                    return false;
                }

                return window.getComputedStyle(el).position === 'fixed';
            } catch {
                return false;
            }
        });

        let adjustments = [];

        fixedElements.forEach(el => {
            try {
                const computedStyle = window.getComputedStyle(el);
                const currentTop = parseInt(computedStyle.top, 10) || 0;

                if (currentTop < headerHeight && Math.abs(currentTop - headerHeight) >= tolerance) {
                    const newTop = currentTop + headerHeight;

                    if (newTop >= 0 && newTop <= maxTop) {
                        adjustments.push({
                            element: el,
                            oldTop: currentTop,
                            newTop: newTop,
                            identifier: el.id || el.className || el.tagName
                        });

                        if (!dryRun) {
                            el.style.top = newTop + 'px';
                        }
                    }
                }
            } catch (error) {
                console.warn('Error processing element:', error);
            }
        });

        if (dryRun) {
            console.log('Dry run - would adjust:', adjustments);
        }

        return adjustments.length;

    } catch (error) {
        console.error('adjustInitialPositioningAdvanced error:', error);
        return false;
    }
}

function updateCPTInfoBoxes() {
    try {
        // Validate CPT select element
        const cptSelect = document.getElementById('cptSelect');
        if (!cptSelect) {
            console.error('updateCPTInfoBoxes: CPT select element not found');
            return false;
        }

        // Validate selected CPT
        const selectedCPT = cptSelect.value;
        if (!selectedCPT || typeof selectedCPT !== 'string') {
            console.warn('updateCPTInfoBoxes: No valid CPT selected');
            return false;
        }

        const trimmedCPT = selectedCPT.trim();
        if (!trimmedCPT) {
            console.warn('updateCPTInfoBoxes: Selected CPT is empty after trimming');
            return false;
        }

        // Get next CPT with error handling
        let nextCPT;
        try {
            if (typeof getNextCPT !== 'function') {
                throw new Error('getNextCPT function not available');
            }
            nextCPT = getNextCPT(trimmedCPT);

            if (!nextCPT || typeof nextCPT !== 'string') {
                console.warn('updateCPTInfoBoxes: Could not determine next CPT');
                nextCPT = 'Unknown';
            }
        } catch (nextCPTError) {
            console.error('updateCPTInfoBoxes: Error getting next CPT:', nextCPTError);
            nextCPT = 'Error';
        }

        // Validate required info box elements
        const missingElements = [];
        if (typeof currentCPTInfoBox === 'undefined' || !currentCPTInfoBox) {
            missingElements.push('currentCPTInfoBox');
        }
        if (typeof nextCPTInfoBox === 'undefined' || !nextCPTInfoBox) {
            missingElements.push('nextCPTInfoBox');
        }

        if (missingElements.length > 0) {
            console.error(`updateCPTInfoBoxes: Required elements not found: ${missingElements.join(', ')}`);
            return false;
        }

        // Create loading content with fallback
        const createLoadingContent = (cptType, cptValue) => {
            // Sanitize CPT values for HTML
            const sanitizedCPTType = String(cptType).replace(/[<>&"]/g, (char) => {
                const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
                return entities[char] || char;
            });

            const sanitizedCPTValue = String(cptValue).replace(/[<>&"]/g, (char) => {
                const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' };
                return entities[char] || char;
            });

            const headerHTML = `
                <div style="
                    background: linear-gradient(135deg, #2193b0, #6dd5ed);
                    color: white;
                    padding: 12px;
                    border-radius: 8px 8px 0 0;
                    margin: -20px -20px 15px -20px;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h3 style="
                        margin: 0;
                        font-size: 24px;
                        font-weight: 600;">${sanitizedCPTType}: ${sanitizedCPTValue}
                    </h3>
                </div>
            `;

            // Check if preloaded gif is available
            const hasValidGif = preloadedInfoBoxGif && preloadedInfoBoxGif.src && preloadedInfoBoxGif.complete;

            let loadingHTML;
            if (hasValidGif) {
                loadingHTML = `
                    <div style="display: flex; justify-content: center; padding: 10px;">
                        <img src="${preloadedInfoBoxGif.src}" alt="Loading..." style="width:100px; height:auto;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div style="display: none; text-align: center; padding: 20px; color: #666; font-size: 16px;">
                            Loading ${sanitizedCPTValue}...
                        </div>
                    </div>
                `;
            } else {
                loadingHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; padding: 20px;">
                        <div style="
                            width: 20px;
                            height: 20px;
                            border: 3px solid #f3f3f3;
                            border-top: 3px solid #3498db;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                            margin-right: 10px;
                        "></div>
                        <span style="color: #666; font-size: 16px;">Loading ${sanitizedCPTValue}...</span>
                    </div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `;
            }

            return headerHTML + loadingHTML;
        };

        // Show loading content immediately with error handling
        try {
            currentCPTInfoBox.innerHTML = createLoadingContent('Current CPT', trimmedCPT);
        } catch (currentError) {
            console.error('updateCPTInfoBoxes: Error setting current CPT loading content:', currentError);
            currentCPTInfoBox.innerHTML = `<div style="color: #dc3545; padding: 20px;">Error loading current CPT</div>`;
        }

        try {
            nextCPTInfoBox.innerHTML = createLoadingContent('Next CPT', nextCPT);
        } catch (nextError) {
            console.error('updateCPTInfoBoxes: Error setting next CPT loading content:', nextError);
            nextCPTInfoBox.innerHTML = `<div style="color: #dc3545; padding: 20px;">Error loading next CPT</div>`;
        }

        // Update info boxes after delay with timeout handling
        const updateTimeout = setTimeout(() => {
            try {
                // Update current CPT info box
                if (typeof updateInfoBox === 'function') {
                    updateInfoBox(currentCPTInfoBox, trimmedCPT, 'Current CPT');
                } else {
                    console.error('updateCPTInfoBoxes: updateInfoBox function not available');
                    currentCPTInfoBox.innerHTML = `<div style="color: #dc3545; padding: 20px;">Update function not available</div>`;
                }

                // Update next CPT info box
                if (nextCPT !== 'Error' && nextCPT !== 'Unknown') {
                    if (typeof updateInfoBox === 'function') {
                        updateInfoBox(nextCPTInfoBox, nextCPT, 'Next CPT');
                    } else {
                        nextCPTInfoBox.innerHTML = `<div style="color: #dc3545; padding: 20px;">Update function not available</div>`;
                    }
                } else {
                    nextCPTInfoBox.innerHTML = `
                        <div style="
                            background: linear-gradient(135deg, #2193b0, #6dd5ed);
                            color: white;
                            padding: 12px;
                            border-radius: 8px 8px 0 0;
                            margin: -20px -20px 15px -20px;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <h3 style="margin: 0; font-size: 24px; font-weight: 600;">Next CPT: ${nextCPT}</h3>
                        </div>
                        <div style="color: #ffc107; text-align: center; padding: 20px;">
                            ${nextCPT === 'Error' ? 'Could not determine next CPT' : 'Next CPT information unavailable'}
                        </div>
                    `;
                }
            } catch (updateError) {
                console.error('updateCPTInfoBoxes: Error in delayed update:', updateError);
            }
        }, 1000);

        // Store timeout ID for potential cleanup
        updateCPTInfoBoxes._lastTimeout = updateTimeout;

        // Update math tables with error handling
        try {
            if (typeof createAndUpdateMathTable === 'function') {
                createAndUpdateMathTable();
            } else {
                console.warn('updateCPTInfoBoxes: createAndUpdateMathTable function not available');
            }
        } catch (mathTableError) {
            console.error('updateCPTInfoBoxes: Error updating math table:', mathTableError);
        }

        try {
            if (typeof createAndUpdateNextCPTMathTable === 'function') {
                createAndUpdateNextCPTMathTable();
            } else {
                console.warn('updateCPTInfoBoxes: createAndUpdateNextCPTMathTable function not available');
            }
        } catch (nextMathTableError) {
            console.error('updateCPTInfoBoxes: Error updating next CPT math table:', nextMathTableError);
        }

        console.log(`updateCPTInfoBoxes: Successfully initiated update for CPT ${trimmedCPT} -> ${nextCPT}`);
        return true;

    } catch (error) {
        console.error('updateCPTInfoBoxes: Unexpected error:', error);

        // Attempt to show error state in info boxes if they exist
        try {
            if (typeof currentCPTInfoBox !== 'undefined' && currentCPTInfoBox) {
                currentCPTInfoBox.innerHTML = `<div style="color: #dc3545; padding: 20px; text-align: center;">Error loading CPT information</div>`;
            }
            if (typeof nextCPTInfoBox !== 'undefined' && nextCPTInfoBox) {
                nextCPTInfoBox.innerHTML = `<div style="color: #dc3545; padding: 20px; text-align: center;">Error loading CPT information</div>`;
            }
        } catch (errorDisplayError) {
            console.error('updateCPTInfoBoxes: Could not display error state:', errorDisplayError);
        }

        return false;
    }
}

// Cleanup function to cancel pending updates if needed
updateCPTInfoBoxes.cleanup = function() {
    if (updateCPTInfoBoxes._lastTimeout) {
        clearTimeout(updateCPTInfoBoxes._lastTimeout);
        updateCPTInfoBoxes._lastTimeout = null;
        console.log('updateCPTInfoBoxes: Cancelled pending update');
    }
};

function addCustomRow(table, rowName, windows, defaultValue, isToggleable, defaultRate, background = '#ffffff') {
    try {
        // Enhanced input validation
        if (!table) {
            console.error('addCustomRow: Table parameter is required');
            return null;
        }

        if (!rowName || typeof rowName !== 'string' || !rowName.trim()) {
            console.error('addCustomRow: Valid rowName parameter is required');
            return null;
        }

        if (!Array.isArray(windows)) {
            console.error('addCustomRow: windows parameter must be an array');
            return null;
        }

        if (windows.length === 0) {
            console.warn('addCustomRow: windows array is empty');
            return null;
        }

        // Validate and sanitize parameters
        const sanitizedRowName = rowName.trim();
        const sanitizedBackground = background || '#ffffff';
        const safeDefaultValue = (defaultValue !== undefined && defaultValue !== null) ? defaultValue : '';
        const safeDefaultRate = (defaultRate !== undefined && defaultRate !== null) ? defaultRate : 0;

        // Create main row with error handling
        let row;
        try {
            row = table.insertRow();
            if (!row) {
                throw new Error('Failed to create table row');
            }
        } catch (rowError) {
            console.error('addCustomRow: Error creating table row:', rowError);
            return null;
        }

        row.style.cssText = `
            background-color: ${sanitizedBackground};
            transition: all 0.2s ease;
        `;

        // Create name cell
        let nameCell;
        try {
            nameCell = row.insertCell();
            if (!nameCell) {
                throw new Error('Failed to create name cell');
            }

            nameCell.textContent = sanitizedRowName;
            nameCell.style.cssText = `
                font-weight: 600;
                padding: 8px;
                color: #1e293b;
                font-size: 22px;
                border-bottom: 1px solid #e2e8f0;
                background-color: ${sanitizedBackground};
            `;
        } catch (nameCellError) {
            console.error('addCustomRow: Error creating name cell:', nameCellError);
            return null;
        }

        // Create data cells with enhanced error handling
        const dataCells = [];
        windows.forEach((window, index) => {
            try {
                const cell = row.insertCell();
                if (!cell) {
                    console.warn(`addCustomRow: Failed to create cell at index ${index}`);
                    return;
                }

                cell.textContent = safeDefaultValue;
                cell.contentEditable = true;
                cell.style.cssText = `
                    padding: 8px;
                    text-align: center;
                    border-bottom: 1px solid #e2e8f0;
                    font-size: 22px;
                    color: #1e293b;
                    transition: all 0.2s ease;
                    background-color: ${sanitizedBackground};
                `;

                // Store reference for cleanup
                dataCells.push(cell);

                // Add event listeners with error handling
                addCellEventListeners(cell, sanitizedBackground, sanitizedRowName, safeDefaultValue, table);

            } catch (cellError) {
                console.error(`addCustomRow: Error creating cell ${index}:`, cellError);
            }
        });

        // Create rate row if applicable
        let rateRow = null;
        if (sanitizedRowName !== 'Outbound Problem Solve') {
            try {
                rateRow = createRateRow(table, windows, safeDefaultRate, sanitizedBackground, sanitizedRowName);
            } catch (rateError) {
                console.error('addCustomRow: Error creating rate row:', rateError);
            }
        }

        // Add toggle functionality if requested
        if (isToggleable) {
            try {
                addToggleFunctionality(nameCell, rateRow, sanitizedRowName);
            } catch (toggleError) {
                console.error('addCustomRow: Error adding toggle functionality:', toggleError);
            }
        }

        // Update container position with error handling
        try {
            if (typeof updateNextCPTContainerPosition === 'function') {
                updateNextCPTContainerPosition();
            }
        } catch (positionError) {
            console.error('addCustomRow: Error updating container position:', positionError);
        }

        // Return row reference and cleanup function
        const result = {
            row: row,
            rateRow: rateRow,
            dataCells: dataCells,
            cleanup: () => {
                try {
                    // Remove event listeners and clean up
                    dataCells.forEach(cell => {
                        if (cell && cell._eventListeners) {
                            Object.entries(cell._eventListeners).forEach(([event, handler]) => {
                                cell.removeEventListener(event, handler);
                            });
                        }
                    });
                } catch (cleanupError) {
                    console.error('addCustomRow: Error during cleanup:', cleanupError);
                }
            }
        };

        console.log(`addCustomRow: Successfully created row for ${sanitizedRowName}`);
        return result;

    } catch (error) {
        console.error('addCustomRow: Unexpected error:', error);
        return null;
    }
}

// Helper function for adding cell event listeners
function addCellEventListeners(cell, background, rowName, defaultValue, table) {
    try {
        const eventListeners = {};

        // Hover effects
        const mouseoverHandler = () => {
            if (cell.contentEditable === 'true') {
                cell.style.backgroundColor = '#ffffff';
                cell.style.cursor = 'pointer';
            }
        };

        const mouseoutHandler = () => {
            cell.style.backgroundColor = background;
        };

        // Input validation handler
        const inputHandler = function() {
            try {
                const newValue = this.textContent.trim();

                if (defaultValue === 'X') {
                    if (newValue !== 'X' && isNaN(parseInt(newValue))) {
                        this.textContent = 'X';
                    }
                } else {
                    const numValue = parseInt(newValue);
                    if (isNaN(numValue) || numValue < 0) {
                        this.textContent = defaultValue;
                    } else {
                        this.textContent = numValue;
                    }
                }

                // Call update functions if available
                if (typeof updateOutboundTotals === 'function') {
                    updateOutboundTotals(table);
                }

                if (table.id === 'nextCPTProductionGraphicTable' && typeof handleNextCPTHCChange === 'function') {
                    handleNextCPTHCChange({ target: this });
                }
            } catch (inputError) {
                console.error('addCustomRow: Error in input handler:', inputError);
            }
        };

        // Add event listeners
        cell.addEventListener('mouseover', mouseoverHandler);
        cell.addEventListener('mouseout', mouseoutHandler);
        cell.addEventListener('input', inputHandler);

        // Store listeners for cleanup
        eventListeners.mouseover = mouseoverHandler;
        eventListeners.mouseout = mouseoutHandler;
        eventListeners.input = inputHandler;

        // Special handling for Pick2Rebin rows
        if (rowName === 'Pick2Rebin Pick' || rowName === 'Pick2Rebin Pack') {
            cell.style.cursor = 'pointer';
            cell.style.fontWeight = '600';

            if (typeof handleCellClick === 'function') {
                const clickHandler = handleCellClick;
                cell.addEventListener('click', clickHandler);
                eventListeners.click = clickHandler;
            }
        }

        // Store event listeners on the cell for cleanup
        cell._eventListeners = eventListeners;

    } catch (error) {
        console.error('addCellEventListeners: Error adding event listeners:', error);
    }
}

// Helper function for creating rate row
function createRateRow(table, windows, defaultRate, background, rowName) {
    try {
        const rateRow = table.insertRow();
        if (!rateRow) {
            throw new Error('Failed to create rate row');
        }

        // Create rate name cell
        const rateNameCell = rateRow.insertCell();
        if (!rateNameCell) {
            throw new Error('Failed to create rate name cell');
        }

        rateNameCell.textContent = 'Expected Rate';
        rateNameCell.style.cssText = `
            padding: 8px 8px 8px 24px;
            color: #1e293b;
            font-size: 16px;
            border-bottom: 1px solid #e2e8f0;
            background-color: ${background};
        `;

        // Create rate cells
        windows.forEach((window, index) => {
            try {
                const rateCell = rateRow.insertCell();
                if (!rateCell) {
                    console.warn(`createRateRow: Failed to create rate cell at index ${index}`);
                    return;
                }

                rateCell.textContent = defaultRate;
                rateCell.contentEditable = true;
                rateCell.style.cssText = `
                    padding: 8px;
                    text-align: center;
                    border-bottom: 1px solid #e2e8f0;
                    color: #1e293b;
                    font-size: 16px;
                    background-color: ${background};
                    transition: all 0.2s ease;
                `;

                // Add rate cell event listeners
                addRateCellEventListeners(rateCell, background, rowName, defaultRate, table);

            } catch (rateCellError) {
                console.error(`createRateRow: Error creating rate cell ${index}:`, rateCellError);
            }
        });

        return rateRow;

    } catch (error) {
        console.error('createRateRow: Error creating rate row:', error);
        return null;
    }
}

// Helper function for rate cell event listeners
function addRateCellEventListeners(rateCell, background, rowName, defaultRate, table) {
    try {
        const eventListeners = {};

        // Hover effects
        const mouseoverHandler = () => {
            if (rateCell.contentEditable === 'true') {
                rateCell.style.backgroundColor = '#ffffff';
                rateCell.style.cursor = 'pointer';
            }
        };

        const mouseoutHandler = () => {
            rateCell.style.backgroundColor = background;
        };

        // Input validation for rate cells
        const inputHandler = function() {
            try {
                const newRate = parseFloat(this.textContent);
                if (isNaN(newRate) || newRate < 0) {
                    this.textContent = defaultRate;
                } else {
                    this.textContent = newRate;
                }

                // Call update functions
                if (typeof updateOutboundTotals === 'function') {
                    updateOutboundTotals(table);
                }
                if (typeof updateRecommendations === 'function') {
                    updateRecommendations(table);
                }
                if (typeof handleRateChange === 'function') {
                    handleRateChange({ target: this });
                }
            } catch (inputError) {
                console.error('addRateCellEventListeners: Error in input handler:', inputError);
            }
        };

        // Add event listeners
        rateCell.addEventListener('mouseover', mouseoverHandler);
        rateCell.addEventListener('mouseout', mouseoutHandler);
        rateCell.addEventListener('input', inputHandler);

        eventListeners.mouseover = mouseoverHandler;
        eventListeners.mouseout = mouseoutHandler;
        eventListeners.input = inputHandler;

        // Special click handling for specific rows
        if (['Pick2Rebin Pick', 'Pick2Rebin Pack', 'VNA Pick', 'VNA Pack'].includes(rowName)) {
            rateCell.style.cursor = 'pointer';
            if (typeof handleCellClick === 'function') {
                const clickHandler = handleCellClick;
                rateCell.addEventListener('click', clickHandler);
                eventListeners.click = clickHandler;
            }
        }

        // Store listeners for cleanup
        rateCell._eventListeners = eventListeners;

    } catch (error) {
        console.error('addRateCellEventListeners: Error adding rate cell event listeners:', error);
    }
}

// Helper function for toggle functionality
function addToggleFunctionality(nameCell, rateRow, rowName) {
    try {
        if (!rateRow) {
            console.warn('addToggleFunctionality: No rate row to toggle');
            return;
        }

        const toggleButton = document.createElement('button');
        if (!toggleButton) {
            throw new Error('Failed to create toggle button');
        }

        toggleButton.textContent = '‚ñº';
        toggleButton.style.cssText = `
            margin-right: 8px;
            border: none;
            background: none;
            cursor: pointer;
            color: #1e293b;
            font-size: 14px;
            transition: transform 0.2s ease;
        `;

        nameCell.insertBefore(toggleButton, nameCell.firstChild);

        // Set initial state
        const initiallyExpanded = (rowName === 'Pick2Rebin Pick' || rowName === 'Pick2Rebin Pack');
        rateRow.style.display = initiallyExpanded ? '' : 'none';

        if (!initiallyExpanded) {
            toggleButton.style.transform = 'rotate(-90deg)';
            toggleButton.textContent = '‚ñ∂';
        }

        // Add click handler
        const clickHandler = () => {
            try {
                const isExpanded = rateRow.style.display !== 'none';
                rateRow.style.display = isExpanded ? 'none' : 'table-row';
                toggleButton.style.transform = isExpanded ? 'rotate(-90deg)' : 'rotate(0deg)';
                toggleButton.textContent = isExpanded ? '‚ñ∂' : '‚ñº';

                if (typeof updateNextCPTContainerPosition === 'function') {
                    setTimeout(updateNextCPTContainerPosition, 50);
                }
            } catch (toggleError) {
                console.error('addToggleFunctionality: Error in toggle handler:', toggleError);
            }
        };

        toggleButton.addEventListener('click', clickHandler);

        // Store handler for cleanup
        toggleButton._clickHandler = clickHandler;

    } catch (error) {
        console.error('addToggleFunctionality: Error adding toggle functionality:', error);
    }
}


function addToggleableRateRow(table, windows, defaultRate, isToggleable) {
    try {
        // Enhanced input validation
        if (!table) {
            console.error('addToggleableRateRow: Table parameter is required');
            return null;
        }

        if (!Array.isArray(windows)) {
            console.error('addToggleableRateRow: windows parameter must be an array');
            return null;
        }

        if (windows.length === 0) {
            console.warn('addToggleableRateRow: windows array is empty');
            return null;
        }

        if (defaultRate === undefined || defaultRate === null) {
            console.error('addToggleableRateRow: defaultRate parameter is required');
            return null;
        }

        // Validate table structure
        if (!table.rows || table.rows.length < 1) {
            console.error('addToggleableRateRow: Table must have at least one existing row');
            return null;
        }

        // Create rate row with error handling
        let rateRow;
        try {
            rateRow = table.insertRow();
            if (!rateRow) {
                throw new Error('Failed to create rate row');
            }
        } catch (rowError) {
            console.error('addToggleableRateRow: Error creating rate row:', rowError);
            return null;
        }

        // Get and validate parent row
        const parentRowIndex = table.rows.length - 2;
        if (parentRowIndex < 0) {
            console.error('addToggleableRateRow: No parent row available');
            try {
                rateRow.remove();
            } catch (removeError) {
                console.warn('Error removing invalid rate row:', removeError);
            }
            return null;
        }

        const parentRow = table.rows[parentRowIndex];
        if (!parentRow || !parentRow.cells || !parentRow.cells[0]) {
            console.error('addToggleableRateRow: Invalid parent row structure');
            try {
                rateRow.remove();
            } catch (removeError) {
                console.warn('Error removing invalid rate row:', removeError);
            }
            return null;
        }

        // Extract and validate row name
        let rowName;
        try {
            const nameCell = parentRow.cells[0];
            const textContent = nameCell.textContent || nameCell.innerText || '';
            rowName = textContent.trim();

            if (!rowName) {
                console.warn('addToggleableRateRow: Parent row has no name');
                rowName = 'Unknown';
            }
        } catch (nameError) {
            console.error('addToggleableRateRow: Error extracting row name:', nameError);
            rowName = 'Unknown';
        }

        // Determine if this is a Pick or Pack row
        const isPickOrPack = rowName === 'Pick2Rebin Pick' || rowName === 'Pick2Rebin Pack';

        // Set initial display state
        rateRow.style.display = isPickOrPack ? 'table-row' : 'none';

        // Create rate name cell
        let nameCell;
        try {
            nameCell = rateRow.insertCell();
            if (!nameCell) {
                throw new Error('Failed to create rate name cell');
            }

            nameCell.textContent = 'Expected Rate';
            nameCell.style.cssText = `
                padding: 8px 8px 8px 24px;
                color: #1e293b;
                font-size: 16px;
                border-bottom: 1px solid #e2e8f0;
                background-color: inherit;
            `;
        } catch (nameCellError) {
            console.error('addToggleableRateRow: Error creating rate name cell:', nameCellError);
            return null;
        }

        // Create rate cells with enhanced error handling
        const rateCells = [];
        const eventListeners = [];

        windows.forEach((window, index) => {
            try {
                const rateCell = rateRow.insertCell();
                if (!rateCell) {
                    console.warn(`addToggleableRateRow: Failed to create rate cell at index ${index}`);
                    return;
                }

                rateCell.textContent = defaultRate;
                rateCell.contentEditable = true;
                rateCell.style.cssText = `
                    padding: 8px;
                    text-align: center;
                    border-bottom: 1px solid #e2e8f0;
                    color: #1e293b;
                    font-size: 16px;
                    background-color: inherit;
                    transition: all 0.2s ease;
                `;

                rateCells.push(rateCell);

                // Add event listeners based on row type
                const cellEventListeners = addRateCellEventListeners(
                    rateCell,
                    isPickOrPack,
                    defaultRate,
                    table
                );

                eventListeners.push(...cellEventListeners);

            } catch (cellError) {
                console.error(`addToggleableRateRow: Error creating rate cell ${index}:`, cellError);
            }
        });

        // Add toggle functionality if requested
        let toggleButton = null;
        if (isToggleable) {
            try {
                toggleButton = addToggleButton(parentRow, rateRow, isPickOrPack);
            } catch (toggleError) {
                console.error('addToggleableRateRow: Error adding toggle functionality:', toggleError);
            }
        }

        // Return row reference and cleanup function
        const result = {
            rateRow: rateRow,
            parentRow: parentRow,
            rateCells: rateCells,
            toggleButton: toggleButton,
            cleanup: () => {
                try {
                    // Remove event listeners
                    eventListeners.forEach(({ element, event, handler }) => {
                        if (element && element.removeEventListener) {
                            element.removeEventListener(event, handler);
                        }
                    });

                    // Remove toggle button if it exists
                    if (toggleButton && toggleButton.parentNode) {
                        toggleButton.parentNode.removeChild(toggleButton);
                    }

                    console.log('addToggleableRateRow: Cleanup completed');
                } catch (cleanupError) {
                    console.error('addToggleableRateRow: Error during cleanup:', cleanupError);
                }
            }
        };

        console.log(`addToggleableRateRow: Successfully created rate row for ${rowName}`);
        return result;

    } catch (error) {
        console.error('addToggleableRateRow: Unexpected error:', error);
        return null;
    }
}

// Helper function for rate cell event listeners
function addRateCellEventListeners(rateCell, isPickOrPack, defaultRate, table) {
    const eventListeners = [];

    try {
        // Add hover effects
        const mouseoverHandler = () => {
            if (rateCell.contentEditable === 'true') {
                rateCell.style.backgroundColor = '#f8fafc';
                rateCell.style.cursor = 'pointer';
            }
        };

        const mouseoutHandler = () => {
            rateCell.style.backgroundColor = 'inherit';
        };

        rateCell.addEventListener('mouseover', mouseoverHandler);
        rateCell.addEventListener('mouseout', mouseoutHandler);

        eventListeners.push(
            { element: rateCell, event: 'mouseover', handler: mouseoverHandler },
            { element: rateCell, event: 'mouseout', handler: mouseoutHandler }
        );

        if (isPickOrPack) {
            // Special handling for Pick/Pack cells
            rateCell.style.cursor = 'pointer';
            rateCell.style.fontWeight = '600';

            if (typeof handleCellClick === 'function') {
                const clickHandler = handleCellClick;
                rateCell.addEventListener('click', clickHandler);
                eventListeners.push({ element: rateCell, event: 'click', handler: clickHandler });
            }
        } else {
            // Input validation for non-Pick/Pack cells
            const inputHandler = function() {
                try {
                    const rawValue = this.textContent.trim();
                    const newRate = parseFloat(rawValue);

                    if (isNaN(newRate) || newRate < 0) {
                        this.textContent = defaultRate;
                    } else {
                        this.textContent = newRate;
                    }

                    // Call update functions if available
                    if (typeof updateOutboundTotals === 'function') {
                        updateOutboundTotals(table);
                    }
                    if (typeof updateRecommendations === 'function') {
                        updateRecommendations(table);
                    }
                    if (typeof handleRateChange === 'function') {
                        handleRateChange({ target: this });
                    }
                } catch (inputError) {
                    console.error('Rate cell input handler error:', inputError);
                    this.textContent = defaultRate;
                }
            };

            rateCell.addEventListener('input', inputHandler);
            eventListeners.push({ element: rateCell, event: 'input', handler: inputHandler });
        }

    } catch (error) {
        console.error('addRateCellEventListeners: Error adding event listeners:', error);
    }

    return eventListeners;
}

// Helper function for toggle button
function addToggleButton(parentRow, rateRow, isPickOrPack) {
    try {
        if (!parentRow.cells[0]) {
            throw new Error('Parent row has no first cell');
        }

        const toggleButton = document.createElement('button');
        if (!toggleButton) {
            throw new Error('Failed to create toggle button');
        }

        toggleButton.textContent = isPickOrPack ? '‚ñº' : '‚ñ∂';
        toggleButton.style.cssText = `
            margin-right: 8px;
            border: none;
            background: none;
            cursor: pointer;
            color: #1e293b;
            font-size: 14px;
            transition: transform 0.2s ease;
        `;

        // Set initial transform state
        if (!isPickOrPack) {
            toggleButton.style.transform = 'rotate(-90deg)';
        }

        const clickHandler = function() {
            try {
                const isExpanded = rateRow.style.display !== 'none';
                rateRow.style.display = isExpanded ? 'none' : 'table-row';
                toggleButton.textContent = isExpanded ? '‚ñ∂' : '‚ñº';
                toggleButton.style.transform = isExpanded ? 'rotate(-90deg)' : 'rotate(0deg)';

                // Update container position if function exists
                if (typeof updateNextCPTContainerPosition === 'function') {
                    setTimeout(() => {
                        try {
                            updateNextCPTContainerPosition();
                        } catch (positionError) {
                            console.warn('Error updating container position:', positionError);
                        }
                    }, 50);
                }
            } catch (toggleError) {
                console.error('Toggle button click handler error:', toggleError);
            }
        };

        toggleButton.addEventListener('click', clickHandler);

        // Store click handler for cleanup
        toggleButton._clickHandler = clickHandler;

        // Insert button at the beginning of the first cell
        parentRow.cells[0].insertBefore(toggleButton, parentRow.cells[0].firstChild);

        return toggleButton;

    } catch (error) {
        console.error('addToggleButton: Error creating toggle button:', error);
        return null;
    }
}

function updateRecommendations(table) {
    try {
        // Validate table parameter
        if (!table) {
            console.error('updateRecommendations: Table parameter is required');
            return false;
        }

        if (!table.rows || table.rows.length < 5) {
            console.error('updateRecommendations: Table does not have sufficient rows');
            return false;
        }

        // Find Pick2Rebin Pack row with more robust selection
        let pickRebinPackRow = null;

        try {
            // Method 1: Try the assumed 5th row
            const fifthRow = table.rows[4]; // 0-indexed, so 4 = 5th row
            if (fifthRow && fifthRow.cells[0]) {
                const cellText = (fifthRow.cells[0].textContent || fifthRow.cells[0].innerText || '').trim();
                if (cellText === 'Pick2Rebin Pack') {
                    pickRebinPackRow = fifthRow;
                }
            }

            // Method 2: Search through all rows if not found
            if (!pickRebinPackRow) {
                for (let i = 0; i < table.rows.length; i++) {
                    const row = table.rows[i];
                    if (row && row.cells[0]) {
                        const cellText = (row.cells[0].textContent || row.cells[0].innerText || '').trim();
                        if (cellText === 'Pick2Rebin Pack') {
                            pickRebinPackRow = row;
                            break;
                        }
                    }
                }
            }
        } catch (rowSearchError) {
            console.error('updateRecommendations: Error searching for Pick2Rebin Pack row:', rowSearchError);
        }

        if (!pickRebinPackRow) {
            console.warn('updateRecommendations: Pick2Rebin Pack row not found');
            return false;
        }

        // Get risk model value with enhanced validation
        let riskModelValue;
        try {
            if (typeof getSelectedRiskModelValue !== 'function') {
                throw new Error('getSelectedRiskModelValue function not available');
            }

            riskModelValue = getSelectedRiskModelValue();

            if (riskModelValue === null || riskModelValue === undefined) {
                throw new Error('Risk model value is null or undefined');
            }

            if (typeof riskModelValue !== 'number' || isNaN(riskModelValue)) {
                throw new Error('Risk model value is not a valid number');
            }
        } catch (riskError) {
            console.warn('updateRecommendations: Unable to get valid risk model value:', riskError.message);
            return false;
        }

        // Get schedule table with enhanced fallback logic
        let scheduleTable;
        try {
            scheduleTable = document.querySelector('#SelectedCPTSchedule') ||
                           document.querySelector('#NextCPTSchedule') ||
                           document.querySelector('.SiteSchedule');

            if (!scheduleTable) {
                throw new Error('No schedule table found');
            }

            if (!scheduleTable.rows || scheduleTable.rows.length === 0) {
                throw new Error('Schedule table has no rows');
            }
        } catch (scheduleError) {
            console.warn('updateRecommendations: Schedule table issue:', scheduleError.message);
            return false;
        }

        // Get production windows with validation
        let productionWindows;
        try {
            if (typeof getProductionWindows !== 'function') {
                throw new Error('getProductionWindows function not available');
            }

            productionWindows = getProductionWindows(scheduleTable);

            if (!productionWindows || !Array.isArray(productionWindows)) {
                throw new Error('Production windows is not a valid array');
            }

            if (productionWindows.length === 0) {
                throw new Error('No production windows found');
            }
        } catch (windowsError) {
            console.warn('updateRecommendations: Unable to get production windows:', windowsError.message);
            return false;
        }

        // Get expected rates with validation
        let expectedRates;
        try {
            if (typeof getExpectedRates !== 'function') {
                throw new Error('getExpectedRates function not available');
            }

            expectedRates = getExpectedRates(table, pickRebinPackRow, productionWindows);

            if (!expectedRates || typeof expectedRates !== 'object') {
                throw new Error('Expected rates is not a valid object');
            }
        } catch (ratesError) {
            console.warn('updateRecommendations: Unable to get expected rates:', ratesError.message);
            return false;
        }

        // Get CPT time with validation
        let cptTime;
        try {
            const cptSelect = document.getElementById('cptSelect');
            if (!cptSelect) {
                throw new Error('CPT select element not found');
            }

            cptTime = cptSelect.value;
            if (!cptTime || typeof cptTime !== 'string') {
                throw new Error('CPT time is not valid');
            }

            cptTime = cptTime.trim();
            if (!cptTime) {
                throw new Error('CPT time is empty');
            }
        } catch (cptError) {
            console.warn('updateRecommendations: Unable to get CPT time:', cptError.message);
            return false;
        }

        // Collect user overrides with enhanced validation
        const userOverrides = {};
        try {
            for (let i = 1; i < pickRebinPackRow.cells.length; i++) {
                try {
                    const overrideCell = pickRebinPackRow.cells[i];
                    if (!overrideCell) continue;

                    if (overrideCell.dataset && overrideCell.dataset.userOverride === 'true') {
                        const cellText = (overrideCell.textContent || overrideCell.innerText || '').trim();
                        const value = parseFloat(cellText);

                        if (!isNaN(value) && isFinite(value)) {
                            userOverrides[i - 1] = value;
                        }
                    }
                } catch (cellError) {
                    console.warn(`updateRecommendations: Error processing override cell ${i}:`, cellError);
                }
            }
        } catch (overrideError) {
            console.error('updateRecommendations: Error collecting user overrides:', overrideError);
            // Continue without overrides
        }

        // Calculate new recommendations
        let newRecommendations;
        try {
            if (typeof calculateHCRecommendations !== 'function') {
                throw new Error('calculateHCRecommendations function not available');
            }

            newRecommendations = calculateHCRecommendations(
                riskModelValue,
                productionWindows,
                expectedRates,
                userOverrides,
                cptTime
            );

            if (!newRecommendations || typeof newRecommendations !== 'object') {
                throw new Error('Recommendations calculation returned invalid result');
            }
        } catch (calcError) {
            console.warn('updateRecommendations: Unable to calculate HC recommendations:', calcError.message);
            return false;
        }

        // Update UI elements with function validation and error handling
        let updateSuccess = true;

        try {
            if (typeof updatePickRebinPackRow === 'function') {
                updatePickRebinPackRow(pickRebinPackRow, newRecommendations, userOverrides);
            } else {
                console.warn('updateRecommendations: updatePickRebinPackRow function not available');
                updateSuccess = false;
            }
        } catch (packRowError) {
            console.error('updateRecommendations: Error updating Pick2Rebin Pack row:', packRowError);
            updateSuccess = false;
        }

        try {
            if (typeof updateProductionGraphic === 'function') {
                updateProductionGraphic();
            } else {
                console.warn('updateRecommendations: updateProductionGraphic function not available');
            }
        } catch (graphicError) {
            console.error('updateRecommendations: Error updating production graphic:', graphicError);
        }

        // Handle table-specific updates with validation
        try {
            if (table.id === 'nextCPTProductionGraphicTable') {
                if (typeof updateNextCPTProductionGraphic === 'function') {
                    updateNextCPTProductionGraphic();
                } else {
                    console.warn('updateRecommendations: updateNextCPTProductionGraphic function not available');
                }
            } else {
                if (typeof updateProcessingTimeLeft === 'function') {
                    updateProcessingTimeLeft();
                } else {
                    console.warn('updateRecommendations: updateProcessingTimeLeft function not available');
                }
            }
        } catch (specificUpdateError) {
            console.error('updateRecommendations: Error in table-specific updates:', specificUpdateError);
        }

        console.log('updateRecommendations: Successfully completed update process');
        return updateSuccess;

    } catch (error) {
        console.error('updateRecommendations: Unexpected error:', error);
        return false;
    }
}

function handleRateOverride(cell, newRate, defaultRate) {
    try {
        // Enhanced input validation
        if (!cell) {
            console.error('handleRateOverride: Cell parameter is required');
            return false;
        }

        if (newRate === undefined || newRate === null) {
            console.error('handleRateOverride: newRate parameter is required');
            return false;
        }

        if (defaultRate === undefined || defaultRate === null) {
            console.error('handleRateOverride: defaultRate parameter is required');
            return false;
        }

        // Validate cell is a DOM element
        if (!cell.textContent && !cell.innerText) {
            console.error('handleRateOverride: Invalid cell element provided');
            return false;
        }

        // Handle reset command
        const newRateStr = String(newRate).trim().toUpperCase();
        if (newRateStr === 'R') {
            try {
                cell.textContent = defaultRate;
                cell.style.backgroundColor = '';
                cell.dataset.userOverride = 'false';
                console.log('handleRateOverride: Rate reset to default');
            } catch (resetError) {
                console.error('handleRateOverride: Error resetting rate:', resetError);
                return false;
            }
        } else {
            // Validate and set new rate
            const parsedRate = parseFloat(newRate);

            if (isNaN(parsedRate)) {
                console.warn('handleRateOverride: Invalid rate - not a number');
                alert('Please enter a valid number for the rate.');
                return false;
            }

            if (parsedRate <= 0) {
                console.warn('handleRateOverride: Invalid rate - must be positive');
                alert('Please enter a positive number for the rate.');
                return false;
            }

            if (!isFinite(parsedRate)) {
                console.warn('handleRateOverride: Invalid rate - must be finite');
                alert('Please enter a valid finite number for the rate.');
                return false;
            }

            try {
                cell.textContent = parsedRate;
                cell.style.backgroundColor = 'lightgreen';
                cell.dataset.userOverride = 'true';
                console.log(`handleRateOverride: Rate set to ${parsedRate}`);
            } catch (setError) {
                console.error('handleRateOverride: Error setting rate:', setError);
                return false;
            }
        }

        // Get parent table with validation
        let productionTable;
        try {
            productionTable = cell.closest('table');
            if (!productionTable) {
                throw new Error('Unable to find parent table');
            }

            if (!productionTable.rows || productionTable.rows.length === 0) {
                throw new Error('Parent table has no rows');
            }
        } catch (tableError) {
            console.error('handleRateOverride: Table validation failed:', tableError.message);
            return false;
        }

        // Find Pick2Rebin Pack row with robust search
        let pickRebinPackRow = null;
        try {
            // Method 1: Try the assumed 3rd row
            const thirdRow = productionTable.rows[2]; // 0-indexed
            if (thirdRow && thirdRow.cells[0]) {
                const cellText = (thirdRow.cells[0].textContent || thirdRow.cells[0].innerText || '').trim();
                if (cellText === 'Pick2Rebin Pack') {
                    pickRebinPackRow = thirdRow;
                }
            }

            // Method 2: Search through all rows if not found
            if (!pickRebinPackRow) {
                for (let i = 0; i < productionTable.rows.length; i++) {
                    const row = productionTable.rows[i];
                    if (row && row.cells[0]) {
                        const cellText = (row.cells[0].textContent || row.cells[0].innerText || '').trim();
                        if (cellText === 'Pick2Rebin Pack') {
                            pickRebinPackRow = row;
                            break;
                        }
                    }
                }
            }
        } catch (rowSearchError) {
            console.error('handleRateOverride: Error searching for Pick2Rebin Pack row:', rowSearchError);
        }

        if (!pickRebinPackRow) {
            console.warn('handleRateOverride: Pick2Rebin Pack row not found');
            return false;
        }

        // Get risk model value with validation
        let riskModelValue;
        try {
            if (typeof getSelectedRiskModelValue !== 'function') {
                throw new Error('getSelectedRiskModelValue function not available');
            }

            riskModelValue = getSelectedRiskModelValue();

            if (riskModelValue === null || riskModelValue === undefined) {
                throw new Error('Risk model value is null or undefined');
            }

            if (typeof riskModelValue !== 'number' || isNaN(riskModelValue)) {
                throw new Error('Risk model value is not a valid number');
            }
        } catch (riskError) {
            console.warn('handleRateOverride: Unable to get valid risk model value:', riskError.message);
            return false;
        }

        // Get schedule table with enhanced fallback
        let scheduleTable;
        try {
            scheduleTable = document.querySelector('#SelectedCPTSchedule') ||
                           document.querySelector('#NextCPTSchedule') ||
                           document.querySelector('.SiteSchedule');

            if (!scheduleTable) {
                throw new Error('No schedule table found');
            }

            if (!scheduleTable.rows || scheduleTable.rows.length === 0) {
                throw new Error('Schedule table has no rows');
            }
        } catch (scheduleError) {
            console.warn('handleRateOverride: Schedule table issue:', scheduleError.message);
            return false;
        }

        // Get production windows with validation
        let productionWindows;
        try {
            if (typeof getProductionWindows !== 'function') {
                throw new Error('getProductionWindows function not available');
            }

            productionWindows = getProductionWindows(scheduleTable);

            if (!productionWindows || !Array.isArray(productionWindows)) {
                throw new Error('Production windows is not a valid array');
            }

            if (productionWindows.length === 0) {
                throw new Error('No production windows found');
            }
        } catch (windowsError) {
            console.warn('handleRateOverride: Unable to get production windows:', windowsError.message);
            return false;
        }

        // Get expected rates with validation
        let expectedRates;
        try {
            if (typeof getExpectedRates !== 'function') {
                throw new Error('getExpectedRates function not available');
            }

            expectedRates = getExpectedRates(productionTable, pickRebinPackRow, productionWindows);

            if (!expectedRates || typeof expectedRates !== 'object') {
                throw new Error('Expected rates is not a valid object');
            }
        } catch (ratesError) {
            console.warn('handleRateOverride: Unable to get expected rates:', ratesError.message);
            return false;
        }

        // Get CPT time with validation
        let cptTime;
        try {
            const cptSelect = document.getElementById('cptSelect');
            if (!cptSelect) {
                throw new Error('CPT select element not found');
            }

            cptTime = cptSelect.value;
            if (!cptTime || typeof cptTime !== 'string') {
                throw new Error('CPT time is not valid');
            }

            cptTime = cptTime.trim();
            if (!cptTime) {
                throw new Error('CPT time is empty');
            }
        } catch (cptError) {
            console.warn('handleRateOverride: Unable to get CPT time:', cptError.message);
            return false;
        }

        // Collect user overrides with enhanced validation
        const userOverrides = {};
        try {
            for (let i = 1; i < pickRebinPackRow.cells.length; i++) {
                try {
                    const overrideCell = pickRebinPackRow.cells[i];
                    if (!overrideCell) continue;

                    if (overrideCell.dataset && overrideCell.dataset.userOverride === 'true') {
                        const cellText = (overrideCell.textContent || overrideCell.innerText || '').trim();
                        const value = parseFloat(cellText);

                        if (!isNaN(value) && isFinite(value)) {
                            userOverrides[i - 1] = value;
                        }
                    }
                } catch (cellError) {
                    console.warn(`handleRateOverride: Error processing override cell ${i}:`, cellError);
                }
            }
        } catch (overrideError) {
            console.error('handleRateOverride: Error collecting user overrides:', overrideError);
            // Continue without overrides
        }

        // Calculate new recommendations
        let newRecommendations;
        try {
            if (typeof calculateHCRecommendations !== 'function') {
                throw new Error('calculateHCRecommendations function not available');
            }

            newRecommendations = calculateHCRecommendations(
                riskModelValue,
                productionWindows,
                expectedRates,
                userOverrides,
                cptTime
            );

            if (!newRecommendations || typeof newRecommendations !== 'object') {
                throw new Error('Recommendations calculation returned invalid result');
            }
        } catch (calcError) {
            console.warn('handleRateOverride: Unable to calculate HC recommendations:', calcError.message);
            return false;
        }

        // Update UI elements with error handling
        let updateSuccess = true;

        try {
            if (typeof updatePickRebinPackRow === 'function') {
                updatePickRebinPackRow(pickRebinPackRow, newRecommendations, userOverrides);
            } else {
                console.warn('handleRateOverride: updatePickRebinPackRow function not available');
                updateSuccess = false;
            }
        } catch (packRowError) {
            console.error('handleRateOverride: Error updating Pick2Rebin Pack row:', packRowError);
            updateSuccess = false;
        }

        try {
            if (typeof updateOutboundTotals === 'function') {
                updateOutboundTotals(productionTable);
            } else {
                console.warn('handleRateOverride: updateOutboundTotals function not available');
            }
        } catch (totalsError) {
            console.error('handleRateOverride: Error updating outbound totals:', totalsError);
        }

        try {
            if (typeof updateProductionGraphic === 'function') {
                updateProductionGraphic();
            } else {
                console.warn('handleRateOverride: updateProductionGraphic function not available');
            }
        } catch (graphicError) {
            console.error('handleRateOverride: Error updating production graphic:', graphicError);
        }

        // Handle table-specific updates with validation
        try {
            if (productionTable.id === 'nextCPTProductionGraphicTable') {
                if (typeof updateNextCPTProductionGraphic === 'function') {
                    updateNextCPTProductionGraphic();
                } else {
                    console.warn('handleRateOverride: updateNextCPTProductionGraphic function not available');
                }
            } else {
                if (typeof updateProcessingTimeLeft === 'function') {
                    updateProcessingTimeLeft();
                } else {
                    console.warn('handleRateOverride: updateProcessingTimeLeft function not available');
                }
            }
        } catch (specificUpdateError) {
            console.error('handleRateOverride: Error in table-specific updates:', specificUpdateError);
        }

        console.log('handleRateOverride: Successfully completed rate override process');
        return updateSuccess;

    } catch (error) {
        console.error('handleRateOverride: Unexpected error:', error);
        return false;
    }
}

function addOutboundTotalsRow(table) {
    try {
        // Enhanced table parameter validation
        if (!table) {
            console.error('addOutboundTotalsRow: Table parameter is required');
            return null;
        }

        if (typeof table !== 'object' || !table.rows) {
            console.error('addOutboundTotalsRow: Invalid table object provided');
            return null;
        }

        // Validate table structure
        if (table.rows.length === 0) {
            console.error('addOutboundTotalsRow: Table must have at least one row (header)');
            return null;
        }

        // Validate header row structure
        const headerRow = table.rows[0];
        if (!headerRow || !headerRow.cells || headerRow.cells.length === 0) {
            console.error('addOutboundTotalsRow: Header row must have cells');
            return null;
        }

        // Check if totals row already exists
        let existingTotalsRow = null;
        try {
            for (let i = 0; i < table.rows.length; i++) {
                const row = table.rows[i];
                if (row && row.cells[0]) {
                    const cellText = (row.cells[0].textContent || row.cells[0].innerText || '').trim();
                    if (cellText === 'Outbound Totals') {
                        existingTotalsRow = row;
                        break;
                    }
                }
            }
        } catch (searchError) {
            console.warn('addOutboundTotalsRow: Error searching for existing totals row:', searchError);
        }

        if (existingTotalsRow) {
            console.log('addOutboundTotalsRow: Totals row already exists, updating instead');
            try {
                if (typeof updateOutboundTotals === 'function') {
                    updateOutboundTotals(table);
                    return existingTotalsRow;
                } else {
                    console.warn('addOutboundTotalsRow: updateOutboundTotals function not available');
                    return existingTotalsRow;
                }
            } catch (updateError) {
                console.error('addOutboundTotalsRow: Error updating existing totals row:', updateError);
                return existingTotalsRow;
            }
        }

        // Create new totals row
        let totalRow;
        try {
            totalRow = table.insertRow(1); // Insert after header row
            if (!totalRow) {
                throw new Error('Failed to create totals row');
            }
        } catch (rowError) {
            console.error('addOutboundTotalsRow: Error creating totals row:', rowError);
            return null;
        }

        // Create name cell
        let nameCell;
        try {
            nameCell = totalRow.insertCell();
            if (!nameCell) {
                throw new Error('Failed to create name cell');
            }

            nameCell.textContent = 'Outbound Totals';
            nameCell.style.cssText = `
                font-weight: 700;
                padding: 8px;
                color: #1e293b;
                font-size: 16px;
                border-bottom: 2px solid #e2e8f0;
                background-color: #f8fafc;
                text-align: left;
            `;

            // Add identifying attribute for easier selection
            nameCell.setAttribute('data-cell-type', 'totals-label');
        } catch (nameCellError) {
            console.error('addOutboundTotalsRow: Error creating name cell:', nameCellError);
            try {
                totalRow.remove();
            } catch (removeError) {
                console.warn('Error removing failed totals row:', removeError);
            }
            return null;
        }

        // Create data cells for each column (excluding the first name column)
        const dataCells = [];
        const totalColumns = headerRow.cells.length;

        for (let i = 1; i < totalColumns; i++) {
            try {
                const cell = totalRow.insertCell();
                if (!cell) {
                    console.warn(`addOutboundTotalsRow: Failed to create cell at index ${i}`);
                    continue;
                }

                cell.style.cssText = `
                    padding: 8px;
                    text-align: center;
                    background-color: #f8fafc;
                    color: #1e293b;
                    font-weight: 700;
                    font-size: 16px;
                    border-bottom: 2px solid #e2e8f0;
                `;

                // Add identifying attributes
                cell.setAttribute('data-cell-type', 'totals-data');
                cell.setAttribute('data-column-index', i - 1);

                // Initialize with 0
                cell.textContent = '0';

                dataCells.push(cell);

            } catch (cellError) {
                console.error(`addOutboundTotalsRow: Error creating cell ${i}:`, cellError);
            }
        }

        // Validate we created some data cells
        if (dataCells.length === 0) {
            console.error('addOutboundTotalsRow: No data cells were created successfully');
            try {
                totalRow.remove();
            } catch (removeError) {
                console.warn('Error removing invalid totals row:', removeError);
            }
            return null;
        }

        // Update totals with function validation
        try {
            if (typeof updateOutboundTotals === 'function') {
                updateOutboundTotals(table);
            } else {
                console.warn('addOutboundTotalsRow: updateOutboundTotals function not available');
            }
        } catch (updateError) {
            console.error('addOutboundTotalsRow: Error calling updateOutboundTotals:', updateError);
        }

        // Return row reference and metadata
        const result = {
            row: totalRow,
            nameCell: nameCell,
            dataCells: dataCells,
            columnCount: totalColumns - 1,
            cleanup: () => {
                try {
                    if (totalRow && totalRow.parentNode) {
                        totalRow.remove();
                    }
                } catch (cleanupError) {
                    console.error('addOutboundTotalsRow: Error during cleanup:', cleanupError);
                }
            }
        };

        console.log(`addOutboundTotalsRow: Successfully created totals row with ${dataCells.length} data cells`);
        return result;

    } catch (error) {
        console.error('addOutboundTotalsRow: Unexpected error:', error);
        return null;
    }
}

// Helper function to safely update totals if the main function isn't available
function safeUpdateOutboundTotals(table) {
    try {
        // Enhanced input validation
        if (!table) {
            console.error('safeUpdateOutboundTotals: Table parameter is required');
            return false;
        }

        if (!table.rows || table.rows.length === 0) {
            console.warn('safeUpdateOutboundTotals: Table has no rows to process');
            return false;
        }

        // Check if updateOutboundTotals function exists and is callable
        if (typeof updateOutboundTotals === 'function') {
            const result = updateOutboundTotals(table);

            // Validate the result if the function returns something meaningful
            if (result === false) {
                console.warn('safeUpdateOutboundTotals: updateOutboundTotals returned false');
            }

            return result !== false;
        } else {
            console.warn('safeUpdateOutboundTotals: updateOutboundTotals function not available');

            // Optional: Implement basic fallback totaling logic
            try {
                return performBasicTotalsUpdate(table);
            } catch (fallbackError) {
                console.error('safeUpdateOutboundTotals: Fallback update failed:', fallbackError);
                return false;
            }
        }
    } catch (error) {
        console.error('safeUpdateOutboundTotals: Error updating totals:', error);
        return false;
    }
}

// Optional fallback function for basic totals calculation
function performBasicTotalsUpdate(table) {
    try {
        // Find the totals row
        let totalsRow = null;
        for (let i = 0; i < table.rows.length; i++) {
            const row = table.rows[i];
            if (row && row.cells[0]) {
                const cellText = (row.cells[0].textContent || row.cells[0].innerText || '').trim();
                if (cellText === 'Outbound Totals') {
                    totalsRow = row;
                    break;
                }
            }
        }

        if (!totalsRow) {
            console.warn('performBasicTotalsUpdate: No totals row found');
            return false;
        }

        // Basic summation for each column
        for (let col = 1; col < totalsRow.cells.length; col++) {
            let columnTotal = 0;

            for (let row = 0; row < table.rows.length; row++) {
                const currentRow = table.rows[row];
                if (currentRow === totalsRow) continue; // Skip totals row itself

                if (currentRow && currentRow.cells[col]) {
                    const cellText = (currentRow.cells[col].textContent || currentRow.cells[col].innerText || '').trim();
                    const value = parseFloat(cellText);

                    if (!isNaN(value) && isFinite(value)) {
                        columnTotal += value;
                    }
                }
            }

            totalsRow.cells[col].textContent = columnTotal;
        }

        console.log('performBasicTotalsUpdate: Basic totals calculation completed');
        return true;

    } catch (error) {
        console.error('performBasicTotalsUpdate: Error in fallback calculation:', error);
        return false;
    }
}

function updateDefaultRates(table, rowName) {
    try {
        // Enhanced input validation
        if (!table) {
            console.error('updateDefaultRates: Table parameter is required');
            return false;
        }

        if (!rowName || typeof rowName !== 'string') {
            console.error('updateDefaultRates: Valid rowName parameter is required');
            return false;
        }

        if (!table.rows || table.rows.length === 0) {
            console.error('updateDefaultRates: Table has no rows');
            return false;
        }

        const trimmedRowName = rowName.trim();
        if (!trimmedRowName) {
            console.error('updateDefaultRates: rowName cannot be empty');
            return false;
        }

        // Get the appropriate rate input element with validation
        let rateInputId;
        if (trimmedRowName === 'Pick2Rebin Pick') {
            rateInputId = 'pickRate';
        } else if (trimmedRowName === 'Pick2Rebin Pack') {
            rateInputId = 'packRate';
        } else {
            console.error(`updateDefaultRates: Unsupported rowName "${trimmedRowName}"`);
            return false;
        }

        const rateElement = document.getElementById(rateInputId);
        if (!rateElement) {
            console.error(`updateDefaultRates: Rate input element "${rateInputId}" not found`);
            return false;
        }

        // Validate and parse the new rate
        const rawRate = rateElement.value;
        if (!rawRate || typeof rawRate !== 'string') {
            console.warn('updateDefaultRates: Rate input is empty or invalid');
            return false;
        }

        const trimmedRate = rawRate.trim();
        if (!trimmedRate) {
            console.warn('updateDefaultRates: Rate input is empty after trimming');
            return false;
        }

        const newRate = parseFloat(trimmedRate);
        if (isNaN(newRate)) {
            console.error(`updateDefaultRates: Rate "${trimmedRate}" is not a valid number`);
            return false;
        }

        if (newRate < 0) {
            console.error(`updateDefaultRates: Rate cannot be negative: ${newRate}`);
            return false;
        }

        if (!isFinite(newRate)) {
            console.error(`updateDefaultRates: Rate must be a finite number: ${newRate}`);
            return false;
        }

        // Find the row with the specified name
        let targetRow = null;
        let targetRowIndex = -1;

        for (let i = 0; i < table.rows.length; i++) {
            try {
                const row = table.rows[i];

                // Validate row structure
                if (!row || !row.cells || !row.cells[0]) {
                    continue;
                }

                const cellText = (row.cells[0].textContent || row.cells[0].innerText || '').trim();
                if (cellText === trimmedRowName) {
                    targetRow = row;
                    targetRowIndex = i;
                    break;
                }
            } catch (rowError) {
                console.warn(`updateDefaultRates: Error checking row ${i}:`, rowError);
                continue;
            }
        }

        if (!targetRow) {
            console.error(`updateDefaultRates: Row with name "${trimmedRowName}" not found`);
            return false;
        }

        // Check if rate row exists after the target row
        if (targetRowIndex + 1 >= table.rows.length) {
            console.error(`updateDefaultRates: Rate row not found after "${trimmedRowName}" row`);
            return false;
        }

        const rateRow = table.rows[targetRowIndex + 1];
        if (!rateRow || !rateRow.cells) {
            console.error(`updateDefaultRates: Invalid rate row structure for "${trimmedRowName}"`);
            return false;
        }

        // Validate this is actually a rate row by checking the first cell
        const rateRowLabel = (rateRow.cells[0]?.textContent || rateRow.cells[0]?.innerText || '').trim();
        if (!rateRowLabel.toLowerCase().includes('rate')) {
            console.warn(`updateDefaultRates: Following row doesn't appear to be a rate row. Label: "${rateRowLabel}"`);
        }

        // Update all rate cells in the row (skip first column which is the label)
        let updatedCells = 0;
        let errorCount = 0;

        for (let j = 1; j < rateRow.cells.length; j++) {
            try {
                const cell = rateRow.cells[j];
                if (cell) {
                    // Store old value for logging
                    const oldValue = (cell.textContent || cell.innerText || '').trim();

                    cell.textContent = newRate;
                    updatedCells++;

                    // Clear any user override marking since this is a default update
                    if (cell.dataset) {
                        cell.dataset.userOverride = 'false';
                    }

                    // Reset background color to default
                    if (cell.style.backgroundColor === 'lightgreen') {
                        cell.style.backgroundColor = '';
                    }
                } else {
                    console.warn(`updateDefaultRates: Rate cell ${j} not found in rate row for "${trimmedRowName}"`);
                    errorCount++;
                }
            } catch (cellError) {
                console.error(`updateDefaultRates: Error updating cell ${j}:`, cellError);
                errorCount++;
            }
        }

        if (updatedCells === 0) {
            console.error(`updateDefaultRates: No cells were updated for "${trimmedRowName}"`);
            return false;
        }

        console.log(`updateDefaultRates: Updated ${updatedCells} rate cells for "${trimmedRowName}" with rate ${newRate}${errorCount > 0 ? ` (${errorCount} errors)` : ''}`);

        // Update totals with enhanced error handling
        try {
            if (typeof updateOutboundTotals === 'function') {
                const totalsResult = updateOutboundTotals(table);
                if (totalsResult === false) {
                    console.warn('updateDefaultRates: updateOutboundTotals returned false');
                }
            } else {
                console.warn('updateDefaultRates: updateOutboundTotals function not available');

                // Try safe fallback
                if (typeof safeUpdateOutboundTotals === 'function') {
                    safeUpdateOutboundTotals(table);
                }
            }
        } catch (totalsError) {
            console.error('updateDefaultRates: Error updating totals:', totalsError);
        }

        return updatedCells > 0;

    } catch (error) {
        console.error('updateDefaultRates: Unexpected error:', error);
        return false;
    }
}

function createNextCPTProductionGraphic(containerId) {
    try {
        // Enhanced input validation
        if (!containerId || typeof containerId !== 'string') {
            console.error('createNextCPTProductionGraphic: Valid containerId parameter is required');
            return null;
        }

        const trimmedContainerId = containerId.trim();
        if (!trimmedContainerId) {
            console.error('createNextCPTProductionGraphic: containerId cannot be empty');
            return null;
        }

        // Find and validate container
        const container = document.getElementById(trimmedContainerId);
        if (!container) {
            console.error(`createNextCPTProductionGraphic: Container element "${trimmedContainerId}" not found`);
            return null;
        }

        // Clear existing content with error handling
        try {
            // Clean up any existing event listeners before clearing
            const existingTable = container.querySelector('#nextCPTProductionGraphicTable');
            if (existingTable) {
                const elementsWithListeners = existingTable.querySelectorAll('[data-has-listeners]');
                elementsWithListeners.forEach(element => {
                    if (element._eventListeners) {
                        Object.entries(element._eventListeners).forEach(([event, handler]) => {
                            element.removeEventListener(event, handler);
                        });
                    }
                });
            }

            container.innerHTML = '';
        } catch (clearError) {
            console.error('createNextCPTProductionGraphic: Error clearing container:', clearError);
        }

        // Create table with error handling
        const table = document.createElement('table');
        if (!table) {
            console.error('createNextCPTProductionGraphic: Failed to create table element');
            return null;
        }

        table.id = 'nextCPTProductionGraphicTable';
        table.style.cssText = `
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border-radius: 8px;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        `;

        // Get and validate rate elements
        const pickRateElement = document.getElementById('pickRate');
        const packRateElement = document.getElementById('packRate');

        if (!pickRateElement || !packRateElement) {
            console.error('createNextCPTProductionGraphic: Pick rate or pack rate elements not found');
            return null;
        }

        // Validate and parse rates
        let pickRate, packRate;
        try {
            const rawPickRate = pickRateElement.value;
            const rawPackRate = packRateElement.value;

            if (!rawPickRate || !rawPackRate) {
                console.warn('createNextCPTProductionGraphic: Pick rate or pack rate is empty');
                pickRate = 100; // Default fallback
                packRate = 100; // Default fallback
            } else {
                pickRate = parseFloat(rawPickRate);
                packRate = parseFloat(rawPackRate);

                if (isNaN(pickRate) || isNaN(packRate)) {
                    console.warn('createNextCPTProductionGraphic: Invalid rate values, using defaults');
                    pickRate = 100;
                    packRate = 100;
                }
            }
        } catch (rateError) {
            console.error('createNextCPTProductionGraphic: Error parsing rates:', rateError);
            pickRate = 100;
            packRate = 100;
        }

        // Create header row with error handling
        let headerRow;
        try {
            headerRow = table.insertRow();
            if (!headerRow) {
                throw new Error('Failed to create header row');
            }

            const recommendationCell = headerRow.insertCell();
            if (!recommendationCell) {
                throw new Error('Failed to create recommendation cell');
            }

            recommendationCell.textContent = 'Recommendation';
            recommendationCell.style.cssText = `
                padding: 16px;
                background-color: #f8fafc;
                color: #1e293b;
                font-weight: 600;
                font-size: 16px;
                border-bottom: 2px solid #e2e8f0;
                text-align: left;
            `;
        } catch (headerError) {
            console.error('createNextCPTProductionGraphic: Error creating header row:', headerError);
            return null;
        }

        // Get production windows with error handling
        let productionWindows;
        try {
            const scheduleTable = document.querySelector('#NextCPTSchedule');
            if (!scheduleTable) {
                console.warn('createNextCPTProductionGraphic: NextCPTSchedule table not found');
                return null;
            }

            if (typeof getProductionWindows !== 'function') {
                throw new Error('getProductionWindows function not available');
            }

            productionWindows = getProductionWindows(scheduleTable);
            if (!productionWindows || !Array.isArray(productionWindows) || productionWindows.length === 0) {
                throw new Error('No valid production windows found');
            }
        } catch (windowsError) {
            console.error('createNextCPTProductionGraphic: Error getting production windows:', windowsError);
            return null;
        }

        // Create header cells for production windows
        productionWindows.forEach((window, index) => {
            try {
                const cell = headerRow.insertCell();
                if (!cell) {
                    console.warn(`createNextCPTProductionGraphic: Failed to create header cell ${index}`);
                    return;
                }

                cell.textContent = window.timeWindow || `Window ${index + 1}`;
                cell.style.cssText = `
                    padding: 16px;
                    background-color: #f8fafc;
                    color: #1e293b;
                    font-weight: 600;
                    font-size: 16px;
                    border-bottom: 2px solid #e2e8f0;
                    text-align: center;
                `;
            } catch (cellError) {
                console.error(`createNextCPTProductionGraphic: Error creating header cell ${index}:`, cellError);
            }
        });

        // Define rows configuration
        const rows = [
            { name: 'Pick2Rebin Pick', defaultValue: 'X', isToggleable: true, defaultRate: pickRate, background: '#f0f9ff' },
            { name: 'Pick2Rebin Pack', defaultValue: 'X', isToggleable: true, defaultRate: packRate, background: '#f0f9ff' },
            { name: 'VNA Pick', defaultValue: 'X', isToggleable: true, defaultRate: 100, background: '#f3f4f6' },
            { name: 'VNA Pack', defaultValue: 'X', isToggleable: true, defaultRate: 100, background: '#f3f4f6' },
            { name: 'Outbound Problem Solve', defaultValue: 1, isToggleable: false, defaultRate: 0, background: '#fef3c7' }
        ];

        // Add rows with error handling
        const addedRows = [];
        rows.forEach((rowConfig, index) => {
            try {
                if (typeof addCustomRow !== 'function') {
                    console.warn('createNextCPTProductionGraphic: addCustomRow function not available');
                    return;
                }

                const result = addCustomRow(
                    table,
                    rowConfig.name,
                    productionWindows,
                    rowConfig.defaultValue,
                    rowConfig.isToggleable,
                    rowConfig.defaultRate,
                    rowConfig.background
                );

                if (result) {
                    addedRows.push(result);
                }
            } catch (rowError) {
                console.error(`createNextCPTProductionGraphic: Error adding row ${index} (${rowConfig.name}):`, rowError);
            }
        });

        // Add Outbound Totals row with enhanced error handling
        try {
            const totalsResult = createTotalsRowForTable(table, productionWindows);
            if (totalsResult) {
                addedRows.push(totalsResult);
            }
        } catch (totalsError) {
            console.error('createNextCPTProductionGraphic: Error creating totals row:', totalsError);
        }

        // Append table to container
        try {
            container.appendChild(table);
        } catch (appendError) {
            console.error('createNextCPTProductionGraphic: Error appending table to container:', appendError);
            return null;
        }

        // Update functions with error handling
        try {
            if (typeof updateOutboundTotals === 'function') {
                updateOutboundTotals(table);
            } else {
                console.warn('createNextCPTProductionGraphic: updateOutboundTotals function not available');
            }
        } catch (totalsUpdateError) {
            console.error('createNextCPTProductionGraphic: Error updating totals:', totalsUpdateError);
        }

        // Call additional update functions with error handling
        const updateFunctions = [
            'updateNextCPTProductionTable',
            'updateNextCPTVNAPackRecommendations',
            'updateNextCPTVNAPickHCBasedOnPackHC',
            'updateNextCPTProductionGraphic'
        ];

        updateFunctions.forEach(funcName => {
            try {
                if (typeof window[funcName] === 'function') {
                    window[funcName]();
                } else {
                    console.warn(`createNextCPTProductionGraphic: ${funcName} function not available`);
                }
            } catch (updateError) {
                console.error(`createNextCPTProductionGraphic: Error calling ${funcName}:`, updateError);
            }
        });

        // Return table reference and cleanup function
        const result = {
            table: table,
            container: container,
            addedRows: addedRows,
            cleanup: () => {
                try {
                    addedRows.forEach(row => {
                        if (row.cleanup) {
                            row.cleanup();
                        }
                    });

                    if (table && table.parentNode) {
                        table.remove();
                    }
                } catch (cleanupError) {
                    console.error('createNextCPTProductionGraphic: Error during cleanup:', cleanupError);
                }
            }
        };

        console.log('createNextCPTProductionGraphic: Successfully created production graphic');
        return result;

    } catch (error) {
        console.error('createNextCPTProductionGraphic: Unexpected error:', error);
        return null;
    }
}

// Helper function for creating totals row
function createTotalsRowForTable(table, productionWindows) {
    try {
        const totalsRow = table.insertRow(1);
        if (!totalsRow) {
            throw new Error('Failed to create totals row');
        }

        const totalsLabelCell = totalsRow.insertCell();
        if (!totalsLabelCell) {
            throw new Error('Failed to create totals label cell');
        }

        totalsLabelCell.textContent = 'Outbound Totals';
        totalsLabelCell.style.cssText = `
            padding: 16px;
            background-color: #f8fafc;
            color: #1e293b;
            font-weight: 700;
            font-size: 16px;
            border-bottom: 2px solid #e2e8f0;
        `;

        const totalsCells = [];
        productionWindows.forEach((window, index) => {
            try {
                const cell = totalsRow.insertCell();
                if (!cell) {
                    console.warn(`createTotalsRowForTable: Failed to create totals cell ${index}`);
                    return;
                }

                cell.style.cssText = `
                    padding: 16px;
                    text-align: center;
                    background-color: #f8fafc;
                    color: #1e293b;
                    font-weight: 700;
                    font-size: 16px;
                    border-bottom: 2px solid #e2e8f0;
                `;

                cell.textContent = '0';
                totalsCells.push(cell);
            } catch (cellError) {
                console.error(`createTotalsRowForTable: Error creating totals cell ${index}:`, cellError);
            }
        });

        return {
            row: totalsRow,
            cells: totalsCells,
            cleanup: () => {
                try {
                    if (totalsRow && totalsRow.parentNode) {
                        totalsRow.remove();
                    }
                } catch (cleanupError) {
                    console.error('createTotalsRowForTable: Error during cleanup:', cleanupError);
                }
            }
        };

    } catch (error) {
        console.error('createTotalsRowForTable: Error creating totals row:', error);
        return null;
    }
}

// Clean up existing timeouts when creating new graphics
let positionUpdateTimeout;
let dispatchUpdateTimeout;

// Helper function to clear existing timeouts
function clearExistingTimeouts() {
    if (positionUpdateTimeout) {
        clearTimeout(positionUpdateTimeout);
        positionUpdateTimeout = null;
    }
    if (dispatchUpdateTimeout) {
        clearTimeout(dispatchUpdateTimeout);
        dispatchUpdateTimeout = null;
    }
}

function updateNextCPTContainerPosition() {
   const fullTableContainer = document.getElementById('fullTableContainer');
   const nextCPTTableContainer = document.getElementById('nextCPTTableContainer');
   const dispatchRecommendationContainer = document.getElementById('dispatchRecommendationContainer');

   // Validate all required containers exist
   if (!fullTableContainer || !nextCPTTableContainer || !dispatchRecommendationContainer) {
       console.warn('updateNextCPTContainerPosition: One or more required containers not found');
       return;
   }

   const buffer = 20;
   const minimumNextCPTTop = 800;
   const minimumDispatchTop = 1500;

   // Calculate full table position with validation
   const fullTableHeight = fullTableContainer.offsetHeight || 0;
   const fullTableTop = parseInt(fullTableContainer.style.top) || 0;
   const fullTableBottom = fullTableTop + fullTableHeight;

   // Set nextCPT position to either its minimum or just below fullTable
   const nextCPTTop = Math.max(minimumNextCPTTop, fullTableBottom + buffer);
   nextCPTTableContainer.style.top = `${nextCPTTop}px`;

   // Position dispatch container
   const nextCPTHeight = nextCPTTableContainer.offsetHeight || 0;
   const nextCPTBottom = nextCPTTop + nextCPTHeight;

   // Set dispatch position to either its minimum or just below nextCPT
   const dispatchTop = Math.max(minimumDispatchTop, nextCPTBottom + buffer);
   dispatchRecommendationContainer.style.top = `${dispatchTop}px`;
}

// Add event listeners with validation
function addPositioningEventListeners() {
    if (typeof updateNextCPTContainerPosition === 'function') {
        window.addEventListener('resize', updateNextCPTContainerPosition, { passive: true });
        window.addEventListener('load', updateNextCPTContainerPosition);
    }
}

// Initialize event listeners
addPositioningEventListeners();

// Event listener for the "Update Rates" button with validation
function addUpdateRatesListener() {
   const updateRatesButton = document.getElementById('updateRatesButton');
   const pickRateInput = document.getElementById('pickRate');
   const packRateInput = document.getElementById('packRate');

   if (!updateRatesButton) {
       console.warn('Update rates button not found');
       return;
   }

   updateRatesButton.addEventListener('click', function() {
       if (!pickRateInput || !packRateInput) {
           console.error('Pick rate or pack rate input elements not found');
           return;
       }

       const newPickRate = pickRateInput.value;
       const newPackRate = packRateInput.value;

       if (!newPickRate || !newPackRate) {
           alert('Please enter valid pick and pack rates');
           return;
       }

       if (typeof updateAllExpectedRates === 'function') {
           updateAllExpectedRates(newPickRate, newPackRate);
       } else {
           console.error('updateAllExpectedRates function not available');
       }
   });
}

// Initialize update rates listener
addUpdateRatesListener();

function updateAllExpectedRates(pickRate, packRate) {
   // Validate input parameters
   if (!pickRate || !packRate) {
       console.error('updateAllExpectedRates: Pick rate and pack rate are required');
       return;
   }

   // Validate rates are numeric
   const numericPickRate = parseFloat(pickRate);
   const numericPackRate = parseFloat(packRate);

   if (isNaN(numericPickRate) || isNaN(numericPackRate) || numericPickRate <= 0 || numericPackRate <= 0) {
       alert('Please enter valid positive numbers for pick and pack rates');
       return;
   }

   const tables = ['productionGraphic', 'nextCPTProductionGraphicTable'];

   tables.forEach(tableId => {
       const table = document.getElementById(tableId);
       if (!table || !table.rows) {
           console.warn(`updateAllExpectedRates: Table "${tableId}" not found or has no rows`);
           return;
       }

       for (let i = 0; i < table.rows.length; i++) {
           const row = table.rows[i];

           // Validate row structure
           if (!row || !row.cells || !row.cells[0]) {
               continue;
           }

           const rowName = row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '');

           if (rowName === 'Pick2Rebin Pick' || rowName === 'Pick2Rebin Pack') {
               const newRate = rowName === 'Pick2Rebin Pick' ? numericPickRate : numericPackRate;

               // Check if next row is the "Expected Rate" row
               if (i + 1 < table.rows.length) {
                   const rateRow = table.rows[i + 1];

                   if (rateRow && rateRow.cells && rateRow.cells[0] &&
                       rateRow.cells[0].textContent.trim() === 'Expected Rate') {

                       // Update the "Expected Rate" row
                       for (let j = 1; j < rateRow.cells.length; j++) {
                           if (rateRow.cells[j]) {
                               rateRow.cells[j].textContent = newRate;
                               rateRow.cells[j].style.backgroundColor = 'yellow';
                           }
                       }
                   }
               }
           }
       }

       // Update totals with function validation
       if (typeof updateOutboundTotals === 'function') {
           updateOutboundTotals(table);
       }
   });

   // Recalculate recommendations and update UI with function validation
   const updateFunctions = [
       'updatePickRebinPackRecommendations',
       'updateNextCPTProductionTable',
       'updateProductionGraphic',
       'updateNextCPTProductionGraphic',
       'updatePlanSummary1'
   ];

   updateFunctions.forEach(funcName => {
       if (typeof window[funcName] === 'function') {
           window[funcName]();
       } else {
           console.warn(`updateAllExpectedRates: Function "${funcName}" not available`);
       }
   });

   // Provide visual feedback
   showUpdateFeedback();
}

function showUpdateFeedback() {
   const updateButton = document.getElementById('updateRatesButton');
   if (!updateButton || !updateButton.parentNode) {
       console.warn('showUpdateFeedback: Update button or its parent not found');
       return;
   }

   const buttonContainer = updateButton.parentNode;

   // Remove any existing feedback messages
   const existingFeedback = buttonContainer.querySelector('.rate-update-feedback');
   if (existingFeedback) {
       existingFeedback.remove();
   }

   const feedbackElement = document.createElement('div');
   feedbackElement.className = 'rate-update-feedback';
   feedbackElement.textContent = 'Rates updated and recommendations recalculated!';
   feedbackElement.style.cssText = `
       color: green;
       font-weight: bold;
       margin-top: 10px;
       transition: opacity 0.3s ease;
   `;

   buttonContainer.appendChild(feedbackElement);

   // Remove the feedback message after 3 seconds
   setTimeout(() => {
       if (feedbackElement.parentNode) {
           feedbackElement.style.opacity = '0';
           setTimeout(() => {
               if (feedbackElement.parentNode) {
                   feedbackElement.remove();
               }
           }, 300);
       }
   }, 3000);
}

function setupUpdateRatesButton() {
   const updateButton = document.getElementById('updateRatesButton');
   const pickRateInput = document.getElementById('pickRate');
   const packRateInput = document.getElementById('packRate');

   if (!updateButton) {
       console.error('setupUpdateRatesButton: Update rates button not found');
       return;
   }

   if (!pickRateInput || !packRateInput) {
       console.error('setupUpdateRatesButton: Pick rate or pack rate input elements not found');
       return;
   }

   // Remove any existing event listeners to prevent duplicates
   const newButton = updateButton.cloneNode(true);
   updateButton.parentNode.replaceChild(newButton, updateButton);

   newButton.addEventListener('click', function() {
       const newPickRate = pickRateInput.value.trim();
       const newPackRate = packRateInput.value.trim();

       // Validate inputs before proceeding
       if (!newPickRate || !newPackRate) {
           alert('Please enter both pick and pack rates');
           return;
       }

       // Validate numeric values
       const pickRateNum = parseFloat(newPickRate);
       const packRateNum = parseFloat(newPackRate);

       if (isNaN(pickRateNum) || isNaN(packRateNum) || pickRateNum <= 0 || packRateNum <= 0) {
           alert('Please enter valid positive numbers for both rates');
           return;
       }

       if (typeof updateAllExpectedRates === 'function') {
           updateAllExpectedRates(newPickRate, newPackRate);
       } else {
           console.error('setupUpdateRatesButton: updateAllExpectedRates function not available');
           alert('Rate update functionality is not available');
       }
   });
}

// Setup button when DOM is ready with fallback options
function initializeUpdateRatesButton() {
   // Try immediate setup if DOM is already loaded
   if (document.readyState === 'complete' || document.readyState === 'interactive') {
       setupUpdateRatesButton();
   } else {
       // Wait for DOM to load
       window.addEventListener('load', setupUpdateRatesButton);
       // Also try on DOMContentLoaded as backup
       document.addEventListener('DOMContentLoaded', setupUpdateRatesButton);
   }
}

// Initialize the button setup
initializeUpdateRatesButton();

function setupRateInputListeners() {
   const pickRateInput = document.getElementById('pickRate');
   const packRateInput = document.getElementById('packRate');

   if (!pickRateInput) {
       console.error('setupRateInputListeners: Pick rate input element not found');
       return;
   }

   if (!packRateInput) {
       console.error('setupRateInputListeners: Pack rate input element not found');
       return;
   }

   // Validate updateAllExpectedRates function exists
   if (typeof updateAllExpectedRates !== 'function') {
       console.error('setupRateInputListeners: updateAllExpectedRates function not available');
       return;
   }

   // Remove any existing event listeners to prevent duplicates
   const newPickRateInput = pickRateInput.cloneNode(true);
   const newPackRateInput = packRateInput.cloneNode(true);

   pickRateInput.parentNode.replaceChild(newPickRateInput, pickRateInput);
   packRateInput.parentNode.replaceChild(newPackRateInput, packRateInput);

   // Add debounced change listeners with validation
   newPickRateInput.addEventListener('change', function() {
       const pickValue = this.value.trim();
       const packValue = newPackRateInput.value.trim();

       if (validateRateInputs(pickValue, packValue)) {
           updateAllExpectedRates(pickValue, packValue);
       }
   });

   newPackRateInput.addEventListener('change', function() {
       const pickValue = newPickRateInput.value.trim();
       const packValue = this.value.trim();

       if (validateRateInputs(pickValue, packValue)) {
           updateAllExpectedRates(pickValue, packValue);
       }
   });
}

function validateRateInputs(pickRate, packRate) {
   // Check if both values are provided
   if (!pickRate || !packRate) {
       console.warn('validateRateInputs: Both pick and pack rates must be provided');
       return false;
   }

   // Validate numeric values
   const pickRateNum = parseFloat(pickRate);
   const packRateNum = parseFloat(packRate);

   if (isNaN(pickRateNum) || isNaN(packRateNum)) {
       console.warn('validateRateInputs: Rates must be valid numbers');
       return false;
   }

   if (pickRateNum <= 0 || packRateNum <= 0) {
       console.warn('validateRateInputs: Rates must be positive numbers');
       return false;
   }

   return true;
}

// Setup listeners when DOM is ready with fallback options
function initializeRateInputListeners() {
   // Try immediate setup if DOM is already loaded
   if (document.readyState === 'complete' || document.readyState === 'interactive') {
       setupRateInputListeners();
   } else {
       // Wait for DOM to load
       window.addEventListener('load', setupRateInputListeners);
       // Also try on DOMContentLoaded as backup
       document.addEventListener('DOMContentLoaded', setupRateInputListeners);
   }
}

// Initialize the listeners
initializeRateInputListeners();


function createAndUpdateMathTable() {
   let mathTableContainer = document.getElementById('mathTableContainer');

   // Create container if it doesn't exist
   if (!mathTableContainer) {
       mathTableContainer = document.createElement('div');
       mathTableContainer.id = 'mathTableContainer';
       mathTableContainer.style.cssText = `
           position: fixed;
           right: 10px;
           top: 1300px;
           width: 300px;
           background-color: white;
           border: 1px solid black;
           padding: 10px;
           z-index: 10000;
           display: none;
           box-shadow: 0 4px 8px rgba(0,0,0,0.1);
           border-radius: 4px;
       `;

       // Validate document.body exists before appending
       if (document.body) {
           document.body.appendChild(mathTableContainer);
       } else {
           console.error('createAndUpdateMathTable: document.body not available');
           return;
       }
   }

   // Clear existing content
   mathTableContainer.innerHTML = '';

   // Create the table
   const mathTable = document.createElement('table');
   mathTable.style.cssText = `
       width: 100%;
       border-collapse: collapse;
       margin-bottom: 20px;
       font-size: 14px;
   `;

   // Create header
   const header = mathTable.createTHead();
   const headerRow = header.insertRow();
   const headerLabels = ['Type', 'Set 1', 'Set 2', 'Set 3', 'Set 4'];

   headerLabels.forEach(text => {
       const th = document.createElement('th');
       th.textContent = text;
       th.style.cssText = `
           border: 1px solid black;
           padding: 8px;
           background-color: #f2f2f2;
           font-weight: bold;
           text-align: center;
       `;
       headerRow.appendChild(th);
   });

   // Create body
   const body = mathTable.createTBody();
   const rowTypes = ['CORA', 'ATROPS', 'MIXED', 'Low Backlog'];

   rowTypes.forEach(rowName => {
       const row = body.insertRow();

       // Create type cell
       const typeCell = row.insertCell();
       typeCell.textContent = rowName;
       typeCell.style.cssText = `
           border: 1px solid black;
           padding: 8px;
           font-weight: bold;
           background-color: #f9f9f9;
       `;

       // Create data cells
       for (let i = 0; i < 4; i++) {
           const dataCell = row.insertCell();
           dataCell.style.cssText = `
               border: 1px solid black;
               padding: 8px;
               text-align: center;
           `;
       }
   });

   // Append table to container
   mathTableContainer.appendChild(mathTable);

   // Update calculations with function validation
   if (typeof updateMathTableCalculations === 'function') {
       updateMathTableCalculations();
   } else {
       console.warn('createAndUpdateMathTable: updateMathTableCalculations function not available');
   }
}

function updateMathTableCalculations() {
   // Validate required elements and functions
   const mathTable = document.querySelector('#mathTableContainer table');
   if (!mathTable) {
       console.error('updateMathTableCalculations: Math table not found');
       return;
   }

   const cptSelect = document.getElementById('cptSelect');
   if (!cptSelect) {
       console.error('updateMathTableCalculations: CPT select element not found');
       return;
   }

   const currentCPT = cptSelect.value;
   if (!currentCPT) {
       console.warn('updateMathTableCalculations: No CPT selected');
       return;
   }

   // Get data with function validation
   const allCoraData = typeof getCORAData === 'function' ? getCORAData() : null;
   const atropsData = typeof getATROPSData === 'function' ? getATROPSData(currentCPT) : null;

   const multiplier = parseFloat(localStorage.getItem('planningRiskMultiplier') || '1.1');

   // Validate table structure
   if (mathTable.rows.length < 5) {
       console.error('updateMathTableCalculations: Math table does not have enough rows');
       return;
   }

   let coraSet1Value, coraSet2Value, coraSet3Value, atropsSet1Value, atropsSet2Value, atropsSet3Value;

   // CORA Set 1 calculation
   const coraRow = mathTable.rows[1];
   if (!coraRow || !coraRow.cells || coraRow.cells.length < 5) {
       console.error('updateMathTableCalculations: Invalid CORA row structure');
       return;
   }

   if (allCoraData && allCoraData[currentCPT]) {
       const columnE = allCoraData[currentCPT].columnE || 0;
       const currentBacklog = allCoraData[currentCPT].currentBacklog || 0;

       coraSet1Value = columnE - currentBacklog;
       coraRow.cells[1].textContent = `${columnE} - ${currentBacklog} = ${coraSet1Value.toFixed(2)}`;
   } else {
       console.error('updateMathTableCalculations: CORA data not available for CPT:', currentCPT);
       coraRow.cells[1].textContent = 'Data not available';
   }

   // ATROPS calculations
   const atropsRow = mathTable.rows[2];
   if (!atropsRow || !atropsRow.cells || atropsRow.cells.length < 5) {
       console.error('updateMathTableCalculations: Invalid ATROPS row structure');
       return;
   }

   if (atropsData && allCoraData && allCoraData[currentCPT]) {
       const cap = parseFloat(atropsData.cap) || 0;
       const percentSchedule = parseFloat(atropsData.percentSchedule) || 0;
       const currentBacklog = allCoraData[currentCPT].currentBacklog || 0;

       // ATROPS Set 1
       atropsSet1Value = cap * Math.max(0, (1 - percentSchedule/100)) * 1.6;
       atropsRow.cells[1].textContent = `${cap} * max(0, (1 - ${(percentSchedule/100).toFixed(2)})) * 1.6 = ${atropsSet1Value.toFixed(2)}`;

       // ATROPS Set 2
       if (percentSchedule > 100) {
           atropsSet2Value = allCoraData[currentCPT].columnD || atropsSet1Value;
       } else {
           atropsSet2Value = atropsSet1Value;
       }
       atropsRow.cells[2].textContent = `${percentSchedule} > 100% ? ${atropsSet2Value.toFixed(2)} : ${atropsSet1Value.toFixed(2)}`;

       // ATROPS Set 3
       atropsSet3Value = atropsSet2Value + currentBacklog;
       atropsRow.cells[3].textContent = `${atropsSet2Value.toFixed(2)} + ${currentBacklog} = ${atropsSet3Value.toFixed(2)}`;
   } else {
       console.error('updateMathTableCalculations: ATROPS or CORA data not available for CPT:', currentCPT);
       atropsRow.cells[1].textContent = 'Data not available';
       atropsRow.cells[2].textContent = 'Data not available';
       atropsRow.cells[3].textContent = 'Data not available';
   }

   // CORA Set 2 and Set 3 Calculations
   if (allCoraData && allCoraData[currentCPT] && atropsData &&
       coraSet1Value !== undefined && atropsSet1Value !== undefined) {

       const columnE = allCoraData[currentCPT].columnE || 0;
       const currentBacklog = allCoraData[currentCPT].currentBacklog || 0;

       if (atropsSet1Value > coraSet1Value) {
           coraSet2Value = columnE;
       } else {
           coraSet2Value = currentBacklog + atropsSet1Value;
       }

       coraRow.cells[2].textContent = `${atropsSet1Value.toFixed(2)} > ${coraSet1Value.toFixed(2)} ? ${columnE} : ${currentBacklog} + ${atropsSet1Value.toFixed(2)} = ${coraSet2Value.toFixed(2)}`;

       coraSet3Value = coraSet2Value;
       coraRow.cells[3].textContent = `${coraSet2Value.toFixed(2)} = ${coraSet3Value.toFixed(2)}`;

       // Mixed calculations
       const mixedRow = mathTable.rows[3];
       if (mixedRow && mixedRow.cells && mixedRow.cells.length >= 5 && atropsSet3Value !== undefined) {
           const mixedSet3Value = (coraSet3Value + atropsSet3Value) / 2;
           mixedRow.cells[3].textContent = `(${coraSet3Value.toFixed(2)} + ${atropsSet3Value.toFixed(2)}) / 2 = ${mixedSet3Value.toFixed(2)}`;

           // Calculate Set 4 values
           const coraSet4Value = Math.ceil(coraSet3Value * multiplier);
           coraRow.cells[4].textContent = `${coraSet4Value}`;

           const atropsSet4Value = Math.ceil(atropsSet3Value * multiplier);
           atropsRow.cells[4].textContent = `${atropsSet4Value}`;

           const mixedSet4Value = Math.ceil(mixedSet3Value * multiplier);
           mixedRow.cells[4].textContent = `${mixedSet4Value}`;

           // Low Backlog Set 4
           const lowBacklogRow = mathTable.rows[4];
           if (lowBacklogRow && lowBacklogRow.cells && lowBacklogRow.cells.length >= 5) {
               const lowBacklogSet4Value = typeof getRodeoTotalValue === 'function' ? getRodeoTotalValue() : 0;
               lowBacklogRow.cells[4].textContent = `${lowBacklogSet4Value}`;

               // Risk Model Selection
               const riskModel = localStorage.getItem('riskModel') || 'MIXED';
               let selectedSet4Value;

               switch(riskModel) {
                   case 'CORA':
                       selectedSet4Value = coraSet4Value;
                       break;
                   case 'ATROPS':
                       selectedSet4Value = atropsSet4Value;
                       break;
                   case 'MIXED':
                       selectedSet4Value = mixedSet4Value;
                       break;
                   case 'Low Backlog':
                       selectedSet4Value = lowBacklogSet4Value;
                       break;
                   default:
                       selectedSet4Value = mixedSet4Value;
               }

               // Add or update the selected risk model row
               let selectedRiskRow = mathTable.rows[5];
               if (!selectedRiskRow) {
                   selectedRiskRow = mathTable.insertRow(-1);
               }

               // Create or update cells
               if (!selectedRiskRow.cells[0]) {
                   selectedRiskRow.insertCell(0);
               }
               selectedRiskRow.cells[0].textContent = `Selected Risk Model (${riskModel})`;
               selectedRiskRow.cells[0].style.cssText = `
                   font-weight: bold;
                   border: 1px solid black;
                   padding: 5px;
               `;

               if (!selectedRiskRow.cells[1]) {
                   selectedRiskRow.insertCell(1);
               }
               selectedRiskRow.cells[1].textContent = selectedSet4Value;
               selectedRiskRow.cells[1].style.cssText = `
                   border: 1px solid black;
                   padding: 5px;
               `;
               selectedRiskRow.cells[1].colSpan = 4;
           }
       }
   } else {
       console.error('updateMathTableCalculations: Insufficient data for complete calculations');

       // Set fallback values for missing data
       ['Data not available', 'Data not available', 'Data not available'].forEach((text, index) => {
           if (coraRow.cells[index + 2]) coraRow.cells[index + 2].textContent = text;
           if (atropsRow.cells[index + 2]) atropsRow.cells[index + 2].textContent = text;
           if (mathTable.rows[3] && mathTable.rows[3].cells[index + 2]) {
               mathTable.rows[3].cells[index + 2].textContent = text;
           }
       });
   }
}

function getSelectedRiskModelValue() {
   // Validate math table exists
   const mathTable = document.querySelector('#mathTableContainer table');
   if (!mathTable || !mathTable.rows) {
       console.error('getSelectedRiskModelValue: Math table not found or has no rows');
       return null;
   }

   // Get risk model from localStorage with validation
   const riskModel = localStorage.getItem('riskModel') || 'MIXED';

   // Find the risk model row with better validation
   const riskRow = Array.from(mathTable.rows).find(row => {
       return row.cells &&
              row.cells[0] &&
              row.cells[0].textContent &&
              row.cells[0].textContent.includes(riskModel);
   });

   if (!riskRow) {
       console.error(`getSelectedRiskModelValue: Row for risk model "${riskModel}" not found in math table`);
       return null;
   }

   // Validate row has enough cells
   if (!riskRow.cells || riskRow.cells.length < 5) {
       console.error(`getSelectedRiskModelValue: Risk model row for "${riskModel}" has insufficient cells`);
       return null;
   }

   // Get and validate the value from Set 4 column
   const cellText = riskRow.cells[4].textContent;
   if (!cellText || cellText.trim() === '') {
       console.error(`getSelectedRiskModelValue: Empty value in Set 4 column for risk model "${riskModel}"`);
       return null;
   }

   const value = parseInt(cellText.trim());
   if (isNaN(value)) {
       console.error(`getSelectedRiskModelValue: Invalid risk model value for "${riskModel}":`, cellText);
       return null;
   }

   // Validate the value is reasonable (positive number)
   if (value < 0) {
       console.warn(`getSelectedRiskModelValue: Risk model value is negative for "${riskModel}":`, value);
       return null;
   }

   return value;
}

function updatePickRebinPackRecommendations() {
   const tables = ['productionGraphic', 'nextCPTProductionGraphicTable'];

   tables.forEach(async (tableId) => {
       try {
           // Validate required elements
           const productionTable = document.getElementById(tableId);
           const scheduleTable = tableId === 'productionGraphic' ?
               document.querySelector('#SelectedCPTSchedule') :
               document.querySelector('#NextCPTSchedule');

           if (!scheduleTable || !productionTable) {
               console.error(`updatePickRebinPackRecommendations: Required tables not found for ${tableId}`);
               return;
           }

           // Get risk model value with function validation
           const riskModelValue = tableId === 'productionGraphic' ?
               (typeof getSelectedRiskModelValue === 'function' ? getSelectedRiskModelValue() : null) :
               (typeof getNextCPTMixedSet4Value === 'function' ? getNextCPTMixedSet4Value() : null);

           if (!riskModelValue) {
               console.warn(`updatePickRebinPackRecommendations: Risk model value not found for ${tableId}`);
               return;
           }

           // Get production windows with validation
           const productionWindows = typeof getProductionWindows === 'function' ?
               getProductionWindows(scheduleTable) : [];

           if (productionWindows.length === 0) {
               console.warn(`updatePickRebinPackRecommendations: No production windows found for ${tableId}`);
               return;
           }

           // Get CPT time with validation
           let cptTime;
           if (tableId === 'productionGraphic') {
               const cptSelect = document.getElementById('cptSelect');
               if (!cptSelect) {
                   console.error(`updatePickRebinPackRecommendations: CPT select element not found`);
                   return;
               }
               cptTime = cptSelect.value;
           } else {
               const cptSelect = document.getElementById('cptSelect');
               if (!cptSelect || typeof getNextCPT !== 'function') {
                   console.error(`updatePickRebinPackRecommendations: Required elements/functions not found for next CPT`);
                   return;
               }
               cptTime = getNextCPT(cptSelect.value);
           }

           if (!cptTime) {
               console.warn(`updatePickRebinPackRecommendations: CPT time not available for ${tableId}`);
               return;
           }

           // Get Pick2Rebin Pack row with validation
           if (typeof getPickRebinPackRow !== 'function') {
               console.error(`updatePickRebinPackRecommendations: getPickRebinPackRow function not available`);
               return;
           }

           const pickRebinPackRow = await getPickRebinPackRow(productionTable);
           if (!pickRebinPackRow) {
               console.error(`updatePickRebinPackRecommendations: Pick2Rebin Pack row not found for ${tableId}`);
               return;
           }

           // Get expected rates with validation
           const expectedRates = typeof getExpectedRates === 'function' ?
               getExpectedRates(productionTable, pickRebinPackRow, productionWindows) : [];

           if (expectedRates.length === 0) {
               console.warn(`updatePickRebinPackRecommendations: No expected rates found for ${tableId}`);
               return;
           }

           if (productionWindows.length !== expectedRates.length) {
               console.warn(`updatePickRebinPackRecommendations: Mismatch between production windows (${productionWindows.length}) and expected rates (${expectedRates.length}) for ${tableId}`);
           }

           // Calculate recommendations with validation
           const recommendations = typeof calculateHCRecommendations === 'function' ?
               calculateHCRecommendations(riskModelValue, productionWindows, expectedRates, {}, cptTime) : null;

           if (!recommendations) {
               console.error(`updatePickRebinPackRecommendations: Failed to calculate recommendations for ${tableId}`);
               return;
           }

           // Update UI with function validation
           if (typeof updatePickRebinPackRow === 'function') {
               updatePickRebinPackRow(pickRebinPackRow, recommendations);
           }

           if (typeof addManualOverrideListeners === 'function') {
               addManualOverrideListeners(pickRebinPackRow);
           }

           if (typeof updatePickHCBasedOnPackHC === 'function') {
               updatePickHCBasedOnPackHC(productionTable);
           }

       } catch (error) {
           console.error(`updatePickRebinPackRecommendations: Error processing ${tableId}:`, error);
       }
   });

   // Update summary and risk model with function validation
   const summaryFunctions = ['updatePlanSummary1', 'updatePlanSummary2', 'updateRiskModelBasedOnTime'];
   summaryFunctions.forEach(funcName => {
       if (typeof window[funcName] === 'function') {
           window[funcName]();
       } else {
           console.warn(`updatePickRebinPackRecommendations: Function "${funcName}" not available`);
       }
   });
}


function getProductionWindows(scheduleTable) {
   // Validate schedule table parameter
   if (!scheduleTable || !scheduleTable.rows) {
       console.error('getProductionWindows: Invalid schedule table provided');
       return [];
   }

   // Validate table structure
   if (scheduleTable.rows.length < 3) {
       console.error('getProductionWindows: Schedule table must have at least 3 rows (time, duration, block type)');
       return [];
   }

   const timeRow = scheduleTable.rows[0];
   const durationRow = scheduleTable.rows[1];
   const blockTypeRow = scheduleTable.rows[2];

   // Validate row structure
   if (!timeRow.cells || !durationRow.cells || !blockTypeRow.cells) {
       console.error('getProductionWindows: One or more table rows have no cells');
       return [];
   }

   // Ensure all rows have the same number of cells
   const cellCount = timeRow.cells.length;
   if (durationRow.cells.length !== cellCount || blockTypeRow.cells.length !== cellCount) {
       console.warn('getProductionWindows: Inconsistent cell count across table rows');
   }

   const windows = [];
   const maxCells = Math.min(cellCount, durationRow.cells.length, blockTypeRow.cells.length);

   for (let i = 0; i < maxCells; i++) {
       // Validate cells exist
       if (!timeRow.cells[i] || !durationRow.cells[i] || !blockTypeRow.cells[i]) {
           console.warn(`getProductionWindows: Missing cell at column ${i}, skipping`);
           continue;
       }

       const blockType = blockTypeRow.cells[i].textContent.trim();
       const timeWindow = timeRow.cells[i].textContent.trim();
       const durationText = durationRow.cells[i].textContent.trim();

       // Only process Production blocks
       if (blockType === 'Production') {
           if (!timeWindow || !durationText) {
               console.warn(`getProductionWindows: Empty time window or duration at column ${i}, skipping`);
               continue;
           }

           let durationInHours;

           if (durationText.includes('left in block')) {
               // Handle "HH:MM left in block" format
               const timeMatch = durationText.match(/(\d{1,2}):(\d{2})/);
               if (timeMatch) {
                   const hours = parseInt(timeMatch[1]);
                   const minutes = parseInt(timeMatch[2]);

                   if (!isNaN(hours) && !isNaN(minutes) && minutes >= 0 && minutes < 60) {
                       durationInHours = hours + minutes / 60;
                   } else {
                       console.warn(`getProductionWindows: Invalid time format in column ${i}: ${durationText}`);
                       continue;
                   }
               } else {
                   console.warn(`getProductionWindows: Could not parse time format in column ${i}: ${durationText}`);
                   continue;
               }
           } else if (durationText.includes('minutes')) {
               // Handle "X minutes" format
               const minuteMatch = durationText.match(/(\d+)\s*minutes?/);
               if (minuteMatch) {
                   const minutes = parseInt(minuteMatch[1]);
                   if (!isNaN(minutes) && minutes >= 0) {
                       durationInHours = minutes / 60;
                   } else {
                       console.warn(`getProductionWindows: Invalid minutes value in column ${i}: ${durationText}`);
                       continue;
                   }
               } else {
                   console.warn(`getProductionWindows: Could not parse minutes format in column ${i}: ${durationText}`);
                   continue;
               }
           } else {
               console.warn(`getProductionWindows: Unexpected duration format in column ${i}: ${durationText}`);
               continue;
           }

           // Validate duration is reasonable
           if (durationInHours <= 0 || durationInHours > 24) {
               console.warn(`getProductionWindows: Duration seems unreasonable in column ${i}: ${durationInHours} hours`);
               continue;
           }

           windows.push({ timeWindow, durationInHours });
           console.log(`getProductionWindows: Production window added: ${timeWindow}, duration: ${durationInHours.toFixed(2)} hours`);
       }
   }

   console.log(`getProductionWindows: Total production windows found: ${windows.length}`);

   // Update plan summary with function validation
   if (typeof updatePlanSummary1 === 'function') {
       updatePlanSummary1();
   } else {
       console.warn('getProductionWindows: updatePlanSummary1 function not available');
   }

   return windows;
}

function getPickRebinPackRow(productionTable, retries = 5) {
   // Validate input parameters
   if (!productionTable) {
       console.error('getPickRebinPackRow: Production table parameter is required');
       return Promise.reject('Invalid table parameter');
   }

   if (!productionTable.rows) {
       console.error('getPickRebinPackRow: Production table has no rows');
       return Promise.reject('Table has no rows');
   }

   if (typeof retries !== 'number' || retries < 0) {
       console.warn('getPickRebinPackRow: Invalid retries parameter, using default value of 5');
       retries = 5;
   }

   console.log("getPickRebinPackRow: Attempting to find Pick2Rebin Pack row");
   console.log("getPickRebinPackRow: Production table rows:", productionTable.rows.length);

   return new Promise((resolve, reject) => {
       function findRow() {
           for (let i = 0; i < productionTable.rows.length; i++) {
               const row = productionTable.rows[i];

               // Validate row structure
               if (!row || !row.cells || !row.cells[0]) {
                   console.warn(`getPickRebinPackRow: Row ${i} has invalid structure, skipping`);
                   continue;
               }

               const firstCellContent = row.cells[0].textContent.trim();
               console.log(`getPickRebinPackRow: Row ${i} first cell content: "${firstCellContent}"`);

               // Check for Pick2Rebin Pack with arrow prefix handling
               if (firstCellContent.includes('Pick2Rebin Pack') ||
                   firstCellContent.replace(/^[‚ñº‚ñ∂]\s*/, '').trim() === 'Pick2Rebin Pack') {
                   console.log("getPickRebinPackRow: Pick2Rebin Pack row found at index:", i);
                   resolve(row);
                   return;
               }
           }

           // Row not found - handle retries
           if (retries > 0) {
               console.log(`getPickRebinPackRow: Pick2Rebin Pack row not found. Retrying... (${retries} attempts left)`);
               setTimeout(() => {
                   retries--;
                   findRow();
               }, 1000);
           } else {
               console.error('getPickRebinPackRow: Pick2Rebin Pack row not found after multiple attempts');

               // Log table structure for debugging (safely)
               try {
                   const rowInfo = Array.from(productionTable.rows).map((row, index) => {
                       const firstCell = row.cells && row.cells[0] ? row.cells[0].textContent.trim() : 'No content';
                       return `Row ${index}: "${firstCell}"`;
                   }).join(', ');
                   console.log("getPickRebinPackRow: Available rows:", rowInfo);
               } catch (error) {
                   console.error('getPickRebinPackRow: Error logging table structure:', error);
               }

               reject(new Error('Pick2Rebin Pack row not found after maximum retries'));
           }
       }

       findRow();
   });
}

function getExpectedRates(productionTable, pickRebinPackRow, productionWindows) {
   // Validate input parameters
   if (!productionTable) {
       console.error('getExpectedRates: Production table parameter is required');
       return [];
   }

   if (!pickRebinPackRow) {
       console.error('getExpectedRates: Pick2Rebin Pack row parameter is required');
       return [];
   }

   if (!Array.isArray(productionWindows)) {
       console.error('getExpectedRates: Production windows must be an array');
       return [];
   }

   // Find the rate row (next sibling of Pick2Rebin Pack row)
   const rateRow = pickRebinPackRow.nextElementSibling;
   if (!rateRow) {
       console.error("getExpectedRates: Expected rate row not found after Pick2Rebin Pack row");
       return [];
   }

   // Validate rate row structure
   if (!rateRow.cells) {
       console.error("getExpectedRates: Rate row has no cells");
       return [];
   }

   // Verify this is actually the expected rate row
   const firstCellContent = rateRow.cells[0] ? rateRow.cells[0].textContent.trim() : '';
   if (!firstCellContent.includes('Expected Rate')) {
       console.warn("getExpectedRates: Next row doesn't appear to be the expected rate row. First cell content:", firstCellContent);
   }

   console.log("getExpectedRates: Number of production windows:", productionWindows.length);
   console.log("getExpectedRates: Rate row has", rateRow.cells.length, "cells");

   const rates = [];

   // Process each production window (skip first cell which is the label)
   for (let i = 1; i <= productionWindows.length; i++) {
       // Validate cell exists
       if (i >= rateRow.cells.length) {
           console.warn(`getExpectedRates: Rate cell ${i} not found, using default rate of 0`);
           rates.push(0);
           continue;
       }

       const rateCell = rateRow.cells[i];
       if (!rateCell) {
           console.warn(`getExpectedRates: Rate cell ${i} is null, using default rate of 0`);
           rates.push(0);
           continue;
       }

       const rateContent = rateCell.textContent.trim();
       if (!rateContent) {
           console.warn(`getExpectedRates: Empty rate content at index ${i}, using default rate of 0`);
           rates.push(0);
           continue;
       }

       const rate = parseFloat(rateContent);
       if (isNaN(rate)) {
           console.warn(`getExpectedRates: Invalid rate found at index ${i}: "${rateContent}", using default rate of 0`);
           rates.push(0);
       } else if (rate < 0) {
           console.warn(`getExpectedRates: Negative rate found at index ${i}: ${rate}, using default rate of 0`);
           rates.push(0);
       } else {
           rates.push(rate);
       }

       console.log(`getExpectedRates: Rate for production window ${i}: ${rates[rates.length - 1]}`);
   }

   // Validate we have the expected number of rates
   if (rates.length !== productionWindows.length) {
       console.warn(`getExpectedRates: Mismatch between production windows (${productionWindows.length}) and extracted rates (${rates.length})`);
   }

   console.log("getExpectedRates: Expected Rates:", rates);
   return rates;
}

function getMaxWalls() {
   const maxWallsSelect = document.getElementById('maxWalls');

   if (!maxWallsSelect) {
       console.warn('getMaxWalls: Max walls select element not found, returning Infinity as default');
       return Infinity;
   }

   const value = maxWallsSelect.value;
   if (!value || value.trim() === '') {
       console.warn('getMaxWalls: Max walls select has no value, returning Infinity as default');
       return Infinity;
   }

   const parsedValue = parseInt(value, 10);
   if (isNaN(parsedValue)) {
       console.warn(`getMaxWalls: Invalid max walls value "${value}", returning Infinity as default`);
       return Infinity;
   }

   if (parsedValue < 0) {
       console.warn(`getMaxWalls: Negative max walls value ${parsedValue}, returning 0`);
       return 0;
   }

   return parsedValue;
}

function calculateHCRecommendations(riskModelValue, productionWindows, expectedRates, userOverrides = {}, cptTime) {
   // Validate input parameters
   if (!riskModelValue || riskModelValue <= 0) {
       console.error('calculateHCRecommendations: Invalid risk model value provided');
       return [];
   }

   if (!Array.isArray(productionWindows) || productionWindows.length === 0) {
       console.error('calculateHCRecommendations: Production windows must be a non-empty array');
       return [];
   }

   if (!Array.isArray(expectedRates) || expectedRates.length === 0) {
       console.error('calculateHCRecommendations: Expected rates must be a non-empty array');
       return [];
   }

   if (productionWindows.length !== expectedRates.length) {
       console.error('calculateHCRecommendations: Production windows and expected rates arrays must have the same length');
       return [];
   }

   if (!cptTime || typeof cptTime !== 'string') {
       console.error('calculateHCRecommendations: Valid CPT time is required');
       return [];
   }

   console.log("-------- Starting HC Recommendations Calculation --------");
   console.log("calculateHCRecommendations: Risk Model Value (Total Units to Process):", riskModelValue);
   console.log("calculateHCRecommendations: Production Windows:", productionWindows);
   console.log("calculateHCRecommendations: Expected Rates:", expectedRates);
   console.log("calculateHCRecommendations: User Overrides:", userOverrides);
   console.log("calculateHCRecommendations: CPT Time:", cptTime);

   let totalCapacity = 0;
   let totalOverrideCapacity = 0;
   let totalTimeUsed = 0;

   // Validate required functions exist
   if (typeof convertToMinutesSinceMidnight !== 'function') {
       console.error('calculateHCRecommendations: convertToMinutesSinceMidnight function not available');
       return [];
   }

   if (typeof getMaxWalls !== 'function') {
       console.error('calculateHCRecommendations: getMaxWalls function not available');
       return [];
   }

   const cptMinutes = convertToMinutesSinceMidnight(cptTime);
   if (cptMinutes === null || isNaN(cptMinutes)) {
       console.error('calculateHCRecommendations: Invalid CPT time conversion result');
       return [];
   }

   const maxWalls = getMaxWalls();
   console.log("calculateHCRecommendations: Max Walls:", maxWalls);

   // Calculate total capacity and override capacity
   for (let i = 0; i < productionWindows.length; i++) {
       const window = productionWindows[i];
       if (!window || typeof window.timeWindow !== 'string' || typeof window.durationInHours !== 'number') {
           console.warn(`calculateHCRecommendations: Invalid production window at index ${i}, skipping`);
           continue;
       }

       let { timeWindow, durationInHours } = window;
       const rate = expectedRates[i];

       if (isNaN(rate) || rate < 0) {
           console.warn(`calculateHCRecommendations: Invalid rate at index ${i}: ${rate}, using 0`);
           expectedRates[i] = 0;
       }

       console.log(`\ncalculateHCRecommendations: Processing window ${i + 1}: ${timeWindow}`);
       console.log(`calculateHCRecommendations: Original duration: ${durationInHours} hours`);

       // Validate time window format
       if (!timeWindow.includes(' to ')) {
           console.warn(`calculateHCRecommendations: Invalid time window format at index ${i}: ${timeWindow}, skipping`);
           continue;
       }

       const [startTime, endTime] = timeWindow.split(' to ');
       if (!startTime || !endTime) {
           console.warn(`calculateHCRecommendations: Invalid time window parts at index ${i}, skipping`);
           continue;
       }

       const startMinutes = convertToMinutesSinceMidnight(startTime);
       let endMinutes = convertToMinutesSinceMidnight(endTime);

       if (startMinutes === null || endMinutes === null || isNaN(startMinutes) || isNaN(endMinutes)) {
           console.warn(`calculateHCRecommendations: Invalid time conversion at index ${i}, skipping`);
           continue;
       }

       // Adjust if the window crosses midnight
       if (endMinutes < startMinutes) endMinutes += 24 * 60;

       // Adjust if CPT is on the next day
       let adjustedCptMinutes = cptMinutes;
       if (cptMinutes < startMinutes) adjustedCptMinutes += 24 * 60;

       // Adjust duration if it's the last window or if CPT falls within this window
       if (i === productionWindows.length - 1 || adjustedCptMinutes <= endMinutes) {
           if (adjustedCptMinutes < endMinutes) {
               durationInHours = Math.max(0, (adjustedCptMinutes - startMinutes) / 60);
           } else {
               durationInHours = Math.max(0, (endMinutes - startMinutes) / 60);
           }
           console.log(`calculateHCRecommendations: Adjusted window duration: ${durationInHours} hours`);
       }

       totalTimeUsed += durationInHours;
       const windowCapacity = expectedRates[i] * durationInHours;

       // Validate user overrides
       if (i in userOverrides) {
           const overrideValue = userOverrides[i];
           if (typeof overrideValue === 'number' && overrideValue >= 0) {
               totalOverrideCapacity += Math.min(overrideValue, maxWalls) * windowCapacity;
           } else {
               console.warn(`calculateHCRecommendations: Invalid user override at index ${i}: ${overrideValue}, ignoring`);
               totalCapacity += windowCapacity;
           }
       } else {
           totalCapacity += windowCapacity;
       }

       console.log(`calculateHCRecommendations: Window ${i + 1} capacity: ${windowCapacity}`);
       console.log(`calculateHCRecommendations: Total capacity so far: ${totalCapacity}`);
       console.log(`calculateHCRecommendations: Total override capacity so far: ${totalOverrideCapacity}`);

       // Stop processing if we've reached or passed the CPT
       if (adjustedCptMinutes <= endMinutes) break;
   }

   console.log("\ncalculateHCRecommendations: ----- Summary -----");
   console.log("calculateHCRecommendations: Total time used for calculations:", totalTimeUsed, "hours");
   console.log("calculateHCRecommendations: Total Override Capacity:", totalOverrideCapacity);
   console.log("calculateHCRecommendations: Remaining Capacity Needed:", Math.max(0, riskModelValue - totalOverrideCapacity));
   console.log("calculateHCRecommendations: Total Available Capacity (non-overridden):", totalCapacity);

   // Prevent division by zero
   if (totalCapacity <= 0) {
       console.warn('calculateHCRecommendations: Total capacity is zero or negative, returning minimum recommendations');
       return productionWindows.map(() => 1);
   }

   // Calculate X (stable HC for non-overridden windows)
   let X = Math.ceil((riskModelValue - totalOverrideCapacity) / totalCapacity);
   X = Math.max(1, Math.min(X, maxWalls)); // Ensure X is between 1 and maxWalls

   console.log("calculateHCRecommendations: Initial Calculated Stable HC (X):", X);

   // Calculate total planned volume with safety checks
   let totalPlannedVolume = totalOverrideCapacity;
   for (let i = 0; i < productionWindows.length; i++) {
       if (!(i in userOverrides) && i < expectedRates.length && i < productionWindows.length) {
           const rate = expectedRates[i] || 0;
           const duration = productionWindows[i].durationInHours || 0;
           totalPlannedVolume += X * rate * duration;
       }
   }

   // Increase X if total planned volume is less than risk model value
   let iterations = 0;
   const maxIterations = maxWalls; // Prevent infinite loops

   while (totalPlannedVolume < riskModelValue && X < maxWalls && iterations < maxIterations) {
       X++;
       totalPlannedVolume = totalOverrideCapacity;

       for (let i = 0; i < productionWindows.length; i++) {
           if (!(i in userOverrides) && i < expectedRates.length && i < productionWindows.length) {
               const rate = expectedRates[i] || 0;
               const duration = productionWindows[i].durationInHours || 0;
               totalPlannedVolume += X * rate * duration;
           }
       }
       iterations++;
   }

   console.log("calculateHCRecommendations: Final Calculated Stable HC (X):", X);
   console.log("calculateHCRecommendations: Total Planned Volume:", totalPlannedVolume);

   // Apply X to all non-overridden windows
   const recommendations = productionWindows.map((_, i) => {
       if (i in userOverrides) {
           const overrideValue = userOverrides[i];
           if (typeof overrideValue === 'number' && overrideValue >= 0) {
               return Math.min(overrideValue, maxWalls);
           } else {
               console.warn(`calculateHCRecommendations: Invalid override value at index ${i}, using calculated value`);
               return X;
           }
       } else {
           return X;
       }
   });

   console.log("calculateHCRecommendations: Final Recommendations:", recommendations);
   console.log("calculateHCRecommendations: -------- End of HC Recommendations Calculation --------");

   return recommendations;
}


function convertTo12HourFormat(time24) {
    const [hours, minutes] = time24.split(':').map(Number);
    const period = hours >= 12 ? 'PM' : 'AM';
    const hours12 = hours % 12 || 12;
    return `${hours12.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} ${period}`;
}

function isTimeBefore(time1, time2) {
    const [t1, p1] = time1.split(' ');
    const [t2, p2] = time2.split(' ');
    const [h1, m1] = t1.split(':').map(Number);
    const [h2, m2] = t2.split(':').map(Number);

    if (p1 !== p2) return p1 === 'AM';
    if (h1 !== h2) return h1 < h2;
    return m1 < m2;
}

function calculateTimeDifference(startTime, endTime) {
    const [start, startPeriod] = startTime.split(' ');
    const [end, endPeriod] = endTime.split(' ');
    const [startHour, startMinute] = start.split(':').map(Number);
    const [endHour, endMinute] = end.split(':').map(Number);

    let hourDiff = endHour - startHour;
    let minuteDiff = endMinute - startMinute;

    if (startPeriod !== endPeriod) hourDiff += 12;
    if (minuteDiff < 0) {
        hourDiff--;
        minuteDiff += 60;
    }

    return hourDiff + minuteDiff / 60;
}
function updatePickRebinPackRow(pickRebinPackRow, recommendations, userOverrides = {}) {
    console.log("Updating Pick2Rebin Pack Row");
    console.log("Recommendations:", recommendations);
    console.log("User Overrides:", userOverrides);

    const maxWalls = getMaxWalls();

    for (let i = 0; i < recommendations.length; i++) {
        const cell = pickRebinPackRow.cells[i + 1]; // +1 to skip the first cell (row header)

        if (i in userOverrides) {
            // Preserve user override, but cap it at ma maxWalls
            cell.textContent = Math.min(userOverrides[i], maxWalls);
            cell.style.backgroundColor = 'pink';
            cell.dataset.userOverride = 'true';
        } else {
            // Update with new recommendation
            const recommendedHC = Math.min(recommendations[i], maxWalls);
            cell.textContent = recommendedHC;
            cell.style.backgroundColor = '';
            cell.dataset.userOverride = 'false';
        }

        cell.dataset.recommended = Math.min(recommendations[i], maxWalls);

        console.log(`Updated cell ${i + 1}: ${cell.textContent} (Override: ${i in userOverrides})`);
    }
}

function addManualOverrideListeners(row) {
   // Validate input parameter
   if (!row) {
       console.error('addManualOverrideListeners: Row parameter is required');
       return;
   }

   // Check if listeners already added to prevent duplicates
   if (row.dataset.listenersAdded) {
       return;
   }

   // Validate row structure
   if (!row.cells || !row.cells[0]) {
       console.error('addManualOverrideListeners: Row has invalid structure');
       return;
   }

   const rowName = row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '');

   // Only add listeners for Pick2Rebin rows
   if (rowName === 'Pick2Rebin Pick' || rowName === 'Pick2Rebin Pack') {
       // Validate handleCellClick function exists
       if (typeof handleCellClick !== 'function') {
           console.error('addManualOverrideListeners: handleCellClick function not available');
           return;
       }

       // Add listeners to HC cells (skip first cell which is the row name)
       for (let i = 1; i < row.cells.length; i++) {
           const cell = row.cells[i];
           if (cell) {
               // Remove existing listener to prevent duplicates
               cell.removeEventListener('click', handleCellClick);
               // Add new listener
               cell.addEventListener('click', handleCellClick);
               cell.style.cursor = 'pointer';
           } else {
               console.warn(`addManualOverrideListeners: Cell ${i} not found in row "${rowName}"`);
           }
       }

       // Add listeners to rate cells in the next row (Expected Rate row)
       const rateRow = row.nextElementSibling;
       if (rateRow && rateRow.cells && rateRow.cells[0]) {
           const rateRowName = rateRow.cells[0].textContent.trim();

           if (rateRowName === 'Expected Rate') {
               // Add listeners to rate cells (skip first cell which is the label)
               for (let i = 1; i < rateRow.cells.length; i++) {
                   const rateCell = rateRow.cells[i];
                   if (rateCell) {
                       // Remove existing listener to prevent duplicates
                       rateCell.removeEventListener('click', handleCellClick);
                       // Add new listener
                       rateCell.addEventListener('click', handleCellClick);
                       rateCell.style.cursor = 'pointer';
                   } else {
                       console.warn(`addManualOverrideListeners: Rate cell ${i} not found in Expected Rate row`);
                   }
               }
           } else {
               console.warn(`addManualOverrideListeners: Expected "Expected Rate" row but found "${rateRowName}"`);
           }
       } else {
           console.warn(`addManualOverrideListeners: Expected Rate row not found or has invalid structure for row "${rowName}"`);
       }
   } else {
       console.log(`addManualOverrideListeners: Skipping non-Pick2Rebin row: "${rowName}"`);
   }

   // Mark listeners as added
   row.dataset.listenersAdded = 'true';
}

function handleManualOverride(event) {
    const cell = event.target;
    const newValue = cell.textContent.trim();
    const row = cell.parentElement;
    const isVNAPack = row.cells[0].textContent.trim() === 'VNA Pack';

    console.log('Handling manual override:', isVNAPack ? 'VNA Pack' : 'Other', 'New value:', newValue);

    const maxWalls = getMaxWalls();

    if (newValue.toUpperCase() === 'R' || isNaN(parseFloat(newValue)) || parseFloat(newValue) < 1) {
        cell.dataset.userOverride = 'false';
        cell.style.backgroundColor = '';
    } else {
        const cappedValue = Math.min(parseFloat(newValue), maxWalls);
        cell.textContent = cappedValue;
        cell.dataset.userOverride = 'true';
        cell.style.backgroundColor = 'pink';
    }

    const productionTable = row.closest('table');
    const scheduleTable = document.querySelector('#SelectedCPTSchedule') || document.querySelector('#NextCPTSchedule');
    const productionWindows = getProductionWindows(scheduleTable);
    const expectedRates = getExpectedRates(productionTable, row, productionWindows);
    const cptTime = document.getElementById('cptSelect').value;

    const userOverrides = {};
    for (let i = 1; i < row.cells.length; i++) {
        const overrideCell = row.cells[i];
        if (overrideCell.dataset.userOverride === 'true') {
            userOverrides[i - 1] = parseFloat(overrideCell.textContent);
        }
    }

    console.log('User Overrides:', userOverrides);

    const riskModelValue = isVNAPack ?
        (parseInt(document.body.dataset.orderPickVNATotal) || 0) :
        getSelectedRiskModelValue();
    console.log('Risk Model Value:', riskModelValue);

    const newRecommendations = calculateHCRecommendations(riskModelValue, productionWindows, expectedRates, userOverrides, cptTime);
    console.log('New Recommendations:', newRecommendations);

    if (isVNAPack) {
        updateVNAPackRow(row, newRecommendations);
    } else {
        updatePickRebinPackRow(row, newRecommendations, userOverrides);
        // Immediately update Pick HC after Pack HC change
        updatePick2RebinPickHC();
    }

    updatePickHCBasedOnPackHC(productionTable);
    updateNextCPTPickHCBasedOnPackHC();
    updateOutboundTotals(productionTable);
    updateProductionGraphic();
    setTimeout(() => {
    updatePlanSummary1();
    }, 2000);
    if (productionTable.id === 'nextCPTProductionGraphicTable') {
        updateNextCPTProductionGraphic();
        updatePlanSummary2();
    } else {
        updateProcessingTimeLeft();
    }
        setTimeout(() => {
    updatePlanSummary1();
    }, 3000);
}

function recalculateRecommendations(pickRebinPackRow, riskModelValue, productionWindows, expectedRates, overrideIndex, overrideValue) {
    let remainingUnits = riskModelValue;

    for (let i = 0; i < productionWindows.length; i++) {
        const cell = pickRebinPackRow.cells[i + 1];
        const { duration } = productionWindows[i];
        const rate = expectedRates[i];
        const durationInHours = duration / 60;

        if (i === overrideIndex) {
            remainingUnits -= overrideValue * rate * durationInHours;
        } else if (cell.textContent !== 'X') {
            const currentHC = parseInt(cell.textContent);
            remainingUnits -= currentHC * rate * durationInHours;
        }
    }

    for (let i = 0; i < productionWindows.length; i++) {
        const cell = pickRebinPackRow.cells[i + 1];
        if (i !== overrideIndex && cell.textContent !== 'X') {
            const { duration } = productionWindows[i];
            const rate = expectedRates[i];
            const durationInHours = duration / 60;
            const maxUnitsInWindow = rate * durationInHours;

            if (remainingUnits <= 0) {
                cell.textContent = '1';
            } else {
                const recommendedHC = Math.ceil(remainingUnits / maxUnitsInWindow);
                cell.textContent = recommendedHC;
                remainingUnits -= recommendedHC * maxUnitsInWindow;
            }
        }
    }
}

function getCurrentCPTRiskModel() {
    return localStorage.getItem('currentCPTRiskModel') || 'MIXED';
}

function getNextCPTRiskModel() {
    return 'MIXED';
}

// Pick Recommendations
function updatePick2RebinPickHC() {
    const productionTable = document.getElementById('productionGraphic');
    if (!productionTable) {
        console.error('Production table not found');
        return;
    }

    let pickRow, packRow, pickRateRow, packRateRow;

    for (let i = 0; i < productionTable.rows.length; i++) {
        const rowName = productionTable.rows[i].cells[0].textContent.trim();
        if (rowName === 'Pick2Rebin Pick') {
            pickRow = productionTable.rows[i];
            pickRateRow = productionTable.rows[i + 1];
        } else if (rowName === 'Pick2Rebin Pack') {
            packRow = productionTable.rows[i];
            packRateRow = productionTable.rows[i + 1];
        }
    }

    if (!pickRow || !packRow || !pickRateRow || !packRateRow) {
        console.error('Required rows not found');
        return;
    }

    for (let i = 1; i < packRow.cells.length; i++) {
        const packHC = parseInt(packRow.cells[i].textContent);
        const packRate = parseFloat(packRateRow.cells[i].textContent);
        const pickRate = parseFloat(pickRateRow.cells[i].textContent);

        if (!isNaN(packHC) && !isNaN(packRate) && !isNaN(pickRate) && pickRate > 0) {
            const newPickHC = Math.ceil((packHC * packRate) / pickRate);
            pickRow.cells[i].textContent = newPickHC;
            pickRow.cells[i].style.backgroundColor = 'lightgreen';
        }
    }

    console.log('Pick2Rebin Pick HC updated');
    updateOutboundTotals(productionTable);
}


function updatePickHCBasedOnPackHC(productionTable) {
    const packRow = productionTable.querySelector('tr:nth-child(5)'); // Assuming Pack2Rebin Pack is the 5th row
    const pickRow = productionTable.querySelector('tr:nth-child(3)'); // Assuming Pick2Rebin Pick is the 3rd row
    const packRateRow = packRow.nextElementSibling;
    const pickRateRow = pickRow.nextElementSibling;

    if (!packRow || !pickRow || !packRateRow || !pickRateRow) {
        console.error('Required rows not found for updating Pick HC');
        return;
    }

    for (let i = 1; i < packRow.cells.length; i++) {
        const packHC = parseInt(packRow.cells[i].textContent);
        const packRate = parseFloat(packRateRow.cells[i].textContent);
        const pickRate = parseFloat(pickRateRow.cells[i].textContent);

        if (!isNaN(packHC) && !isNaN(packRate) && !isNaN(pickRate) && pickRate > 0) {
            const newPickHC = Math.ceil((packHC * packRate) / pickRate);
            if (!pickRow.cells[i].dataset.userOverride) {
                pickRow.cells[i].textContent = newPickHC;
                // Remove any background color for automatic updates
                pickRow.cells[i].style.backgroundColor = '';
            }
        }
    }

    console.log('Pick2Rebin Pick HC updated based on Pack HC');
    updateOutboundTotals(productionTable);
}
function handleRateChange(event) {
    const rateCell = event.target;
    const productionTable = rateCell.closest('table');
    updatePickHCBasedOnPackHC(productionTable);
    updatePickRebinPackRecommendations();
    // Update the next CPT table as well
    updateNextCPTPick2RebinPickHC();
    // Update outbound totals and production graphics for both tables
    updateOutboundTotals(productionTable);
    updateProductionGraphic();
    updateNextCPTProductionGraphic();
}
document.getElementById('cptSelect').addEventListener('change', updateCPTInfoBoxes);
document.getElementById('refreshButton').addEventListener('click', updateCPTInfoBoxes);
document.getElementById('cptSelect').addEventListener('change', updatePickRebinPackRecommendations);
document.getElementById('riskModel').addEventListener('change', updatePickRebinPackRecommendations);
function getNextCPT(currentCPT) {
    const selectedSite = document.getElementById('siteSelector').value;

    // If site is in specialCPTs, use those times and add '20:20'
    // If not in specialCPTs, use default times without '20:20'
    const baseTimes = specialCPTs[selectedSite] || ['00:20', '06:20', '11:20', '14:20', '18:20'];
    const cptTimes = specialCPTs[selectedSite] ? [...baseTimes, '20:20'] : baseTimes;

    const currentIndex = cptTimes.indexOf(currentCPT);
    return cptTimes[(currentIndex + 1) % cptTimes.length];
}
const preloadedInfoBoxGif = new Image();
preloadedInfoBoxGif.src = 'https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExMnpvbWdhaTljNGFnbGhsbmgzMXY4a2didnNqajQ4dngyb3N3NHNwMCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/r88w2d7tHqazFwNEGN/giphy.webp';
// Call this function after the page loads
window.addEventListener('load', adjustInitialPositioning);
window.addEventListener('resize', adjustFixedElementPositions);

// Function to adjust positions of fixed elements
function adjustFixedElements() {
    const containers = [
        'container',
        'clockContainer',
        'cptInfoContainer',
        'timestampContainer',
        'currentCPTInfoBox',
        'nextCPTInfoBox',
        'fullTableContainer',
        'nextCPTTableContainer',
        'nextCPTInfoTableContainer',
        'maxWallsContainer',
        'dispatchRecommendationContainer',
        'mathTableContainer',
        'nextCPTMathTableContainer',
        'outboundPlanningRecommendationContainer',
        'injections',
    ];

    containers.forEach(containerId => {
        const element = document.getElementById(containerId);
        if (element) {
            if (!element.hasAttribute('data-original-top')) {
                element.setAttribute('data-original-top', element.style.top || '0px');
            }
            element.style.position = 'fixed';
            element.style.zIndex = '1000';
        }
    });
}

// Function to update positions based on scroll
function updatePositions() {
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const containers = document.querySelectorAll('[data-original-top]');

    containers.forEach(element => {
        const originalTop = parseInt(element.getAttribute('data-original-top')) || 0;
        element.style.top = `${originalTop - scrollTop}px`;
    });
}

// Call adjustFixedElements after the DOM is fully loaded
document.addEventListener('DOMContentLoaded', adjustFixedElements);

// Update positions on scroll
window.addEventListener('scroll', updatePositions);

// Initial position update
updatePositions();

// Ensure the body is at least as tall as the viewport
document.body.style.minHeight = '100vh';

// Add some extra space at the bottom of the page
const extraSpace = document.createElement('div');
extraSpace.style.height = '2000px'; // Adjust this value as needed
document.body.appendChild(extraSpace);

function initializeMaxWalls() {
    const maxWallsSelect = document.getElementById('maxWalls');

    if (!maxWallsSelect) {
        console.error('maxWalls select element not found');
        return;
    }

    // Set initial value to 15 and color to yellow
    maxWallsSelect.value = 15;
    maxWallsSelect.style.backgroundColor = 'yellow';
    maxWallsSelect.dataset.recommendedValue = 15; // Set initial recommended value

    // Event listener for changes
    maxWallsSelect.addEventListener('change', manualChangeHandler);

    // Initial update based on the currently selected site
    const selectedSite = document.getElementById('siteSelector').value;
    if (selectedSite) {
        updateMaxWalls(selectedSite);
    }
}


window.addEventListener('load', initializeMaxWalls);

function updateMaxWalls(site) {
    console.log(`updateMaxWalls called for site: ${site}`);
    if (!site) {
        console.error('No site provided to updateMaxWalls');
        return;
    }

    const url = `https://flow-sortation-na.amazon.com/${site}/afe/rainbow/PPPickToRebin`;
    console.log(`Fetching URL: ${url}`);

    const maxWallsSelect = document.getElementById('maxWalls');
    if (maxWallsSelect) {
        maxWallsSelect.disabled = true;
        maxWallsSelect.style.opacity = '0.5';
        const loadingOption = document.createElement('option');
        loadingOption.text = 'Loading...';
        maxWallsSelect.add(loadingOption, 0);
        maxWallsSelect.selectedIndex = 0;
    }

    GM_xmlhttpRequest({
        method: "GET",
        url: url,
        headers: {
            "Accept": "application/json, text/plain, */*",
            "Referer": `https://flow-sortation-na.amazon.com/${site}/`,
        },
        timeout: 30000, // 30 seconds timeout
        onload: function(response) {
            console.log('Response received:', response.status);
            if (response.status !== 200) {
                console.error('Error fetching data:', response.status, response.statusText);
                resetMaxWallsSelect(maxWallsSelect);
                return;
            }

            try {
                const data = JSON.parse(response.responseText);
                console.log('Parsed data:', data);

                const wallCount = data.utilizationByStation.length;
                console.log(`Number of walls found: ${wallCount}`);

                if (maxWallsSelect) {
                    maxWallsSelect.remove(0); // Remove the loading option
                    maxWallsSelect.disabled = false;
                    maxWallsSelect.style.opacity = '1';
                    const newValue = wallCount > 30 ? 30 : (wallCount < 1 ? 1 : wallCount);

                    // Remove the event listener before changing the value
                    maxWallsSelect.removeEventListener('change', manualChangeHandler);

                    maxWallsSelect.value = newValue;

                    // Only set the recommended value if it hasn't been set before
                    if (!maxWallsSelect.dataset.recommendedValue) {
                        maxWallsSelect.dataset.recommendedValue = newValue;
                    }

                    console.log(`Updated maxWalls select to: ${newValue}`);

                    // Set background color to light green if data was pulled correctly
                    maxWallsSelect.style.backgroundColor = 'lightgreen';

                    // Add the event listener back
                    maxWallsSelect.addEventListener('change', manualChangeHandler);

                    // Set a flag to indicate this was an automatic update
                    maxWallsSelect.dataset.automaticUpdate = 'true';
                } else {
                    console.error('maxWalls select element not found');
                }
            } catch (error) {
                console.error('Error parsing response:', error);
                resetMaxWallsSelect(maxWallsSelect);
            }
        },
        onerror: function(error) {
            console.error('Error in GM_xmlhttpRequest:', error);
            resetMaxWallsSelect(maxWallsSelect);
        },
        ontimeout: function() {
            console.error('Request timed out after 30 seconds');
            resetMaxWallsSelect(maxWallsSelect);
        }
    });
}


function manualChangeHandler(event) {
    // Check if this was triggered by an automatic update
    if (this.dataset.automaticUpdate === 'true') {
        this.dataset.automaticUpdate = 'false';
        return;
    }

    const selectedValue = parseInt(this.value);
    const recommendedValue = parseInt(this.dataset.recommendedValue);

    if (selectedValue !== recommendedValue) {
        this.style.backgroundColor = 'red'; // Set to red when changed to any different value
    } else {
        this.style.backgroundColor = 'lightgreen'; // Set back to light green if it matches the recommended value
    }

    // Log the values for debugging
    console.log(`Selected: ${selectedValue}, Recommended: ${recommendedValue}`);
}

function resetMaxWallsSelect(select) {
    if (select) {
        select.remove(0); // Remove the loading option
        select.disabled = false;
        select.style.opacity = '1';

        // Remove the event listener before changing the value
        select.removeEventListener('change', manualChangeHandler);

        select.value = 15; // Set to default value of 15
        select.style.backgroundColor = 'yellow'; // Set to yellow when reset (default 15)

        // Add the event listener back
        select.addEventListener('change', manualChangeHandler);

        // Set a flag to indicate this was an automatic update
        select.dataset.automaticUpdate = 'true';
    }
}
// Make sure to call this function when the page loads
window.addEventListener('load', function() {
    console.log('Window loaded, initializing Max Walls');
    initializeMaxWalls();
});
// Update positions on scroll
window.addEventListener('scroll', updatePositions);

// Initial position update
updatePositions();

// Adjust the elongation div
if (elongationDiv) {
    elongationDiv.style.height = '9000px'; // Adjust this value as needed
}

// Ensure the body is at least as tall as the viewport
document.body.style.minHeight = '100vh';

// NEXTCPTMATH


function createAndUpdateNextCPTMathTable() {
    let nextCPTMathTableContainer = document.getElementById('nextCPTMathTableContainer');
    if (!nextCPTMathTableContainer) {
        nextCPTMathTableContainer = document.createElement('div');
        nextCPTMathTableContainer.id = 'nextCPTMathTableContainer';
        nextCPTMathTableContainer.style.position = 'fixed';
        nextCPTMathTableContainer.style.right = '10px';
        nextCPTMathTableContainer.style.top = '800px';
        nextCPTMathTableContainer.style.width = '300px';
        nextCPTMathTableContainer.style.backgroundColor = 'white';
        nextCPTMathTableContainer.style.border = '1px solid black';
        nextCPTMathTableContainer.style.padding = '10px';
        nextCPTMathTableContainer.style.zIndex = '10000';
        nextCPTMathTableContainer.style.display = 'none'; // Hide the original container
        document.body.appendChild(nextCPTMathTableContainer);
    }

    let mathTable = document.createElement('table');
    mathTable.style.width = '100%';
    mathTable.style.borderCollapse = 'collapse';

    let header = mathTable.createTHead();
    let headerRow = header.insertRow();
    ['Type', 'Set 1', 'Set 2', 'Set 3', 'Set 4'].forEach(text => {
        let th = document.createElement('th');
        th.textContent = text;
        th.style.border = '1px solid black';
        th.style.padding = '5px';
        headerRow.appendChild(th);
    });

    let body = mathTable.createTBody();
    ['CORA', 'ATROPS', 'MIXED', 'Low Backlog'].forEach(rowName => {
        let row = body.insertRow();
        let cell = row.insertCell();
        cell.textContent = rowName;
        cell.style.border = '1px solid black';
        cell.style.padding = '5px';

        for (let i = 0; i < 4; i++) {
            let cell = row.insertCell();
            cell.style.border = '1px solid black';
            cell.style.padding = '5px';
        }
    });

    nextCPTMathTableContainer.innerHTML = '';
    nextCPTMathTableContainer.appendChild(mathTable);

    updateNextCPTMathTableCalculations();
}

function updateNextCPTMathTableCalculations() {
    const riskModel = 'MIXED';
    let mathTable = document.querySelector('#nextCPTMathTableContainer table');
    if (!mathTable) {
        console.error('Next CPT Math table not found');
        return;
    }

    let currentCPT = document.getElementById('cptSelect').value;
    let nextCPT = getNextCPT(currentCPT);
    console.log('Next CPT:', nextCPT);

    let allCoraData = getCORAData();
    console.log('All CORA data:', allCoraData);

    let atropsData = getATROPSData(nextCPT);
    console.log('ATROPS data for next CPT:', atropsData);

    const multiplier = parseFloat(localStorage.getItem('planningRiskMultiplier') || '1.3');

    let coraSet1Value, coraSet2Value, coraSet3Value, atropsSet1Value, atropsSet2Value, atropsSet3Value;

    // CORA Set 1 calculation
    if (allCoraData && allCoraData[nextCPT]) {
        let columnE = allCoraData[nextCPT].columnE;
        let currentBacklog = allCoraData[nextCPT].currentBacklog;
        console.log(`For next CPT ${nextCPT}: Column E = ${columnE}, Current Backlog (Column A) = ${currentBacklog}`);

        coraSet1Value = columnE - currentBacklog;

        let coraRow = mathTable.rows[1];
        coraRow.cells[1].textContent = `${columnE} - ${currentBacklog} = ${coraSet1Value.toFixed(2)}`;
        console.log(`CORA Set 1 calculation: ${columnE} - ${currentBacklog} = ${coraSet1Value.toFixed(2)}`);
    } else {
        console.error('CORA data not available for the next CPT:', nextCPT);
        let coraRow = mathTable.rows[1];
        coraRow.cells[1].textContent = 'Data not available';
    }

    // ATROPS calculations
    let atropsRow = mathTable.rows[2];
    if (atropsData && allCoraData && allCoraData[nextCPT]) {
        let cap = parseFloat(atropsData.cap);
        let percentSchedule = parseFloat(atropsData.percentSchedule);
        let currentBacklog = allCoraData[nextCPT].currentBacklog;

        // ATROPS Set 1
        atropsSet1Value = cap * Math.max(0, (1 - percentSchedule/100)) * 1.6;
        atropsRow.cells[1].textContent = `${cap} * max(0, (1 - ${(percentSchedule/100).toFixed(2)})) * 1.6 = ${atropsSet1Value.toFixed(2)}`;
        console.log(`ATROPS Set 1 calculation: ${cap} * max(0, (1 - ${(percentSchedule/100).toFixed(2)})) * 1.6 = ${atropsSet1Value.toFixed(2)}`);

        // ATROPS Set 2
        if (percentSchedule > 100) {
            atropsSet2Value = allCoraData[nextCPT].columnD || atropsSet1Value;
        } else {
            atropsSet2Value = atropsSet1Value;
        }
        atropsRow.cells[2].textContent = `${percentSchedule} > 100% ? ${atropsSet2Value.toFixed(2)} : ${atropsSet1Value.toFixed(2)}`;
        console.log(`ATROPS Set 2 calculation: ${percentSchedule} > 100% ? ${atropsSet2Value.toFixed(2)} : ${atropsSet1Value.toFixed(2)}`);

        // ATROPS Set 3
        atropsSet3Value = atropsSet2Value + currentBacklog;
        atropsRow.cells[3].textContent = `${atropsSet2Value.toFixed(2)} + ${currentBacklog} = ${atropsSet3Value.toFixed(2)}`;
        console.log(`ATROPS Set 3 calculation: ${atropsSet2Value.toFixed(2)} + ${currentBacklog} = ${atropsSet3Value.toFixed(2)}`);
    } else {
        console.error('ATROPS data or CORA data not available for the next CPT:', nextCPT);
        atropsRow.cells[1].textContent = 'Data not available';
        atropsRow.cells[2].textContent = 'Data not available';
        atropsRow.cells[3].textContent = 'Data not available';
    }

    // CORA Set 2 and Set 3 Calculations
    if (allCoraData && allCoraData[nextCPT] && atropsData) {
        let columnE = allCoraData[nextCPT].columnE;
        let currentBacklog = allCoraData[nextCPT].currentBacklog;

        if (atropsSet1Value > coraSet1Value) {
            coraSet2Value = columnE;
        } else {
            coraSet2Value = currentBacklog + atropsSet1Value;
        }

        let coraRow = mathTable.rows[1];
        coraRow.cells[2].textContent = `${atropsSet1Value.toFixed(2)} > ${coraSet1Value.toFixed(2)} ? ${columnE} : ${currentBacklog} + ${atropsSet1Value.toFixed(2)} = ${coraSet2Value.toFixed(2)}`;
        console.log(`CORA Set 2 calculation: ${atropsSet1Value.toFixed(2)} > ${coraSet1Value.toFixed(2)} ? ${columnE} : ${currentBacklog} + ${atropsSet1Value.toFixed(2)} = ${coraSet2Value.toFixed(2)}`);

        coraSet3Value = coraSet2Value;
        coraRow.cells[3].textContent = `${coraSet2Value.toFixed(2)} = ${coraSet3Value.toFixed(2)}`;
        console.log(`CORA Set 3 calculation: ${coraSet2Value.toFixed(2)} = ${coraSet3Value.toFixed(2)}`);

        let mixedSet3Value = (coraSet3Value + atropsSet3Value) / 2;
        let mixedRow = mathTable.rows[3];
        mixedRow.cells[3].textContent = `(${coraSet3Value.toFixed(2)} + ${atropsSet3Value.toFixed(2)}) / 2 = ${mixedSet3Value.toFixed(2)}`;
        console.log(`Mixed Set 3 calculation: (${coraSet3Value.toFixed(2)} + ${atropsSet3Value.toFixed(2)}) / 2 = ${mixedSet3Value.toFixed(2)}`);

        // Calculate Set 4 values
        let coraSet4Value = Math.ceil(coraSet3Value * multiplier);
        coraRow.cells[4].textContent = `${coraSet4Value}`;
        console.log(`CORA Set 4 calculation: ${coraSet3Value.toFixed(2)} * ${multiplier} = ${coraSet4Value}`);

        let atropsSet4Value = Math.ceil(atropsSet3Value * multiplier);
        atropsRow.cells[4].textContent = `${atropsSet4Value}`;
        console.log(`ATROPS Set 4 calculation: ${atropsSet3Value.toFixed(2)} * ${multiplier} = ${atropsSet4Value}`);

        let mixedSet4Value = Math.ceil(mixedSet3Value * multiplier);
        mixedRow.cells[4].textContent = `${mixedSet4Value}`;
        console.log(`MIXED Set 4 calculation: ${mixedSet3Value.toFixed(2)} * ${multiplier} = ${mixedSet4Value}`);

        // Low Backlog Set 4 (placeholder)
        let lowBacklogSet4Value = 0;
        mathTable.rows[4].cells[4].textContent = `${lowBacklogSet4Value}`;

        // Always use MIXED for the selected risk model
        let selectedRiskRow = mathTable.rows[5] || mathTable.insertRow(-1);
        let riskModelCell = selectedRiskRow.cells[0] || selectedRiskRow.insertCell(0);
        riskModelCell.textContent = `Selected Risk Model (MIXED)`;
        riskModelCell.style.fontWeight = 'bold';
        riskModelCell.style.border = '1px solid black';
        riskModelCell.style.padding = '5px';

        let riskValueCell = selectedRiskRow.cells[1] || selectedRiskRow.insertCell(1);
        riskValueCell.textContent = mixedSet4Value;
        riskValueCell.style.border = '1px solid black';
        riskValueCell.style.padding = '5px';
        riskValueCell.colSpan = 4; // Span across all SET columns

        console.log('Next CPT Math table calculations updated with MIXED as selected risk model');
    }
}
function getNextCPTSelectedRiskModelValue() {
    const mathTable = document.querySelector('#nextCPTMathTableContainer table');
    if (!mathTable) {
        console.error('Next CPT Math table not found');
        return null;
    }
    const mixedRow = Array.from(mathTable.rows).find(row => row.cells[0].textContent.trim() === 'MIXED');
    if (!mixedRow) {
        console.error('MIXED row not found in next CPT math table');
        return null;
    }
    const value = parseInt(mixedRow.cells[4].textContent);
    if (isNaN(value)) {
        console.error('Invalid MIXED Set 4 value in next CPT math table:', mixedRow.cells[4].textContent);
        return null;
    }
    console.log('Next CPT MIXED Set 4 value:', value);
    return value;
}

let dispatchRecommendationContainer = document.createElement('div');
dispatchRecommendationContainer.id = 'dispatchRecommendationContainer';
dispatchRecommendationContainer.style.position = 'fixed';
dispatchRecommendationContainer.style.top = '1500px';
dispatchRecommendationContainer.style.left = '56.8%';
dispatchRecommendationContainer.style.transform = 'translateX(-60%)';
dispatchRecommendationContainer.style.backgroundColor = 'white';
dispatchRecommendationContainer.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.1)';
dispatchRecommendationContainer.style.borderRadius = '12px';
dispatchRecommendationContainer.style.padding = '20px';
dispatchRecommendationContainer.style.zIndex = '10000';
dispatchRecommendationContainer.style.width = '43%';
dispatchRecommendationContainer.style.transition = 'all 0.3s ease';
document.body.appendChild(dispatchRecommendationContainer);


// Function to create the Dispatch Recommendation table
function createDispatchRecommendationTable() {
    // Create a wrapper div for centering
    const wrapper = document.createElement('div');
    wrapper.style.display = 'flex';
    wrapper.style.justifyContent = 'center';
    wrapper.style.width = '95%';
    wrapper.style.marginTop = '10px';

    const table = document.createElement('table');
    table.style.width = '95%';
    table.style.maxWidth = '500px';
    table.style.borderCollapse = 'collapse';

    // Table header
    const header = table.createTHead();
    const headerRow = header.insertRow();
    const headerCells = ['Path', 'Volume (Packages)', 'SLA', 'Induct', 'Buffer', 'Stow', 'Problem Solve', 'RTS', 'Empty Cart Return', 'Spotter'];
    headerCells.forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        th.style.border = '1px solid #ddd';
        th.style.padding = '8px';
        th.style.backgroundColor = '#f2f2f2';
        headerRow.appendChild(th);
    });

    // Table body
    const body = table.createTBody();
    const rows = [
        ['Rates(PPH)', '-', '-', '1800', '300', '300', 'Fixed', 'Fixed', '1200', '3600'],
        ['All', 'Pending', '-', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['Outbound', 'Pending', '1h', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['Rolled', '0', '30m', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['Held', '0', '45m', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['RTS', '0', '30m', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['Injection', '0', '1h', 'X', 'X', 'X', 'X', 'X', 'X', 'X']
    ];

    rows.forEach((rowData, index) => {
        const row = body.insertRow();
        rowData.forEach((cellData, cellIndex) => {
            const cell = row.insertCell();
            if (index === 1 && cellIndex === 0) {
                cell.innerHTML = '<span class="toggle-icon">‚ñ∂</span> ' + cellData;
                cell.style.cursor = 'pointer';
                cell.addEventListener('click', toggleCollapse);
            } else {
                cell.textContent = cellData;
            }
            cell.style.border = '1px solid #ddd';
            cell.style.padding = '8px';
            if (index === 0) {
                cell.style.backgroundColor = '#e6f2ff';
            }
        });
        if (index === 1) {
            row.classList.add('collapsible');
        } else if (index > 1) {
            row.classList.add('collapsible-content');
            row.style.display = 'none';
        }
    });

    // Add table to wrapper and return wrapper
    wrapper.appendChild(table);
    return wrapper;
}

// Function to toggle the collapse/expand of rows
function toggleCollapse(event) {
    const row = event.target.closest('tr');
    row.classList.toggle('active');
    const toggleIcon = row.querySelector('.toggle-icon');
    toggleIcon.textContent = row.classList.contains('active') ? '‚ñº' : '‚ñ∂';

    let nextRow = row.nextElementSibling;
    while (nextRow && nextRow.classList.contains('collapsible-content')) {
        nextRow.style.display = row.classList.contains('active') ? 'table-row' : 'none';
        nextRow = nextRow.nextElementSibling;
    }
}
function initializeDispatchRecommendation() {
    const container = document.getElementById('dispatchRecommendationContainer');
    container.innerHTML = `
        <h2 style="
            color: #2c3e50;
            font-size: 24px;
            margin-bottom: 20px;
            font-weight: 600;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        ">Dispatch Recommendation</h2>
        <p id="totalHCDisplay" style="
            color: #34495e;
            font-size: 16px;
            margin-bottom: 15px;
        ">Total HC: <span id="hcValue">X.00</span></p>`;
    const table = document.createElement('table');
    table.style.width = '95%';
    table.style.borderCollapse = 'collapse';
    table.style.marginTop = '10px';
    table.style.backgroundColor = 'white';
    table.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
    table.style.borderRadius = '8px';
    table.style.overflow = 'hidden';
    table.style.fontSize = '16px';

    const headerRow = table.insertRow();
    ['Path', 'Volume (Packages)', 'SLA', 'Induct', 'Buffer', 'Stow', 'Problem Solve', 'RTS', 'Empty Cart Return', 'Spotter'].forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        th.style.backgroundColor = '#f8fafc';
        th.style.color = '#475569';
        th.style.padding = '12px';
        th.style.fontWeight = '600';
        th.style.fontSize = '16px';
        th.style.textAlign = 'left';
        th.style.borderBottom = '2px solid #e2e8f0';
        th.style.borderRight = '1px solid #e2e8f0';
        headerRow.appendChild(th);
    });

    const paths = ['Rates(PPH)', 'All', 'Outbound', 'Rolled', 'Held', 'RTS', 'Injection'];
    const defaultValues = [
        ['-', '-', '1800', '300', '300', 'Fixed', 'Fixed', '1200', '3600'],
        ['Pending', '-', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['Pending', '1h', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['0', '30m', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['0', '45m', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['0', '30m', 'X', 'X', 'X', 'X', 'X', 'X', 'X'],
        ['0', '1h', 'X', 'X', 'X', 'X', 'X', 'X', 'X']
    ];

    paths.forEach((path, index) => {
        const row = table.insertRow();
        const pathCell = row.insertCell();
        pathCell.textContent = path;
        pathCell.style.padding = '12px';
        pathCell.style.color = '#1e293b';
        pathCell.style.fontSize = '16px';
        pathCell.style.backgroundColor = index % 2 === 0 ? '#f8fafc' : 'white';
        pathCell.style.borderBottom = '1px solid #e2e8f0';
        pathCell.style.borderRight = '1px solid #e2e8f0';

        defaultValues[index].forEach(value => {
            const cell = row.insertCell();
            cell.textContent = value;
            cell.style.padding = '12px';
            cell.style.color = '#475569';
            cell.style.fontSize = '16px';
            cell.style.backgroundColor = index % 2 === 0 ? '#f8fafc' : 'white';
            cell.style.borderBottom = '1px solid #e2e8f0';
            cell.style.borderRight = '1px solid #e2e8f0';
        });
    });

    container.appendChild(table);
}

function updateRTSVolume(volume) {
    console.log(`[DEBUG] Updating RTS volume: ${volume}`);
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    if (dispatchTable) {
        const rtsRow = Array.from(dispatchTable.rows).find(row => row.cells[0].textContent.trim() === 'RTS');
        if (rtsRow && rtsRow.cells.length > 1) {
            const volumeCell = rtsRow.cells[1];

            if (volume !== null && volume !== undefined) {
                volumeCell.textContent = volume;
                volumeCell.style.backgroundColor = 'lightgreen';
                console.log(`[DEBUG] RTS volume updated successfully to: ${volume}`);
            } else {
                volumeCell.textContent = 'Update failed';
                volumeCell.style.backgroundColor = 'lightcoral';
                console.error('[DEBUG] Failed to update RTS volume: Invalid volume');
            }
        } else {
            console.error('[DEBUG] RTS row or volume cell not found in Dispatch Recommendation table');
        }
    } else {
        console.error('[DEBUG] Dispatch Recommendation table not found');
    }
}
window.addEventListener('load', initializeDispatchRecommendation);
let outboundPlanningRecommendationContainer;
let currentStationCode = '';

// Function to update the station code when a site is selected
function updateStationCode() {
    const siteSelector = document.getElementById('siteSelector');
    currentStationCode = siteSelector.value;
    console.log('Station code updated:', currentStationCode);

    // Fetch data for the newly selected site
    if (currentStationCode) {
        fetchAndDisplayOutboundPlanning(currentStationCode);
    }
}
// Set up event listener for site selection
function setupSiteSelector() {
    const siteSelector = document.getElementById('siteSelector');
    if (siteSelector) {
        siteSelector.addEventListener('change', updateStationCode);
        console.log('Site selector event listener set up');
    } else {
        console.error('Site selector not found');
    }
}

// Run setup when the page loads
window.addEventListener('load', function() {
    console.log('Window loaded, setting up site selector');
    setupSiteSelector();

    // If there's an initial selection, fetch data for it
    updateStationCode();
});

// Add this line at the beginning of your script
console.log('Script loaded.');

let injections = document.createElement('div');
injections.id = 'Injections';
injections.style.cssText = `
    position: fixed;
    top: 1300px;
    left: 10px;
    min-width: 8%;
    width: auto;
    max-width: 25%;
    background-color: white;
    padding: 20px;
    z-index: 10000;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(20px);
    overflow-x: auto;
`;
document.body.appendChild(injections);

// Fade in animation
setTimeout(() => {
    injections.style.opacity = '1';
    injections.style.transform = 'translateY(0)';
}, 100);

// Add hover effect
injections.addEventListener('mouseover', () => {
    injections.style.boxShadow = '0 6px 20px rgba(0, 0, 0, 0.15)';
});

injections.addEventListener('mouseout', () => {
    injections.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.1)';
});


function fetchAndDisplayOutboundPlanning(siteCode) {
    const stationCode = complementaryStations[siteCode];
    if (!stationCode) {
        console.error('No station code found for site:', siteCode);
        return;
    }

    console.log('Starting fetchAndDisplayOutboundPlanning function for site:', siteCode, 'station:', stationCode);

    const url = 'https://logistics.amazon.com/station/proxyapigateway/data';
    const headers = {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest'
    };
    const body = JSON.stringify({
        "resourcePath": "/ivs/getNodeLineHaulList",
        "httpMethod": "post",
        "processName": "induct",
        "requestBody": {
            "nodeId": stationCode,
            "groupBy": ""
        }
    });

    console.log('Initiating GM_xmlhttpRequest for station:', stationCode);
    GM_xmlhttpRequest({
        method: 'POST',
        url: url,
        headers: headers,
        data: body,
        onload: function(response) {
            console.log('Response received for station:', stationCode, 'Status:', response.status);
            try {
                const data = JSON.parse(response.responseText);
                displayLineHaulTable(data, siteCode, stationCode, injections);
            } catch (error) {
                console.error('Error parsing response:', error);
                injections.innerHTML = `
                    <h2>Error</h2>
                    <p>Failed to parse response data for ${siteCode} (${stationCode}): ${error.message}</p>
                `;
            }
        },
        onerror: function(error) {
            console.error('Error in GM_xmlhttpRequest for station:', stationCode, error);
            injections.innerHTML = `
                <h2>Error</h2>
                <p>Failed to load data for ${siteCode} (${stationCode}): ${error.message}</p>
            `;
        }
    });
}

const standardCETSchedule = {
'CET1': [
{ name: 'Breakfast', time: '18:45' },
{ name: 'Brunch', time: '03:30' },
{ name: 'Bedtime', time: '14:00' }
],
'CET2': [
{ name: 'Breakfast', time: '22:00' },
{ name: 'Brunch', time: '05:30' },
{ name: 'Lunch', time: '07:30' },
{ name: 'Dinner', time: '11:30' },
{ name: 'Bedtime', time: '16:00' }
]
};

const sny1CETSchedule = {
    'CET1': [
        { name: 'Breakfast', time: '16:00' }
    ],
    'CET2': [
        { name: 'Breakfast', time: '18:20' },
        { name: 'Bedtime', time: '10:30' }
    ],
    'CET3': [
        { name: 'Breakfast', time: '21:20' },
        { name: 'Brunch', time: '02:30' },
        { name: 'Dinner', time: '07:00' },
        { name: 'Bedtime', time: '12:30' }
    ]
};
function determineCET(plannedTime) {
    // Get the current selected site
    const currentSite = document.getElementById('siteSelector').value;

    // Extract the time portion from the planned time string
    const timeStr = plannedTime.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    });

    const [hours, minutes] = timeStr.split(':').map(Number);
    const plannedMinutes = hours * 60 + minutes;

    function timeToMinutes(timeStr) {
        const [h, m] = timeStr.split(':').map(Number);
        return h * 60 + m;
    }

    // Special case for SNY1
    if (currentSite === 'SNY1') {
        const sny1CetRanges = [
            { start: '12:30', end: '16:00', cet: 'Breakfast - CET1' },
            { start: '16:00', end: '18:20', cet: 'Breakfast - CET2' },
            { start: '18:20', end: '21:20', cet: 'Breakfast - CET3' },
            { start: '21:20', end: '02:30', cet: 'Brunch - CET3' },
            { start: '02:30', end: '07:00', cet: 'Dinner - CET3' },
            { start: '07:00', end: '10:30', cet: 'Bedtime - CET2'},
            { start: '10:30', end: '12:30', cet: 'Bedtime - CET3'}
        ];

        function isInTimeRange(plannedMin, startTime, endTime) {
            let start = timeToMinutes(startTime);
            let end = timeToMinutes(endTime);
            let planned = plannedMin;

            // Handle ranges that cross midnight
            if (end < start) {
                end += 24 * 60;
                if (planned < start) {
                    planned += 24 * 60;
                }
            }

            return planned >= start && planned < end;
        }

        for (const range of sny1CetRanges) {
            if (isInTimeRange(plannedMinutes, range.start, range.end)) {
                return range.cet;
            }
        }

        return 'Non-CET';
    }

    // Standard CET ranges for all other sites
    const cetRanges = [
        { start: '14:00', end: '16:00', cet: 'Bedtime - CET2' },
        { start: '16:00', end: '18:45', cet: 'Breakfast - CET1' },
        { start: '18:45', end: '22:00', cet: 'Breakfast - CET2' },
        { start: '22:00', end: '03:30', cet: 'Brunch - CET1' },
        { start: '03:30', end: '05:30', cet: 'Brunch - CET2' },
        { start: '05:30', end: '07:30', cet: 'Lunch - CET2' },
        { start: '07:30', end: '11:30', cet: 'Dinner - CET2'},
        { start: '11:30', end: '14:00', cet: 'Bedtime - CET1' }
    ];

    function isInTimeRange(plannedMin, startTime, endTime) {
        let start = timeToMinutes(startTime);
        let end = timeToMinutes(endTime);
        let planned = plannedMin;

        // Handle ranges that cross midnight
        if (end < start) {
            end += 24 * 60;
            if (planned < start) {
                planned += 24 * 60;
            }
        }

        return planned >= start && planned < end;
    }

    for (const range of cetRanges) {
        if (isInTimeRange(plannedMinutes, range.start, range.end)) {
            return range.cet;
        }
    }

    return 'Non-CET';
}
function displayLineHaulTable(data, siteCode, stationCode, container) {
    container.innerHTML = `
        <h2 style="
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.2s ease;
        ">
            <a href="https://logistics.amazon.com/station/dashboard/receive?stationCode=${stationCode}"
               target="_blank"
               title="Open in Logistics Dashboard: https://logistics.amazon.com/station/dashboard/receive?stationCode=${stationCode}"
               style="
                   color: #2c3e50;
                   font-size: 28px;
                   text-decoration: none;
                   display: inline-flex;
                   align-items: center;
                   transition: all 0.2s ease;
               "
               onmouseover="this.style.color='#3498db'; this.style.transform='translateX(5px)'"
               onmouseout="this.style.color='#2c3e50'; this.style.transform='translateX(0)'"
            >
                LineHaul Info for ${siteCode} (${stationCode})
                <svg xmlns="http://www.w3.org/2000/svg"
                     width="24"
                     height="24"
                     viewBox="0 0 24 24"
                     style="margin-left: 8px; fill: currentColor;"
                >
                    <path d="M10 6v2h8.59L8.8 17.79l1.41 1.41L20 9.41V18h2V6z"/>
                </svg>
            </a>
        </h2>
        <div style="overflow-x: auto;">
    `;
    if (!data.lineHauls || data.lineHauls.length === 0) {
        container.innerHTML += `
            <p style="
                color: #7f8c8d;
                font-size: 20px;
                text-align: center;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 8px;
                margin: 10px 0;
            ">No LineHaul data available.</p>`;
        return;
    }

    data.lineHauls.sort((a, b) => {
        const statusOrder = { 'ARRIVED': 0, 'IN_TRANSIT': 1, 'PENDING_DEPART': 2 };
        if (statusOrder[a.lineHaulStatus] < statusOrder[b.lineHaulStatus]) return -1;
        if (statusOrder[a.lineHaulStatus] > statusOrder[b.lineHaulStatus]) return 1;
        const aTime = new Date(a.lineHaulTime?.plannedTime);
        const bTime = new Date(b.lineHaulTime?.plannedTime);
        return aTime - bTime;
    });

    const table = document.createElement('table');
    table.id = 'lineHaulTable';
    table.style.cssText = `
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-top: 15px;
        background: white;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        border-radius: 8px;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 16px;
    `;

    const headerRow = table.insertRow();
    ['LineHaul ID', 'Status', 'Planned Time', 'CET', 'Volume', 'Active Pending Volume'].forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        th.style.cssText = `
            padding: 16px;
            background-color: #f8fafc;
            color: #475569;
            font-weight: 600;
            text-align: left;
            border-bottom: 2px solid #e2e8f0;
            font-size: 18px;
            transition: background-color 0.2s ease;
        `;

        th.addEventListener('mouseover', () => {
            th.style.backgroundColor = '#f1f5f9';
        });
        th.addEventListener('mouseout', () => {
            th.style.backgroundColor = '#f8fafc';
        });

        headerRow.appendChild(th);
    });


    // Helper function to get CET schedule based on site
    function getCETSchedule(site) {
        return site === 'SNY1' ? sny1CETSchedule : standardCETSchedule;
    }

    // Helper function to convert time to minutes
    function timeToMinutes(timeStr) {
        const [h, m] = timeStr.split(':').map(Number);
        return h * 60 + m;
    }

    // Helper function to check if time is past CET
    function isPastCET(actualTime, targetTime, cetType) {
        const actualMinutes = timeToMinutes(actualTime);
        const targetMinutes = timeToMinutes(targetTime);

        // Handle midnight crossing for different CET types
        if (siteCode === 'SNY1') {
            // Special handling for SNY1 CET windows
            const adjustedActual = actualMinutes;
            let adjustedTarget = targetMinutes;

            // Adjust for CET windows that cross midnight
            if (cetType === 'CET2' && targetTime === '10:30') {
                adjustedTarget += 24 * 60; // Add 24 hours worth of minutes
            }
            if (cetType === 'CET3' && (targetTime === '02:30' || targetTime === '07:00' || targetTime === '12:30')) {
                if (actualMinutes < 12 * 60) { // If actual time is before noon
                    adjustedTarget += 24 * 60;
                }
            }

            return adjustedActual > adjustedTarget;
        } else {
            // Standard CET handling
            if (targetMinutes < 6 * 60 && actualMinutes > 18 * 60) { // Handle midnight crossing
                return true;
            }
            return actualMinutes > targetMinutes;
        }
    }

    data.lineHauls.forEach(lineHaul => {
        const row = table.insertRow();
        row.style.cssText = `
            transition: all 0.3s ease;
            border-bottom: 1px solid #e2e8f0;
            font-size: 16px;
        `;

        row.addEventListener('mouseover', () => {
            row.style.backgroundColor = '#f8fafc';
            row.style.transform = 'translateX(5px)';
        });

        row.addEventListener('mouseout', () => {
            row.style.transform = 'translateX(0)';
            switch (lineHaul.lineHaulStatus) {
                case 'ARRIVED': row.style.backgroundColor = '#e6ffe6'; break;
                case 'IN_TRANSIT': row.style.backgroundColor = '#e6f3ff'; break;
                case 'PENDING_DEPART': row.style.backgroundColor = '#ffffd0'; break;
                default: row.style.backgroundColor = 'transparent';
            }
        });

        const cellId = row.insertCell();
        const cellStatus = row.insertCell();
        const cellPlannedTime = row.insertCell();
        const cellCET = row.insertCell();
        const cellVolume = row.insertCell();
        const cellActivePendingVolume = row.insertCell();
        cellId.innerHTML = `
            <a href="#"
               title="Open in Trans Logistics: https://trans-logistics.amazon.com/fmc/execution/search/${lineHaul.lineHaulId}"
               style="
                   color: #2563eb;
                   text-decoration: none;
                   font-weight: 500;
                   transition: all 0.2s ease;
                   display: inline-flex;
                   align-items: center;
                   gap: 4px;
               "
            >
                ${lineHaul.lineHaulId}
                <svg xmlns="http://www.w3.org/2000/svg"
                     width="16"
                     height="16"
                     viewBox="0 0 24 24"
                     style="fill: currentColor;"
                >
                    <path d="M10 6v2h8.59L8.8 17.79l1.41 1.41L20 9.41V18h2V6z"/>
                </svg>
            </a>`;

        const link = cellId.querySelector('a');

        link.addEventListener('click', (e) => {
            e.preventDefault();
            window.open(`https://trans-logistics.amazon.com/fmc/execution/search/${lineHaul.lineHaulId}`, '_blank');
        });

        link.addEventListener('mouseover', (e) => {
            e.target.style.color = '#1d4ed8';
            e.target.style.textDecoration = 'underline';
            e.target.style.cursor = 'pointer';
        });

        link.addEventListener('mouseout', (e) => {
            e.target.style.color = '#2563eb';
            e.target.style.textDecoration = 'none';
        });

        cellStatus.textContent = lineHaul.lineHaulStatus;

        const plannedTime = new Date(lineHaul.lineHaulTime?.plannedTime);
        cellPlannedTime.textContent = plannedTime.toLocaleString("en-US", {
            dateStyle: 'short',
            timeStyle: 'short'
        });

        const cetInfo = determineCET(plannedTime);
        cellCET.textContent = cetInfo;

        cellVolume.textContent = lineHaul.volume;
        cellActivePendingVolume.textContent = 'Loading...';

        const baseCellStyle = `
            padding: 16px;
            border: none;
            border-bottom: 1px solid #e2e8f0;
            font-size: 16px;
            transition: all 0.2s ease;
            color: #1a202c;
        `;

        [cellId, cellStatus, cellPlannedTime, cellCET, cellVolume, cellActivePendingVolume].forEach(cell => {
            cell.style.cssText = baseCellStyle;
        });

        // Status-specific styling
        cellStatus.style.fontWeight = 'bold';
        switch (lineHaul.lineHaulStatus) {
            case 'ARRIVED':
                row.style.backgroundColor = '#e6ffe6';
                cellStatus.style.color = '#166534';
                if (cetInfo !== 'Non-CET') {
                    const [mealName, cetType] = cetInfo.split(' - ');
                    const schedule = getCETSchedule(siteCode);

                    if (schedule[cetType]) {
                        const targetCET = schedule[cetType].find(cet => cet.name === mealName);

                        if (targetCET) {
                            const actualTime = new Date(lineHaul.lineHaulTime?.actualTime || lineHaul.lineHaulTime?.departedTime)
                                .toLocaleTimeString('en-US', {
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    hour12: false,
                                });

                            if (isPastCET(actualTime, targetCET.time, cetType)) {
                                row.classList.add('blink');
                                row.style.backgroundColor = '#ffcccc';
                                cellCET.style.color = '#dc2626';
                                cellCET.style.fontWeight = 'bold';
                            }
                        }
                    }
                }
                break;
            case 'IN_TRANSIT':
                row.style.backgroundColor = '#e6f3ff';
                cellStatus.style.color = '#1e40af';
                break;
            case 'PENDING_DEPART':
                row.style.backgroundColor = '#ffffd0';
                cellStatus.style.color = '#854d0e';
                break;
        }

        // Active Pending Volume loading animation
        cellActivePendingVolume.style.position = 'relative';
        cellActivePendingVolume.style.animation = 'pulse 2s infinite';

        updateActivePendingVolume(siteCode, lineHaul.lineHaulId);
    });

    container.appendChild(table);

    const style = document.createElement('style');
    style.textContent = `
        @keyframes blinkingBackground {
            0% { background-color: inherit; }
            50% { background-color: #ffcccc; }
            100% { background-color: inherit; }
        }
        .blink {
            animation: blinkingBackground 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    `;
    document.head.appendChild(style);
    processLineHauls(siteCode);

}



function updateSiteData() {
    const siteSelector = document.getElementById('siteSelector');
    const selectedSite = siteSelector.value;
    if (selectedSite) {
        fetchAndDisplayOutboundPlanning(selectedSite);
        fetchRTSData(selectedSite);
        fetchProblemSolveData(selectedSite);
        fetchAndUpdateHeldData(selectedSite);
    }
}


// Run setup when the page loads
window.addEventListener('load', function() {
    console.log('Window loaded, setting up site selector');
    setupSiteSelector();
    updateSiteData();
});

// Function to generate Rodeo URL
function generateRodeoURL(site, cpt) {
    const baseURL = "https://rodeo-iad.amazon.com/";
    const cptMap = {
        "06:20": "06%3A20",
        "11:20": "11%3A20",
        "14:20": "14%3A20",
        "18:20": "18%3A20",
        "00:20": "00%3A20",
        "01:35": "01%3A35",
        "05:35": "05%3A35",
        "10:25": "10%3A25",
        "15:05": "15%3A05"
    };

    const encodedCPT = cptMap[cpt] || cpt;

    return `${baseURL}${site}/Dwell?yAxis=PROCESS_PATH&zAxis=WORK_POOL&shipmentTypes=ALL&DwellTimeGreaterThan=0&DwellTimeLessThan=0&exSDRange.quickRange=DAILY_EXACT&exSDRange.dailyExact=${encodedCPT}&giftOption=ALL&fulfillmentServiceClass=ALL&fracs=ALL&isEulerExSDMiss=ALL&isEulerPromiseMiss=ALL&isEulerUpgraded=ALL&isReactiveTransfer=ALL&workPool=PredictedCharge&workPool=PlannedShipment&_workPool=on&workPool=ReadyToPick&workPool=ReadyToPickHardCapped&workPool=ReadyToPickUnconstrained&workPool=PickingNotYetPicked&workPool=PickingNotYetPickedPrioritized&workPool=PickingNotYetPickedNotPrioritized&workPool=PickingNotYetPickedHardCapped&workPool=CrossdockNotYetPicked&_workPool=on&workPool=PickingPicked&workPool=PickingPickedInProgress&workPool=PickingPickedInTransit&workPool=PickingPickedRouting&workPool=PickingPickedAtDestination&workPool=Inducted&workPool=RebinBuffered&workPool=Sorted&workPool=GiftWrap&workPool=Packing&workPool=Scanned&workPool=ProblemSolving&workPool=ProcessPartial&workPool=SoftwareException&workPool=Crossdock&workPool=PreSort&workPool=TransshipSorted&workPool=Palletized&_workPool=on&_workPool=on&processPath=PPAFE1&processPath=PPAFE2&processPath=PPSingleBoxDrop1&processPath=PPSingleLarge&processPath=PPSingleMedium&processPath=PPSingleSmall&processPath=PPSmartPac&processPath=PPHighQuantityShipment&processPath=PPOrderPickVNA&processPath=PPPickToRebin&processPath=PPRecycle&processPath=PPSingle&processPath=PPSplitDemand&processPath=PPAFE1&processPath=PPAFE2&processPath=PPSingleBoxDrop1&processPath=PPSingleLarge&processPath=PPSingleMedium&processPath=PPSingleSmall&processPath=PPSmartPac&processPath=PPHighQuantityShipment&processPath=PPOrderPickVNA&processPath=PPPickToRebin&processPath=PPRecycle&processPath=PPSingle&processPath=PPSplitDemand&processPath=&minPickPriority=MIN_PRIORITY&shipMethod=&shipOption=&sortCode=&fnSku=`;
}

let rodeoInfoBox = document.createElement('div');
rodeoInfoBox.id = 'rodeoInfoBox';
rodeoInfoBox.style.position = 'fixed';
rodeoInfoBox.style.left = '240px'; // Adjust this value to position it next to the currentCPTInfoBox
rodeoInfoBox.style.top = '360px'; // Same top position as currentCPTInfoBox
rodeoInfoBox.style.border = '1px solid black';
rodeoInfoBox.style.padding = '10px';
rodeoInfoBox.style.width = '310px'; // Adjust width as needed
rodeoInfoBox.style.backgroundColor = 'white';
rodeoInfoBox.style.display = 'none';
document.body.appendChild(rodeoInfoBox);

function updateRodeoLink() {
    const site = document.getElementById('siteSelector').value;
    const cpt = document.getElementById('cptSelect').value;
    if (site && cpt) {
        const url = generateRodeoURL(site, cpt);
        let rodeoLink = document.getElementById('rodeoLink');
        if (rodeoLink) {
            rodeoLink.href = url;
        } else {
            rodeoLink = document.createElement('a');
            rodeoLink.id = 'rodeoLink';
            rodeoLink.href = url;
            rodeoLink.target = '_blank';
            rodeoLink.textContent = 'Open in Rodeo';
            rodeoLink.style.display = 'block';
            rodeoLink.style.marginBottom = '10px';
            rodeoInfoBox.insertBefore(rodeoLink, rodeoInfoBox.firstChild);
        }
    }
}
function fetchAndDisplayRodeoInfo() {
    console.log('--- Starting fetchAndDisplayRodeoInfo ---');
    const site = document.getElementById('siteSelector').value;
    const cpt = document.getElementById('cptSelect').value;

    console.log(`Site: ${site}, CPT: ${cpt}`);

    if (!site || !cpt) {
        console.log('Site or CPT not selected, exiting function');
        rodeoInfoBox.innerHTML = '<p>Please select a site and CPT first.</p>';
        return;
    }

    updateRodeoLink();

    const url = generateRodeoURL(site, cpt);
    console.log('Fetching Rodeo data from URL:', url);

    rodeoInfoBox.innerHTML = '<p>Loading Rodeo data...</p>';

    GM_xmlhttpRequest({
        method: 'GET',
        url: url,
        onload: function(response) {
            console.log(`Rodeo response received. Status: ${response.status}`);
            if (response.status === 200) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(response.responseText, 'text/html');

                let html = '';

                function createWorkPoolTable(categoryName, tableSelector) {
                    console.log(`Creating table for ${categoryName}`);
                    let tableHtml = `<h3>${categoryName}</h3>`;
                    tableHtml += '<table border="1" style="border-collapse: collapse; margin-bottom: 20px;">';
                    tableHtml += '<tr><th></th><th>-Total-</th><th>Earlier Total</th><th>Range Total</th></tr>';

                    const table = doc.querySelector(tableSelector);
                    if (table) {
                        const rows = table.querySelectorAll('tr:not(.header-row):not(.grand-total)');
                        rows.forEach(row => {
                            const cells = row.cells;
                            if (cells.length >= 4) {
                                tableHtml += `<tr>
                                    <td>${cells[0].textContent.trim()}</td>
                                    <td>${cells[1].textContent.trim()}</td>
                                    <td>${cells[2].textContent.trim()}</td>
                                    <td>${cells[3].textContent.trim()}</td>
                                </tr>`;
                            }
                        });

                        // Add grand total row if it exists
                        const grandTotal = table.querySelector('tr.grand-total');
                        if (grandTotal) {
                            const cells = grandTotal.cells;
                            tableHtml += `<tr>
                                <td>${cells[0].textContent.trim()}</td>
                                <td>${cells[1].textContent.trim()}</td>
                                <td>${cells[2].textContent.trim()}</td>
                                <td>${cells[3].textContent.trim()}</td>
                            </tr>`;
                        }
                    } else {
                        console.warn(`Table not found for selector: ${tableSelector}`);
                    }

                    tableHtml += '</table>';
                    return tableHtml;
                }

                html += createWorkPoolTable('Total', '.result-table');
                html += createWorkPoolTable('ReadyToPick', '#ReadyToPickTable');
                html += createWorkPoolTable('PickingNotYetPicked', '#PickingNotYetPickedTable');

                console.log('HTML generated for Rodeo info tables');
                rodeoInfoBox.innerHTML = html;

                // Extract OrderpickVNA Total
                const totalTable = doc.querySelector('.result-table');
                let orderPickVNATotal = 0;
                if (totalTable) {
                    console.log('Total table found, searching for PPOrderPickVNA');
                    const rows = totalTable.querySelectorAll('tr:not(.header-row):not(.grand-total)');
                    rows.forEach(row => {
                        const processPath = row.cells[0].textContent.trim();
                        const total = parseInt(row.cells[1].textContent.trim().replace(/,/g, ''), 10);
                        console.log(`Process Path: ${processPath}, Total: ${total}`);
                        if (processPath === 'PPOrderPickVNA') {
                            orderPickVNATotal = total;
                            console.log('Found PPOrderPickVNA total:', orderPickVNATotal);
                        }
                    });
                } else {
                    console.warn('Total table not found');
                }

                // Store the OrderpickVNA Total
                document.body.dataset.orderPickVNATotal = orderPickVNATotal;
                console.log('Stored OrderpickVNA Total:', orderPickVNATotal);

                // Use Promise to ensure correct order of operations
                Promise.resolve()
                    .then(() => {
                        console.log('Updating math table calculations');
                        return updateMathTableCalculations();
                    })
                    .then(() => {
                        console.log('Waiting for production table to load');
                        return waitForProductionTable();
                    })
                    .then(() => {
                        console.log('Calling updateVNAPackRecommendations');
                        return updateVNAPackRecommendations();
                    })
                    .catch(error => {
                        console.error('Error in promise chain:', error);
                    });

            } else {
                console.error('Error fetching Rodeo data. Status:', response.status);
                rodeoInfoBox.innerHTML = `<p>Error fetching Rodeo data. Status: ${response.status}</p>`;
            }
        },
        onerror: function(error) {
            console.error('Rodeo fetch error:', error);
            rodeoInfoBox.innerHTML = `<p>Error fetching Rodeo data: ${error.message || 'Unknown error'}</p>`;
        }
    });

    console.log('--- Ending fetchAndDisplayRodeoInfo ---');
}

function fetchAndDisplayExSDInfo() {
    console.log('fetchAndDisplayExSDInfo: Starting function');

    const exSDBox = document.getElementById('exSDBox');
    const siteSelector = document.getElementById('siteSelector');

    if (!exSDBox) {
        console.error('fetchAndDisplayExSDInfo: exSDBox element not found');
        return;
    }

    if (!siteSelector) {
        console.error('fetchAndDisplayExSDInfo: Site selector element not found');
        return;
    }

   if (!siteSelector) {
       console.error('fetchAndDisplayExSDInfo: Site selector element not found');
       return;
   }

   const site = siteSelector.value;
   if (!site) {
       console.log('fetchAndDisplayExSDInfo: Site not selected, exiting function');
       if (typeof exSDBox !== 'undefined' && exSDBox) {
           exSDBox.innerHTML = '<p>Please select a site first.</p>';
       }
       return;
   }

   if (typeof exSDBox === 'undefined' || !exSDBox) {
       console.error('fetchAndDisplayExSDInfo: exSDBox element not found');
       return;
   }

   const url = `https://rodeo-iad.amazon.com/${site}/ExSD?yAxis=PROCESS_PATH&zAxis=WORK_POOL&shipmentTypes=ALL&exSDRange.quickRange=NEXT_3_DAYS&exSDRange.dailyStart=00%3A00&exSDRange.dailyEnd=00%3A00&giftOption=ALL&fulfillmentServiceClass=ALL&fracs=ALL&isEulerExSDMiss=ALL&isEulerPromiseMiss=ALL&isEulerUpgraded=ALL&isReactiveTransfer=ALL&_workPool=on&workPool=ReadyToPick&workPool=ReadyToPickHardCapped&workPool=ReadyToPickUnconstrained&workPool=PickingNotYetPicked&workPool=PickingNotYetPickedPrioritized&workPool=PickingNotYetPickedNotPrioritized&workPool=PickingNotYetPickedHardCapped&workPool=CrossdockNotYetPicked&_workPool=on&workPool=PickingPicked&workPool=PickingPickedInProgress&workPool=PickingPickedInTransit&workPool=PickingPickedRouting&workPool=PickingPickedAtDestination&workPool=Inducted&workPool=RebinBuffered&workPool=Sorted&workPool=GiftWrap&workPool=Packing&workPool=Scanned&workPool=ProblemSolving&workPool=ProcessPartial&workPool=SoftwareException&workPool=Crossdock&workPool=PreSort&workPool=TransshipSorted&workPool=Palletized&_workPool=on&_workPool=on&processPath=PPPickToRebin&processPath=PPOrderPickVNA&processPath=PPSingle&processPath=PPSplitDemand&processPath=&minPickPriority=MIN_PRIORITY&shipMethod=&shipOption=&sortCode=&fnSku=`;

   console.log('fetchAndDisplayExSDInfo: Fetching ExSD data from URL:', url);
   exSDBox.innerHTML = '<p>Loading ExSD data...</p>';

   if (typeof GM_xmlhttpRequest === 'undefined') {
       console.error('fetchAndDisplayExSDInfo: GM_xmlhttpRequest not available');
       exSDBox.innerHTML = '<p>Error: Request functionality not available</p>';
       return;
   }

   GM_xmlhttpRequest({
       method: 'GET',
       url: url,
       onload: function(response) {
           console.log(`fetchAndDisplayExSDInfo: ExSD response received. Status: ${response.status}`);
           if (response.status === 200) {
               try {
                   const parser = new DOMParser();
                   const doc = parser.parseFromString(response.responseText, 'text/html');

                   function createWorkPoolTable(categoryName, tableSelector) {
                       console.log(`fetchAndDisplayExSDInfo: Creating table for ${categoryName}`);
                       let tableHtml = `<div class="category-header">${categoryName}</div>`;
                       tableHtml += '<table style="width: 100%; border-collapse: collapse;">';

                       const table = doc.querySelector(tableSelector);
                       if (!table) {
                           console.warn(`fetchAndDisplayExSDInfo: Table not found for selector ${tableSelector}`);
                           tableHtml += '<tr><td>No data available</td></tr>';
                           tableHtml += '</table>';
                           return tableHtml;
                       }

                       // Get headers
                       const headerRow = table.querySelector('tr.header-row');
                       if (headerRow && headerRow.cells) {
                           const headers = Array.from(headerRow.cells).map(cell => cell.textContent.trim());

                           // Create header row with blue background
                           tableHtml += '<tr style="background-color: #e6eff7;">';
                           tableHtml += '<th style="text-align: left; font-weight: normal;">Total</th>';
                           tableHtml += '<th style="text-align: right;">Range Total</th>';
                           // Add dynamic CPT headers (skip first 4 standard columns)
                           if (headers.length > 4) {
                               headers.slice(4).forEach(header => {
                                   tableHtml += `<th style="text-align: right;">${header}</th>`;
                               });
                           }
                           tableHtml += '</tr>';

                           // Add data rows
                           const rows = table.querySelectorAll('tr:not(.header-row):not(.grand-total)');
                           rows.forEach(row => {
                               if (!row.cells || row.cells.length < 4) {
                                   return;
                               }

                               const cells = row.cells;
                               tableHtml += '<tr>';

                               // Process path cell with light blue background for certain rows
                               const processPath = cells[0].textContent.trim();
                               const isSpecialRow = processPath.includes('PPOrderPickVNA') ||
                                                  processPath.includes('PPPickToRebin');
                               tableHtml += `<td style="background-color: ${isSpecialRow ? '#e6eff7' : '#f5f5f5'};">
                                                ${processPath}
                                            </td>`;

                               // Range Total column (was cells[3])
                               tableHtml += `<td style="text-align: right; background-color: #ffffff;">${cells[3] ? cells[3].textContent.trim() : ''}</td>`;

                               // Additional dynamic columns (skip Total, Earlier Total, and Later Total)
                               for (let i = 4; i < cells.length; i++) {
                                   tableHtml += `<td style="text-align: right; background-color: #ffffff;">${cells[i].textContent.trim()}</td>`;
                               }
                               tableHtml += '</tr>';
                           });

                           // Add total row
                           const grandTotal = table.querySelector('tr.grand-total');
                           if (grandTotal && grandTotal.cells) {
                               tableHtml += '<tr style="background-color: #e6eff7;">';
                               const totalCells = grandTotal.cells;

                               // First cell (process path)
                               tableHtml += `<td style="text-align: left;">
                                                ${totalCells[0] ? totalCells[0].textContent.trim() : ''}
                                            </td>`;

                               // Range Total column
                               tableHtml += `<td style="text-align: right;">
                                                ${totalCells[3] ? totalCells[3].textContent.trim() : ''}
                                            </td>`;

                               // Additional columns
                               for (let i = 4; i < totalCells.length; i++) {
                                   tableHtml += `<td style="text-align: right;">
                                                    ${totalCells[i].textContent.trim()}
                                                </td>`;
                               }
                               tableHtml += '</tr>';
                           }
                       } else {
                           console.warn(`fetchAndDisplayExSDInfo: Header row not found for table ${tableSelector}`);
                           tableHtml += '<tr><td>Header row not found</td></tr>';
                       }

                       tableHtml += '</table>';
                       return tableHtml;
                   }

                   let html = '';
                   html += createWorkPoolTable('Total', '.result-table');
                   html += createWorkPoolTable('ReadyToPick', '#ReadyToPickTable');
                   html += createWorkPoolTable('PickingNotYetPicked', '#PickingNotYetPickedTable');

                   console.log('fetchAndDisplayExSDInfo: HTML generated for ExSD info tables');
                   exSDBox.innerHTML = html;

               } catch (error) {
                   console.error('fetchAndDisplayExSDInfo: Error parsing response:', error);
                   exSDBox.innerHTML = '<p>Error processing ExSD data</p>';
               }
           } else {
               console.error('fetchAndDisplayExSDInfo: Request failed with status:', response.status);
               exSDBox.innerHTML = `<p>Error fetching ExSD data. Status: ${response.status}</p>`;
           }
       },
       onerror: function(error) {
           console.error('fetchAndDisplayExSDInfo: Request error:', error);
           exSDBox.innerHTML = `<p>Error fetching ExSD data: ${error.message || 'Unknown error'}</p>`;
       }
   });

   console.log('fetchAndDisplayExSDInfo: Function ending');
}

// Event listeners with validation
function setupExSDEventListeners() {
   const siteSelector = document.getElementById('siteSelector');
   const refreshButton = document.getElementById('refreshButton');

   if (siteSelector) {
       siteSelector.addEventListener('change', fetchAndDisplayExSDInfo);
   } else {
       console.warn('setupExSDEventListeners: Site selector not found');
   }

   if (refreshButton) {
       refreshButton.addEventListener('click', fetchAndDisplayExSDInfo);
   } else {
       console.warn('setupExSDEventListeners: Refresh button not found');
   }
}

// Initialize event listeners
if (document.readyState === 'loading') {
   document.addEventListener('DOMContentLoaded', setupExSDEventListeners);
   window.addEventListener('load', fetchAndDisplayExSDInfo);
} else {
   setupExSDEventListeners();
   fetchAndDisplayExSDInfo();
}

function generateNextCPTRodeoURL(site, currentCPT) {
    const nextCPT = getNextCPT(currentCPT);
    return generateRodeoURL(site, nextCPT);
}
function fetchAndDisplayNextCPTRodeoInfo() {
    console.log('--- Starting fetchAndDisplayNextCPTRodeoInfo ---');
    const site = document.getElementById('siteSelector').value;
    const currentCPT = document.getElementById('cptSelect').value;
    const nextCPT = getNextCPT(currentCPT);

    console.log(`Site: ${site}, Next CPT: ${nextCPT}`);

    if (!site || !currentCPT) {
        console.log('Site or CPT not selected, exiting function');
        nextCPTRodeoInfoBox.innerHTML = '<p>Please select a site and CPT first.</p>';
        return;
    }

    const url = generateRodeoURL(site, nextCPT);
    console.log('Fetching Next CPT Rodeo data from URL:', url);

    nextCPTRodeoInfoBox.innerHTML = '<p>Loading Next CPT Rodeo data...</p>';

    GM_xmlhttpRequest({
        method: 'GET',
        url: url,
        onload: function(response) {
            console.log(`Next CPT Rodeo response received. Status: ${response.status}`);
            if (response.status === 200) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(response.responseText, 'text/html');

                let html = '';

                function createWorkPoolTable(categoryName, tableSelector) {
                    console.log(`Creating table for ${categoryName}`);
                    let tableHtml = `<h3>${categoryName}</h3>`;
                    tableHtml += '<table border="1" style="border-collapse: collapse; margin-bottom: 20px;">';
                    tableHtml += '<tr><th></th><th>-Total-</th><th>Earlier Total</th><th>Range Total</th></tr>';

                    const table = doc.querySelector(tableSelector);
                    if (table) {
                        const rows = table.querySelectorAll('tr:not(.header-row):not(.grand-total)');
                        rows.forEach(row => {
                            const cells = row.cells;
                            if (cells.length >= 4) {
                                tableHtml += `<tr>
                                    <td>${cells[0].textContent.trim()}</td>
                                    <td>${cells[1].textContent.trim()}</td>
                                    <td>${cells[2].textContent.trim()}</td>
                                    <td>${cells[3].textContent.trim()}</td>
                                </tr>`;
                            }
                        });

                        // Add grand total row if it exists
                        const grandTotal = table.querySelector('tr.grand-total');
                        if (grandTotal) {
                            const cells = grandTotal.cells;
                            tableHtml += `<tr>
                                <td>${cells[0].textContent.trim()}</td>
                                <td>${cells[1].textContent.trim()}</td>
                                <td>${cells[2].textContent.trim()}</td>
                                <td>${cells[3].textContent.trim()}</td>
                            </tr>`;
                        }
                    } else {
                        console.warn(`Table not found for selector: ${tableSelector}`);
                    }

                    tableHtml += '</table>';
                    return tableHtml;
                }

                html += createWorkPoolTable('Total', '.result-table');
                html += createWorkPoolTable('ReadyToPick', '#ReadyToPickTable');
                html += createWorkPoolTable('PickingNotYetPicked', '#PickingNotYetPickedTable');

                console.log('HTML generated for Next CPT Rodeo info tables');
                nextCPTRodeoInfoBox.innerHTML = html;

                // Extract OrderpickVNA Total for Next CPT
                const totalTable = doc.querySelector('.result-table');
                let nextOrderPickVNATotal = 0;
                if (totalTable) {
                    console.log('Next CPT Total table found, searching for PPOrderPickVNA');
                    const rows = totalTable.querySelectorAll('tr:not(.header-row):not(.grand-total)');
                    rows.forEach(row => {
                        const processPath = row.cells[0].textContent.trim();
                        const total = parseInt(row.cells[1].textContent.trim().replace(/,/g, ''), 10);
                        console.log(`Next CPT Process Path: ${processPath}, Total: ${total}`);
                        if (processPath === 'PPOrderPickVNA') {
                            nextOrderPickVNATotal = total;
                            console.log('Found Next CPT PPOrderPickVNA total:', nextOrderPickVNATotal);
                        }
                    });
                } else {
                    console.warn('Next CPT Total table not found');
                }

                // Store the Next CPT OrderpickVNA Total
                document.body.dataset.nextOrderPickVNATotal = nextOrderPickVNATotal;
                console.log('Stored Next CPT OrderpickVNA Total:', nextOrderPickVNATotal);

                // Use Promise to ensure correct order of operations
                Promise.resolve()
                    .then(() => {
                        console.log('Updating next CPT math table calculations');
                        return updateNextCPTMathTableCalculations();
                    })
                    .then(() => {
                        console.log('Waiting for next CPT production table to load');
                        return waitForNextCPTProductionTable();
                    })
                    .then(() => {
                        console.log('Calling updateNextCPTVNAPackRecommendations');
                        return updateNextCPTVNAPackRecommendations();
                    })
                    .then(() => {
                        console.log('Calling updateNextCPTProductionTable');
                        return updateNextCPTProductionTable();
                    })
                    .catch(error => {
                        console.error('Error in next CPT promise chain:', error);
                    });

            } else {
                console.error('Error fetching Next CPT Rodeo data. Status:', response.status);
                nextCPTRodeoInfoBox.innerHTML = `<p>Error fetching Next CPT Rodeo data. Status: ${response.status}</p>`;
            }
        },
        onerror: function(error) {
            console.error('Next CPT Rodeo fetch error:', error);
            nextCPTRodeoInfoBox.innerHTML = `<p>Error fetching Next CPT Rodeo data: ${error.message || 'Unknown error'}</p>`;
        }
    });
    console.log('--- Ending fetchAndDisplayNextCPTRodeoInfo ---');
}

let nextCPTRodeoInfoBox = document.createElement('div');
nextCPTRodeoInfoBox.id = 'nextCPTRodeoInfoBox';
nextCPTRodeoInfoBox.style.position = 'fixed';
nextCPTRodeoInfoBox.style.left = '240px';
nextCPTRodeoInfoBox.style.top = '800px'; // Position it below the current CPT Rodeo box
nextCPTRodeoInfoBox.style.border = '1px solid black';
nextCPTRodeoInfoBox.style.padding = '10px';
nextCPTRodeoInfoBox.style.width = '310px';
nextCPTRodeoInfoBox.style.backgroundColor = 'white';
nextCPTRodeoInfoBox.style.display = 'none';
document.body.appendChild(nextCPTRodeoInfoBox);


function waitForProductionTable(attempts = 0, maxAttempts = 10) {
    return new Promise((resolve, reject) => {
        const productionTable = document.getElementById('productionGraphic');
        if (productionTable) {
            console.log('Production table found');
            resolve();
        } else if (attempts < maxAttempts) {
            console.log(`Production table not found, attempt ${attempts + 1}. Retrying in 500ms...`);
            setTimeout(() => {
                waitForProductionTable(attempts + 1, maxAttempts).then(resolve).catch(reject);
            }, 5000);
        } else {
            reject(new Error('Production table not found after maximum attempts'));
        }
    });
}
function updateVNAPackRecommendations() {
    return new Promise((resolve) => {
        console.log('--- Starting updateVNAPackRecommendations ---');
        const productionTable = document.getElementById('productionGraphic');
        const scheduleTable = document.querySelector('#SelectedCPTSchedule');

        if (!productionTable || !scheduleTable) {
            console.error('Production table or schedule table not found');
            resolve();
            return;
        }

        const vnaPackRow = Array.from(productionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');

        if (!vnaPackRow) {
            console.error('VNA Pack row not found');
            resolve();
            return;
        }

        const orderPickVNATotal = parseInt(document.body.dataset.orderPickVNATotal) || 0;
        const productionWindows = getProductionWindows(scheduleTable);
        const expectedRates = getExpectedRates(productionTable, vnaPackRow, productionWindows);
        const cptTime = document.getElementById('cptSelect').value;

        // Calculate total available time
        let totalAvailableTime = productionWindows.reduce((total, window) => total + window.durationInHours, 0);

        // Calculate required HC
        let requiredHC = Math.ceil(orderPickVNATotal / (totalAvailableTime * expectedRates[0]));

        // Update VNA Pack row
        for (let i = 1; i < vnaPackRow.cells.length; i++) {
            if (i <= productionWindows.length) {
                vnaPackRow.cells[i].textContent = requiredHC;
            } else {
                vnaPackRow.cells[i].textContent = 'X';
                vnaPackRow.cells[i].style.backgroundColor = '';
            }
        }

        // Update VNA Pick HC based on VNA Pack HC
        updateVNAPickHCBasedOnPackHC(productionTable);

        updateOutboundTotals(productionTable);
        updateProductionGraphic();
        console.log('--- Ending updateVNAPackRecommendations ---');
        resolve();
    });
}
function calculateVNAHCRecommendations(orderPickVNATotal, productionWindows, expectedRates, cptTime) {
    console.log("-------- Starting VNA HC Recommendations Calculation --------");
    console.log("OrderPickVNA Total:", orderPickVNATotal);
    console.log("Production Windows:", productionWindows);
    console.log("Expected Rates:", expectedRates);
    console.log("CPT Time:", cptTime);

    let totalCapacity = 0;
    let totalTimeUsed = 0;

    // Calculate total capacity
    for (let i = 0; i < productionWindows.length; i++) {
        let { timeWindow, durationInHours } = productionWindows[i];
        const rate = expectedRates[i];

        totalTimeUsed += durationInHours;
        const windowCapacity = rate * durationInHours;
        totalCapacity += windowCapacity;

        console.log(`Window ${i + 1} capacity: ${windowCapacity}`);
    }

    console.log("Total time used for calculations:", totalTimeUsed, "hours");
    console.log("Total Available Capacity:", totalCapacity);

    // Calculate stable HC
    let stableHC = Math.ceil(orderPickVNATotal / totalCapacity);
    stableHC = Math.max(1, stableHC); // Ensure at least 1 HC

    console.log("Calculated Stable HC:", stableHC);

    // Apply stable HC to all windows
    const recommendations = productionWindows.map(() => stableHC);

    console.log("Final Recommendations:", recommendations);
    console.log("-------- End of VNA HC Recommendations Calculation --------");

    return recommendations;
}
function updateVNAPackRow(vnaPackRow, recommendations) {
    console.log('Updating VNA Pack Row');
    for (let i = 0; i < recommendations.length; i++) {
        const cell = vnaPackRow.cells[i + 1]; // +1 to skip the first cell (row header)
        if (cell) {
            const recommendedHC = recommendations[i];
            cell.textContent = recommendedHC;
            cell.style.backgroundColor = 'lightgreen';
            cell.dataset.recommended = recommendedHC;
            console.log(`Updated cell ${i + 1}: ${recommendedHC}`);
        } else {
            console.error(`Cell ${i + 1} not found in VNA Pack row`);
        }
    }
}

function getRodeoTotalValue() {
    const rodeoInfoBox = document.getElementById('rodeoInfoBox');
    if (!rodeoInfoBox) return 0;

    // Find the first table (Total table)
    const totalTable = rodeoInfoBox.querySelector('table');
    if (!totalTable) return 0;

    // Find the last row of the Total table (which should be the Total row)
    const rows = totalTable.querySelectorAll('tr');
    const lastRow = rows[rows.length - 1];
    if (!lastRow) return 0;

    // Get the value from the second cell (Total column)
    const totalCell = lastRow.cells[1];
    if (!totalCell) return 0;

    const totalValue = parseInt(totalCell.textContent.trim().replace(/,/g, ''), 10);
    return isNaN(totalValue) ? 0 : totalValue;
}
function updateVNAPickHCBasedOnPackHC(productionTable) {
    const packRow = Array.from(productionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');
    const pickRow = Array.from(productionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pick');
    const packRateRow = packRow ? packRow.nextElementSibling : null;
    const pickRateRow = pickRow ? pickRow.nextElementSibling : null;

    if (!packRow || !pickRow || !packRateRow || !pickRateRow) {
        console.error('Required rows not found for updating VNA Pick HC');
        return;
    }

    for (let i = 1; i < packRow.cells.length; i++) {
        const packHC = parseInt(packRow.cells[i].textContent);
        const packRate = parseFloat(packRateRow.cells[i].textContent);
        const pickRate = parseFloat(pickRateRow.cells[i].textContent);

        if (!isNaN(packHC) && !isNaN(packRate) && !isNaN(pickRate) && pickRate > 0) {
            const newPickHC = Math.ceil((packHC * packRate) / pickRate);
            if (pickRow.cells[i].textContent === 'X' || !pickRow.cells[i].dataset.userOverride) {
                pickRow.cells[i].textContent = newPickHC;
                pickRow.cells[i].style.backgroundColor = '';
            }
        }
    }

    console.log('VNA Pick HC updated based on VNA Pack HC');
    updateOutboundTotals(productionTable);
}

function addVNARateChangeListeners(productionTable) {
    const vnaRows = ['VNA Pack', 'VNA Pick'];
    vnaRows.forEach(rowName => {
        const row = Array.from(productionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === rowName);
        if (row) {
            // Add listeners to HC cells
            for (let i = 1; i < row.cells.length; i++) {
                row.cells[i].addEventListener('input', handleVNARateChange);
            }

            // Add listeners to rate cells
            const rateRow = row.nextElementSibling;
            if (rateRow) {
                for (let i = 1; i < rateRow.cells.length; i++) {
                    rateRow.cells[i].addEventListener('input', handleVNARateChange);
                }
            }
        }
    });
}
function handleVNAHCChange(event) {
    const cell = event.target;
    const row = cell.closest('tr');
    const productionTable = row.closest('table');

    updateVNAPickHCBasedOnPackHC(productionTable);
    updateOutboundTotals(productionTable);
    updateProductionGraphic();
}

function handleVNARateChange(event) {
    const cell = event.target;
    const row = cell.closest('tr');
    const productionTable = row.closest('table');

    updateVNAPickHCBasedOnPackHC(productionTable);
    updateOutboundTotals(productionTable);
    updateProductionGraphic();
}
function updateNextCPTProductionTable() {
    console.log("Starting updateNextCPTProductionTable");
    const nextCPTScheduleTable = document.querySelector('#NextCPTSchedule');
    const nextProductionTable = document.getElementById('nextCPTProductionGraphicTable');

    if (!nextCPTScheduleTable || !nextProductionTable) {
        console.error("Required tables not found for next CPT. Exiting function.");
        return;
    }

    const nextCPTMixedSet4Value = getNextCPTSelectedRiskModelValue();
    console.log("Next CPT MIXED Set 4 Value:", nextCPTMixedSet4Value);

    if (!nextCPTMixedSet4Value) {
        console.log("Next CPT MIXED Set 4 value not found. Exiting function.");
        return;
    }

    const productionWindows = getProductionWindows(nextCPTScheduleTable);
    console.log("Next CPT Production Windows:", productionWindows);

    if (productionWindows.length === 0) {
        console.log("No production windows found for next CPT. Exiting function.");
        return;
    }

    // Get the next CPT time
    const nextCPT = getNextCPT(document.getElementById('cptSelect').value);
    console.log("Next CPT Time:", nextCPT);

    getNextCPTPickRebinPackRow(nextProductionTable)
        .then(pickRebinPackRow => {
            console.log("Next CPT Pick2Rebin Pack Row:", pickRebinPackRow);

            const expectedRates = getExpectedRates(nextProductionTable, pickRebinPackRow, productionWindows);
            console.log("Next CPT Expected Rates:", expectedRates);

            if (productionWindows.length !== expectedRates.length) {
                console.log(`Mismatch between production windows (${productionWindows.length}) and expected rates (${expectedRates.length}) for next CPT.`);
                console.log("Will use available rates and windows.");
            }

            const recommendations = calculateHCRecommendations(nextCPTMixedSet4Value, productionWindows, expectedRates, {}, nextCPT);
            console.log("Calculated Next CPT Recommendations:", recommendations);

            updateNextCPTPickRebinPackRow(pickRebinPackRow, recommendations);
            console.log("Next CPT Pick2Rebin Pack Row updated");
            addNextCPTManualOverrideListeners(pickRebinPackRow);

            // Update Pick HC after Pack HC is set for next CPT
            updateNextCPTPickHCBasedOnPackHC(nextProductionTable);

            // Update VNA recommendations for next CPT
            updateNextCPTVNAPackRecommendations();
            updateNextCPTVNAPickHCBasedOnPackHC(nextProductionTable);

            updateOutboundTotals(nextProductionTable);
            updateNextCPTProductionGraphic();
            updatePlanSummary2();
        })
        .catch(error => {
            console.error("Error in updateNextCPTProductionTable:", error);
        });
}

// Function to get the MIXED Set 4 value from the next CPT math table
function getNextCPTMixedSet4Value() {
    const nextCPTMathTable = document.querySelector('#nextCPTMathTableContainer table');
    if (!nextCPTMathTable) {
        console.error('Next CPT Math table not found');
        return null;
    }
    const mixedRow = Array.from(nextCPTMathTable.rows).find(row => row.cells[0].textContent.trim() === 'MIXED');
    if (!mixedRow) {
        console.error('MIXED row not found in Next CPT Math table');
        return null;
    }
    const value = parseInt(mixedRow.cells[4].textContent);
    if (isNaN(value)) {
        console.error('Invalid MIXED Set 4 value in Next CPT Math table:', mixedRow.cells[4].textContent);
        return null;
    }
    console.log('Next CPT MIXED Set 4 value:', value);
    return value;
}

// Function to get the Pick2Rebin Pack row for the next CPT table
function getNextCPTPickRebinPackRow(nextProductionTable, retries = 5) {
    console.log("Attempting to find Next CPT Pick2Rebin Pack row");
    console.log("Next CPT Production table rows:", nextProductionTable.rows.length);

    return new Promise((resolve, reject) => {
        function findRow() {
            for (let i = 0; i < nextProductionTable.rows.length; i++) {
                const row = nextProductionTable.rows[i];
                const firstCellContent = row.cells[0].textContent.trim();
                console.log(`Row ${i} first cell content: "${firstCellContent}"`);

                if (firstCellContent.includes('Pick2Rebin Pack')) {
                    console.log("Next CPT Pick2Rebin Pack row found at index:", i);
                    resolve(row);
                    return;
                }
            }

            if (retries > 0) {
                console.log(`Next CPT Pick2Rebin Pack row not found. Retrying... (${retries} attempts left)`);
                setTimeout(() => {
                    retries--;
                    findRow();
                }, 1000);
            } else {
                console.error('Next CPT Pick2Rebin Pack row not found after multiple attempts');
                console.log("Next CPT Table structure:", nextProductionTable.innerHTML);
                reject('Row not found');
            }
        }

        findRow();
    });
}

function calculateNextCPTHCRecommendations(riskModelValue, productionWindows, expectedRates, userOverrides = {}, cptTime) {
    console.log("-------- Starting Next CPT HC Recommendations Calculation --------");
    console.log("Risk Model Value (Total Units to Process for Next CPT):", riskModelValue);
    console.log("Next CPT Production Windows:", productionWindows);
    console.log("Next CPT Expected Rates:", expectedRates);
    console.log("Next CPT User Overrides:", userOverrides);
    console.log("Next CPT Time:", cptTime);

    let totalCapacity = 0;
    let totalOverrideCapacity = 0;
    let totalTimeUsed = 0;

    const cptMinutes = convertToMinutesSinceMidnight(cptTime);

    // Calculate total capacity and override capacity
    for (let i = 0; i < productionWindows.length; i++) {
        let { timeWindow, durationInHours } = productionWindows[i];
        const rate = expectedRates[i];

        console.log(`\nProcessing next CPT window ${i + 1}: ${timeWindow}`);
        console.log(`Original duration: ${durationInHours} hours`);

        let [startTime, endTime] = timeWindow.split(' to ');
        let startMinutes = convertToMinutesSinceMidnight(startTime);
        let endMinutes = convertToMinutesSinceMidnight(endTime);

        // Adjust if the window crosses midnight
        if (endMinutes < startMinutes) endMinutes += 24 * 60;

        // Adjust if CPT is on the next day
        let adjustedCptMinutes = cptMinutes;
        if (cptMinutes < startMinutes) adjustedCptMinutes += 24 * 60;

        // Adjust duration if it's the last window or if CPT falls within this window
        if (i === productionWindows.length - 1 || adjustedCptMinutes <= endMinutes) {
            if (adjustedCptMinutes < endMinutes) {
                durationInHours = (adjustedCptMinutes - startMinutes) / 60;
            } else {
                durationInHours = (endMinutes - startMinutes) / 60;
            }
            console.log(`Adjusted next CPT window duration: ${durationInHours} hours`);
        }

        totalTimeUsed += durationInHours;
        const windowCapacity = rate * durationInHours;

        if (i in userOverrides) {
            totalOverrideCapacity += userOverrides[i] * windowCapacity;
        } else {
            totalCapacity += windowCapacity;
        }

        console.log(`Next CPT Window ${i + 1} capacity: ${windowCapacity}`);
        console.log(`Total capacity so far: ${totalCapacity}`);
        console.log(`Total override capacity so far: ${totalOverrideCapacity}`);

        // Stop processing if we've reached or passed the CPT
        if (adjustedCptMinutes <= endMinutes) break;
    }

    console.log("\n----- Next CPT Summary -----");
    console.log("Total time used for calculations:", totalTimeUsed, "hours");
    console.log("Total Override Capacity:", totalOverrideCapacity);
    console.log("Remaining Capacity Needed:", Math.max(0, riskModelValue - totalOverrideCapacity));
    console.log("Total Available Capacity (non-overridden):", totalCapacity);

    // Calculate X (stable HC for non-overridden windows)
    let X = Math.ceil((riskModelValue - totalOverrideCapacity) / totalCapacity);
    X = Math.max(1, X); // Ensure at least 1 HC

    console.log("Calculated Stable HC (X) for Next CPT:", X);

    // Apply X to all non-overridden windows
    const recommendations = productionWindows.map((_, i) => i in userOverrides ? userOverrides[i] : X);

    console.log("Final Next CPT Recommendations:", recommendations);
    console.log("-------- End of Next CPT HC Recommendations Calculation --------");

    return recommendations;
}

function updateNextCPTPickRebinPackRow(pickRebinPackRow, recommendations, userOverrides = {}) {
    console.log("Updating Next CPT Pick2Rebin Pack Row");
    console.log("Next CPT Recommendations:", recommendations);
    console.log("Next CPT User Overrides:", userOverrides);

    const maxWalls = getMaxWalls();

    for (let i = 0; i < recommendations.length; i++) {
        const cell = pickRebinPackRow.cells[i + 1]; // +1 to skip the first cell (row headeader)

        if (i in userOverrides) {
            // Preserve user override, but cap it at maxWalls
            cell.textContent = Math.min(userOverrides[i], maxWalls);
            cell.style.backgroundColor = 'pink';
            cell.dataset.userOverride = 'true';
        } else {
            // Update with new recommendation
            const recommendedHC = Math.min(recommendations[i], maxWalls);
            cell.textContent = recommendedHC;
            cell.style.backgroundColor = '';
            cell.dataset.userOverride = 'false';
        }

        cell.dataset.recommended = Math.min(recommendations[i], maxWalls);

        console.log(`Updated next CPT cell ${i + 1}: ${cell.textContent} (Override: ${i in userOverrides})`);
    }
}
function addNextCPTManualOverrideListeners(row) {
    if (row.dataset.listenersAdded === 'true') return;

    const rowName = row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '');
    if (rowName === 'Pick2Rebin Pick' || rowName === 'Pick2Rebin Pack') {
        // Remove any existing listeners first
        for (let i = 1; i < row.cells.length; i++) {
            const cell = row.cells[i];
            cell.removeEventListener('click', handleCellClick);
            cell.removeEventListener('click', handleNextCPTManualOverride);
            cell.addEventListener('click', handleCellClick);
        }

        // Handle rate row
        const rateRow = row.nextElementSibling;
        if (rateRow && rateRow.cells[0].textContent.trim() === 'Expected Rate') {
            for (let i = 1; i < rateRow.cells.length; i++) {
                const cell = rateRow.cells[i];
                cell.removeEventListener('click', handleCellClick);
                cell.removeEventListener('input', handleNextCPTRateChange);
                cell.addEventListener('click', handleCellClick);
            }
        }
    }

    row.dataset.listenersAdded = 'true';
}
function handleNextCPTRateChange(event) {
    const cell = event.target;
    const nextProductionTable = cell.closest('table');
    const rateRow = cell.closest('tr');
    const parentRow = rateRow.previousElementSibling;
    const rowName = parentRow.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '');

    // Update any styling for the rate cell
    cell.style.backgroundColor = 'lightgreen';
    setTimeout(() => {
        cell.style.backgroundColor = '';
    }, 2000);

    // If this is Pick2Rebin Pack rate, update Pick HC
    if (rowName === 'Pick2Rebin Pack') {
        updateNextCPTPickHCBasedOnPackHC(nextProductionTable);
    }

    // Update other calculations
    updateOutboundTotals(nextProductionTable);
    updateNextCPTProductionTable();
    updateNextCPTProductionGraphic();
    updatePlanSummary2();
}
function handleNextCPTManualOverride(event) {
    const cell = event.target;
    const newValue = cell.textContent.trim();
    const row = cell.parentElement;
    const nextProductionTable = row.closest('table');

    console.log('Handling manual override for next CPT:', 'New value:', newValue);

    const maxWalls = getMaxWalls();

    if (newValue.toUpperCase() === 'R' || isNaN(parseFloat(newValue)) || parseFloat(newValue) < 1) {
        cell.dataset.userOverride = 'false';
        cell.style.backgroundColor = '';
    } else {
        const cappedValue = Math.min(parseFloat(newValue), maxWalls);
        cell.textContent = cappedValue;
        cell.dataset.userOverride = 'true';
        cell.style.backgroundColor = 'pink';
    }

    // Preserve the Next CPT Schedule
    const nextCPTScheduleTable = document.querySelector('#NextCPTSchedule');
    if (!nextCPTScheduleTable) {
        console.error('Next CPT Schedule table not found');
        return;
    }

    const productionWindows = getProductionWindows(nextCPTScheduleTable);
    const expectedRates = getExpectedRates(nextProductionTable, row, productionWindows);
    const nextCPT = getNextCPT(document.getElementById('cptSelect').value);

    const userOverrides = {};
    for (let i = 1; i < row.cells.length; i++) {
        const overrideCell = row.cells[i];
        if (overrideCell.dataset.userOverride === 'true') {
            userOverrides[i - 1] = Math.min(parseFloat(overrideCell.textContent), maxWalls);
        }
    }

    console.log('Next CPT User Overrides:', userOverrides);

    const nextCPTMixedSet4Value = getNextCPTMixedSet4Value();
    console.log('Next CPT MIXED Set 4 Value:', nextCPTMixedSet4Value);

    if (nextCPTMixedSet4Value === null) {
        console.error('Failed to get Next CPT MIXED Set 4 Value');
        return;
    }

    const newRecommendations = calculateHCRecommendations(nextCPTMixedSet4Value, productionWindows, expectedRates, userOverrides, nextCPT);
    console.log('New Next CPT Recommendations:', newRecommendations);

    updateNextCPTPickRebinPackRow(row, newRecommendations, userOverrides);

    updateOutboundTotals(nextProductionTable);
    updateNextCPTProductionGraphic();

    // Ensure the Next CPT Schedule is still visible
    if (nextCPTScheduleTable.style.display === 'none') {
        nextCPTScheduleTable.style.display = '';
    }

    // Update Pick HC after Pack HC is set for next CPT
    updateNextCPTPickHCBasedOnPackHC(nextProductionTable);
    updatePlanSummary2();
}

// Function to update Pick HC based on Pack HC for the next CPT table
function updateNextCPTPickHCBasedOnPackHC(nextProductionTable) {
    const packRow = nextProductionTable.querySelector('tr:nth-child(5)'); // Assuming Pack2Rebin Pack is the 5th row
    const pickRow = nextProductionTable.querySelector('tr:nth-child(3)'); // Assuming Pick2Rebin Pick is the 3rd row
    const packRateRow = packRow.nextElementSibling;
    const pickRateRow = pickRow.nextElementSibling;

    if (!packRow || !pickRow || !packRateRow || !pickRateRow) {
        console.error('Required rows not found for updating Next CPT Pick HC');
        return;
    }

    for (let i = 1; i < packRow.cells.length; i++) {
        const packHC = parseInt(packRow.cells[i].textContent);
        const packRate = parseFloat(packRateRow.cells[i].textContent);
        const pickRate = parseFloat(pickRateRow.cells[i].textContent);

        if (!isNaN(packHC) && !isNaN(packRate) && !isNaN(pickRate) && pickRate > 0) {
            const newPickHC = Math.ceil((packHC * packRate) / pickRate);
            if (!pickRow.cells[i].dataset.userOverride) {
                pickRow.cells[i].textContent = newPickHC;
                //Remove any background color for automatic updates
                pickRow.cells[i].style.backgroundColor = '';
            }
        }
    }

    console.log('Next CPT Pick2Rebin Pick HC updated based on Pack HC');
    updateOutboundTotals(nextProductionTable);
}
function updateNextCPTPick2RebinPickHC() {
    const nextProductionTable = document.getElementById('nextCPTProductionGraphicTable');
    if (!nextProductionTable) {
        console.error('Next CPT Production table not found');
        return;
    }

    let pickRow, packRow, pickRateRow, packRateRow;

    for (let i = 0; i < nextProductionTable.rows.length; i++) {
        const rowName = nextProductionTable.rows[i].cells[0].textContent.trim();
        if (rowName === 'Pick2Rebin Pick') {
            pickRow = nextProductionTable.rows[i];
            pickRateRow = nextProductionTable.rows[i + 1];
        } else if (rowName === 'Pick2Rebin Pack') {
            packRow = nextProductionTable.rows[i];
            packRateRow = nextProductionTable.rows[i + 1];
        }
    }

    if (!pickRow || !packRow || !pickRateRow || !packRateRow) {
        console.error('Required rows not found in Next CPT Production table');
        return;
    }

    for (let i = 1; i < packRow.cells.length; i++) {
        // Skip if there's a user override on the Pick cell
        if (pickRow.cells[i].dataset.userOverride === 'true') {
            console.log(`Skipping cell ${i} due to user override`);
            continue;
        }

        const packHC = parseInt(packRow.cells[i].textContent);
        const packRate = parseFloat(packRateRow.cells[i].textContent);
        const pickRate = parseFloat(pickRateRow.cells[i].textContent);

        if (!isNaN(packHC) && !isNaN(packRate) && !isNaN(pickRate) && pickRate > 0) {
            const newPickHC = Math.ceil((packHC * packRate) / pickRate);
            pickRow.cells[i].textContent = newPickHC;
            pickRow.cells[i].style.backgroundColor = 'lightgreen';
        }
    }

    console.log('Next CPT Pick2Rebin Pick HC updated');
    updateOutboundTotals(nextProductionTable);
}
function handleNextCPTHCChange(event) {
    const cell = event.target;
    const nextProductionTable = cell.closest('table');
    updateNextCPTPick2RebinPickHC();
    updateOutboundTotals(nextProductionTable);
    updateNextCPTProductionGraphic();
}
function getNextCPTOrderPickVNATotal() {
    const nextCPTRodeoInfoBox = document.getElementById('nextCPTRodeoInfoBox');
    if (!nextCPTRodeoInfoBox) {
        console.error('Next CPT Rodeo Info Box not found');
        return 0;
    }

    const tables = nextCPTRodeoInfoBox.querySelectorAll('table');
    console.log(`Found ${tables.length} tables in Next CPT Rodeo Info Box`);

    for (let table of tables) {
        const rows = table.querySelectorAll('tr');
        for (let row of rows) {
            const cells = row.querySelectorAll('td');
            if (cells.length > 1) {
                console.log(`Row content: ${cells[0].textContent.trim()} - ${cells[1].textContent.trim()}`);
                if (cells[0].textContent.trim() === 'PPOrderPickVNA') {
                    const total = parseInt(cells[1].textContent.trim().replace(/,/g, ''), 10);
                    console.log('Found Next CPT PPOrderPickVNA total:', total);
                    return isNaN(total) ? 0 : total;
                }
            }
        }
    }
    console.warn('PPOrderPickVNA not found in Next CPT Rodeo Info Box');
    return 0;
}

function updateNextCPTVNAPackRecommendations() {
    console.log('--- Starting updateNextCPTVNAPackRecommendations ---');
    const nextProductionTable = document.getElementById('nextCPTProductionGraphicTable');
    const nextScheduleTable = document.querySelector('#NextCPTSchedule');

    if (!nextProductionTable || !nextScheduleTable) {
        console.error('Next CPT Production table or schedule table not found');
        return;
    }

    const vnaPackRow = Array.from(nextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');

    if (!vnaPackRow) {
        console.error('VNA Pack row not found in next CPT table');
        return;
    }

    const orderPickVNATotal = getNextCPTOrderPickVNATotal();
    console.log('Next CPT OrderPickVNA Total:', orderPickVNATotal);

    const productionWindows = getProductionWindows(nextScheduleTable);
    const expectedRates = getExpectedRates(nextProductionTable, vnaPackRow, productionWindows);
    const nextCPT = getNextCPT(document.getElementById('cptSelect').value);

    console.log('Next CPT Production Windows:', productionWindows);
    console.log('Next CPT Expected Rates:', expectedRates);

    // Calculate total available time
    let totalAvailableTime = productionWindows.reduce((total, window) => total + window.durationInHours, 0);
    console.log('Total Available Time:', totalAvailableTime);

    // Calculate required HC
    let requiredHC = Math.ceil(orderPickVNATotal / (totalAvailableTime * expectedRates[0]));
    const maxWalls = getMaxWalls();
    requiredHC = Math.min(requiredHC, maxWalls);
    console.log('Required HC (capped at Max Walls):', requiredHC);

    // Update VNA Pack row
    for (let i = 1; i < vnaPackRow.cells.length; i++) {
        if (i <= productionWindows.length) {
            vnaPackRow.cells[i].textContent = requiredHC;
            console.log(`Updated VNA Pack cell ${i} to ${requiredHC}`);
        } else {
            vnaPackRow.cells[i].textContent = 'X';
            vnaPackRow.cells[i].style.backgroundColor = '';
            console.log(`Set VNA Pack cell ${i} to X`);
        }
    }

    // Update VNA Pick HC based on VNA Pack HC
    updateNextCPTVNAPickHCBasedOnPackHC(nextProductionTable);

    updateOutboundTotals(nextProductionTable);
    updateNextCPTProductionGraphic();
    console.log('--- Ending updateNextCPTVNAPackRecommendations ---');
}


function updateNextCPTVNAPickHCBasedOnPackHC(nextProductionTable) {
    console.log('--- Starting updateNextCPTVNAPickHCBasedOnPackHC ---');
    const packRow = Array.from(nextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');
    const pickRow = Array.from(nextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pick');
    const packRateRow = packRow ? packRow.nextElementSibling : null;
    const pickRateRow = pickRow ? pickRow.nextElementSibling : null;

    if (!packRow || !pickRow || !packRateRow || !pickRateRow) {
        console.error('Required rows not found for updating Next CPT VNA Pick HC');
        return;
    }

    for (let i = 1; i < packRow.cells.length; i++) {
        const packHC = parseInt(packRow.cells[i].textContent);
        const packRate = parseFloat(packRateRow.cells[i].textContent);
        const pickRate = parseFloat(pickRateRow.cells[i].textContent);

        console.log(`Column ${i}: Pack HC = ${packHC}, Pack Rate = ${packRate}, Pick Rate = ${pickRate}`);

        if (!isNaN(packHC) && !isNaN(packRate) && !isNaN(pickRate) && pickRate > 0) {
            const newPickHC = Math.ceil((packHC * packRate) / pickRate);
            console.log(`New Pick HC calculated: ${newPickHC}`);
            if (pickRow.cells[i].textContent === 'X' || !pickRow.cells[i].dataset.userOverride) {
                pickRow.cells[i].textContent = newPickHC;

            }
        } else {
            console.log('Skipping calculation due to invalid values');
        }
    }

    console.log('Next CPT VNA Pick HC updated based on VNA Pack HC');
    console.log('--- Ending updateNextCPTVNAPickHCBasedOnPackHC ---');
}
function waitForNextCPTProductionTable(attempts = 0, maxAttempts = 10) {
    return new Promise((resolve, reject) => {
        const nextProductionTable = document.getElementById('nextCPTProductionGraphicTable');
        if (nextProductionTable) {
            console.log('Next CPT Production table found');
            resolve();
        } else if (attempts < maxAttempts) {
            console.log(`Next CPT Production table not found, attempt ${attempts + 1}. Retrying in 500ms...`);
            setTimeout(() => {
                waitForNextCPTProductionTable(attempts + 1, maxAttempts).then(resolve).catch(reject);
            }, 500);
        } else {
            reject(new Error('Next CPT Production table not found after maximum attempts'));
        }
    });
}
document.getElementById('cptSelect').addEventListener('change', function() {
    fetchAndDisplayRodeoInfo();
    fetchAndDisplayNextCPTRodeoInfo();
});

window.addEventListener('load', function() {
    fetchAndDisplayRodeoInfo();
    fetchAndDisplayNextCPTRodeoInfo();
});

let planSummary1Container = document.createElement('div');
planSummary1Container.id = 'planSummary1Container';
planSummary1Container.style.cssText = `
    position: fixed;
    top: 230px;
    right: 40px;
    width: 650px;
    background-color: #ffffff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 12px;
    padding: 20px;
    z-index: 10000;
    font-size: 20px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(-10px);
`;
document.body.appendChild(planSummary1Container);

// Animation entrance
setTimeout(() => {
    planSummary1Container.style.opacity = '1';
    planSummary1Container.style.transform = 'translateY(0)';
}, 100);
function updatePlanSummary1() {
    console.log("Starting updatePlanSummary1");

    const selectedCPTSchedule = document.getElementById('SelectedCPTSchedule');
    if (!selectedCPTSchedule) {
        console.error('SelectedCPTSchedule table not found');
        return;
    }

    const productionTable = document.getElementById('productionGraphic');
    if (!productionTable) {
        console.error('Production table not found');
        return;
    }

const planSummary1Container = document.getElementById('planSummary1Container');
planSummary1Container.innerHTML = `
    <h3 style="
        margin: 0 0 20px 0;
        color: #2c3e50;
        font-size: 24px;
        font-weight: 600;
        border-bottom: 2px solid #ecf0f1;
        padding-bottom: 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    ">
        <span>Plan Summary 1</span>
        <span style="
            font-size: 14px;
            color: #64748b;
            font-weight: normal;
        ">Current CPT Plan</span>
    </h3>`;

const table = document.createElement('table');
table.style.cssText = `
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 10px;
    position: relative;
    max-height: calc(100vh - 400px);
    overflow-y: auto;
`;

const headerRow = table.insertRow();
headerRow.style.cssText = `
    position: sticky;
    top: 0;
    z-index: 1;
    background-color: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
`;
['Window', 'Multis Capacity', 'Singles', 'Total Capacity', 'Effective Time', 'Window Planned Volume'].forEach(header => {
    const th = document.createElement('th');
    th.textContent = header;
    th.style.cssText = `
        padding: 12px;
        text-align: left;
        font-weight: 600;
        color: #2c3e50;
        background-color: #f8fafc;
        border-bottom: 2px solid #edf2f7;
        position: sticky;
        top: 0;
        transition: background-color 0.3s ease;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        letter-spacing: 0.3px;
    `;
    headerRow.appendChild(th);
});

    // Get relevant rows
    const timeRow = selectedCPTSchedule.rows[0];
    const durationRow = selectedCPTSchedule.rows[1];
    const blockTypeRow = selectedCPTSchedule.rows[2];
    const packRow = Array.from(productionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'Pick2Rebin Pack');
    const vnaPackRow = Array.from(productionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');

    if (!blockTypeRow || !packRow || !vnaPackRow) {
        console.error('Required rows not found');
        return;
    }

    const packRateRow = packRow.nextElementSibling;
    const vnaPackRateRow = vnaPackRow.nextElementSibling;

    // Find production windows and their corresponding indices
    const productionWindows = [];
    for (let i = 0; i < blockTypeRow.cells.length; i++) {
        if (blockTypeRow.cells[i].textContent.trim() === 'Production') {
            productionWindows.push({
                index: i,
                time: timeRow.cells[i].textContent,
                duration: durationRow.cells[i].textContent
            });
        }
    }

    console.log("Production windows:", productionWindows);

    let obPlannedVolume = 0;
    const currentCPT = document.getElementById('cptSelect').value;
    console.log("Current CPT:", currentCPT);

    productionWindows.forEach((window, index) => {
    console.log(`\nProcessing window ${index + 1}:`, window);

    const row = table.insertRow();
    row.style.cssText = `
        transition: all 0.2s ease;
    `;

    // Add hover effect to row
    row.addEventListener('mouseover', () => {
        row.style.backgroundColor = '#f8fafc';
       });
    row.addEventListener('mouseout', () => {
        row.style.backgroundColor = 'transparent';
    });

    // Window time
    row.insertCell().textContent = window.time;

    // Multis Capacity
    const packHC = parseInt(packRow.cells[index + 1].textContent) || 0;
    const packRate = parseFloat(packRateRow.cells[index + 1].textContent) || 0;
    const multisCapacity = packHC * packRate;
    console.log(`Multis - HC: ${packHC}, Rate: ${packRate}, Capacity: ${multisCapacity}`);
    row.insertCell().textContent = multisCapacity.toFixed(0);


        // Singles
        const vnaPackHC = parseInt(vnaPackRow.cells[index + 1].textContent) || 0;
        const vnaPackRate = parseFloat(vnaPackRateRow.cells[index + 1].textContent) || 0;
        const singlesCapacity = vnaPackHC * vnaPackRate;
        console.log(`Singles - HC: ${vnaPackHC}, Rate: ${vnaPackRate}, Capacity: ${singlesCapacity}`);
        row.insertCell().textContent = singlesCapacity.toFixed(0);

const totalCapacity = multisCapacity + singlesCapacity;
console.log(`Total Capacity: ${totalCapacity}`);
const totalCapacityCell = row.insertCell();
totalCapacityCell.textContent = totalCapacity.toFixed(0);
totalCapacityCell.style.cssText = `
    padding: 12px;
    text-align: right;
    color: #7c3aed;
    font-weight: 600;
    background-color: ${totalCapacity > 0 ? '#f5f3ff' : 'transparent'};
    border-radius: 4px;
`;

        // If this is the first window, update the Dispatch Recommendation table
        if (index === 0) {
            const adjustedVolume = Math.ceil(totalCapacity / 1.6);
            const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
            if (dispatchTable) {
                const rows = Array.from(dispatchTable.rows);
                const outboundRow = rows.find(row => row.cells[0].textContent.trim() === 'Outbound');
                if (outboundRow && outboundRow.cells[1]) {
                    outboundRow.cells[1].textContent = adjustedVolume;
                    outboundRow.cells[1].style.backgroundColor = 'lightgreen';
                    outboundRow.cells[1].style.transition = 'background-color 0.5s ease';
                    console.log(`Updated Outbound volume to: ${adjustedVolume}`);
                }
            }
        }
        // Calculate effective time
        let effectiveTime;

        if (index === 0 && window.duration.includes('left in block')) {
            // For the first window, use the "left in block" time if available
            effectiveTime = convertLeftInBlockToHours(window.duration);
        } else if (index === productionWindows.length - 1) {
            // For the last window, calculate time until CPT
            let [startTime, endTime] = window.time.split(' to ');
            let startMinutes = convertToMinutesSinceMidnight(startTime);
            let cptMinutes = convertToMinutesSinceMidnight(currentCPT);

            // Adjust if CPT is on the next day
            if (cptMinutes < startMinutes) cptMinutes += 24 * 60;

            effectiveTime = (cptMinutes - startMinutes) / 60;
        } else {
            // For other windows, use the full duration
            effectiveTime = convertToHours(window.duration);
        }

        console.log(`Final Effective time: ${effectiveTime} hours`);
        row.insertCell().textContent = effectiveTime.toFixed(2);

let windowPlannedVolume = totalCapacity * effectiveTime;
console.log(`Window Planned Volume: ${windowPlannedVolume}`);
const volumeCell = row.insertCell();
volumeCell.textContent = windowPlannedVolume.toFixed(0);
volumeCell.style.cssText = `
    padding: 12px;
    text-align: right;
    color: #0891b2;
    font-weight: 600;
    background-color: ${windowPlannedVolume > 0 ? '#f0f9ff' : 'transparent'};
    border-radius: 4px;
`;
        obPlannedVolume += windowPlannedVolume;

row.querySelectorAll('td').forEach((cell, cellIndex) => {
    cell.style.cssText = `
        padding: 12px;
        border-bottom: 1px solid #edf2f7;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        transition: background-color 0.2s ease;
    `;

    // Add specific styling based on cell type
    if (cellIndex === 1) { // Multis Capacity
        cell.style.color = '#2563eb';
        cell.style.fontWeight = '500';
    } else if (cellIndex === 2) { // Singles
        cell.style.color = '#059669';
        cell.style.fontWeight = '500';
    } else if (cellIndex === 3) { // Total Capacity
        cell.style.color = '#7c3aed';
        cell.style.fontWeight = '600';
    }

    // Add text alignment
    if (cellIndex > 0) { // All cells except Window
        cell.style.textAlign = 'right';
    }
});
    });

    // Round up the total OB Planned Volume
    obPlannedVolume = Math.ceil(obPlannedVolume);
    console.log(`\nFinal OB Planned Volume: ${obPlannedVolume}`);

    // Get Column A value (assuming it's the current backlog)
    const columnAValue = getCurrentBacklog();

    // Calculate Risk %
    const riskPercentage = Math.ceil((columnAValue / obPlannedVolume) * 100 * 100) / 100;


    // Get Column E value from CORA table
    const columnEValue = getColumnEFromCORA();

    // Calculate Risk with Expected Charge
    const riskWithExpectedCharge = Math.ceil((columnEValue / obPlannedVolume) * 100 * 100) / 100;

    // Add a new row with three columns for summary information
const summaryRow = table.insertRow();
summaryRow.style.cssText = `
    background-color: #f8fafc;
    font-weight: 600;
    margin-top: 10px;
    border-radius: 0 0 8px 8px;
`;

// First column: OB Planned Volume
const plannedVolumeCell = summaryRow.insertCell();
plannedVolumeCell.innerHTML = `<span style="font-weight: 700">OB Planned Volume:</span> <span style="font-weight: normal">${obPlannedVolume}</span>`;
plannedVolumeCell.style.cssText = `
    padding: 16px;
    color: #1e293b;
    border-radius: 0 0 0 8px;
    font-size: 20px;
`;

// Second column: Risk %
const riskCell = summaryRow.insertCell();
riskCell.innerHTML = `<span style="font-weight: 700">Risk %:</span> <span style="font-weight: normal">${riskPercentage.toFixed(2)}%</span>`;
riskCell.style.cssText = `
    padding: 16px;
    text-align: center;
    font-size: 20px;
`;

// Third column: Risk with Expected Charge
const riskWithChargeCell = summaryRow.insertCell();
riskWithChargeCell.innerHTML = `<span style="font-weight: 700">Risk with Expected Charge:</span> <span style="font-weight: normal">${riskWithExpectedCharge.toFixed(2)}%</span>`;
riskWithChargeCell.style.cssText = `
    padding: 16px;
    text-align: right;
    color: #1e293b;
    border-radius: 0 0 8px 0;
    font-size: 20px;
`;

// Keep the existing risk percentage conditional styling but update colors
if (riskPercentage > 90) {
    riskCell.style.backgroundColor = '#fee2e2';
    riskCell.style.color = '#991b1b';
} else if (riskPercentage > 80) {
    riskCell.style.backgroundColor = '#fef9c3';
    riskCell.style.color = '#854d0e';
}

// Set the colspan for each cell to make them equal width
plannedVolumeCell.colSpan = 2;
riskCell.colSpan = 2;
riskWithChargeCell.colSpan = 2;


    // Append the new table to the container
    planSummary1Container.appendChild(table);
            setTimeout(() => {
                calculateDispatchRecommendations();
                    updatePlanSummaryWithGroceryVolumes();
            }, 100); // 100ms delay

    console.log("Finished updatePlanSummary1");

    function convertToMinutesSinceMidnight(timeString) {
        let [time, period] = timeString.split(' ');
        let [hours, minutes] = time.split(':').map(Number);

        if (period === 'PM' && hours !== 12) hours += 12;
        if (period === 'AM' && hours === 12) hours = 0;

        return hours * 60 + minutes;
    }

    function convertLeftInBlockToHours(leftInBlock) {
        const [hours, minutes] = leftInBlock.split(' ')[0].split(':').map(Number);
        return hours + minutes / 60;
    }

    function convertToHours(duration) {
        if (duration.includes('minutes')) {
            return parseInt(duration) / 60;
        } else {
            // Assume it's in "HH:MM" format
            const [hours, minutes] = duration.split(':').map(Number);
            return hours + minutes / 60;
        }
    }
function calculateDispatchRecommendations() {
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    if (!dispatchTable) return;

    const rows = Array.from(dispatchTable.rows);
    const headerRow = rows[0];
    const ratesRow = rows[1];
    const currentSite = document.getElementById('siteSelector').value;
    const settings = allSiteSettings[currentSite];

    // Helper function to convert SLA to hours
    function getSLAHours(slaText) {
        if (!slaText) return 0;
        if (slaText.includes('h')) return parseFloat(slaText);
        if (slaText.includes('m')) return parseFloat(slaText) / 60;
        return 0;
    }

    // Helper function to enforce MIN/MAX constraints
    function enforceConstraints(value, config) {
        if (!value || isNaN(value)) return 0;
        const min = parseFloat(config.minHC) || 0;
        const max = parseFloat(config.maxHC) || Infinity;
        return Math.min(Math.max(Math.ceil(value), min), max);
    }

    // Process Outbound row calculations first
    const outboundRow = rows.find(row => row.cells[0].textContent.trim() === 'Outbound');
    if (outboundRow) {
        const volume = parseFloat(outboundRow.cells[1].textContent) || 0;
        const slaHours = getSLAHours(outboundRow.cells[2].textContent);

        for (let j = 3; j < outboundRow.cells.length; j++) {
            const headerText = headerRow.cells[j].textContent.trim();
            const rate = ratesRow.cells[j].textContent.trim();

            // Only process if it's NOT a Fixed rate
            if (rate !== 'Fixed') {
                const rateValue = parseFloat(rate);
                if (rateValue > 0 && slaHours > 0) {
                    const calculatedHC = volume / (rateValue * slaHours);
                    outboundRow.cells[j].textContent = calculatedHC.toFixed(2);
                } else {
                    outboundRow.cells[j].textContent = '0.00';
                }
            }
            // Skip Fixed roles - leave their values as is
        }
    }

    // Find and process All row
    const allRow = rows.find(row => row.cells[0].textContent.trim() === 'All');
    if (allRow) {
        const allRowIndex = rows.indexOf(allRow);

        // Calculate total volume
        let totalVolume = 0;
        for (let i = allRowIndex + 1; i < rows.length; i++) {
            const volumeCell = rows[i].cells[1].textContent.trim();
            if (volumeCell !== 'Pending') {
                totalVolume += parseFloat(volumeCell) || 0;
            }
        }
        allRow.cells[1].textContent = totalVolume;
        allRow.cells[1].style.backgroundColor = 'lightgreen';

        // Process each column
        for (let j = 3; j < allRow.cells.length; j++) {
            const headerText = headerRow.cells[j].textContent.trim();
            const rate = ratesRow.cells[j].textContent.trim();

            if (rate === 'Fixed') {
                allRow.cells[j].style.backgroundColor = '#FFE4B5';
                continue; // Skip Fixed roles - leave their values as is
            }

            // For columns with rates, sum up all values below
            let sum = 0;
            for (let i = allRowIndex + 1; i < rows.length; i++) {
                const value = parseFloat(rows[i].cells[j].textContent) || 0;
                sum += value;
            }

            // Find the corresponding settings
            const roleName = headerText + ' (sortation)';
            const roleSettings = settings[roleName];

            if (roleSettings) {
                // Round up and apply constraints
                sum = Math.ceil(sum);
                const finalValue = enforceConstraints(sum, roleSettings);
                allRow.cells[j].textContent = finalValue;
                allRow.cells[j].style.backgroundColor = '#FFE4B5';
            }
        }
    }

    // Process other rows (Rolled, Held, RTS, Injection)
    for (let i = 3; i < rows.length; i++) {
        const row = rows[i];
        if (row === outboundRow) continue;

        const volume = parseFloat(row.cells[1].textContent) || 0;
        const slaHours = getSLAHours(row.cells[2].textContent);

        for (let j = 3; j < row.cells.length; j++) {
            const rate = ratesRow.cells[j].textContent.trim();

            // Only process if it's NOT a Fixed rate
            if (rate !== 'Fixed') {
                const rateValue = parseFloat(rate);
                if (rateValue > 0 && slaHours > 0) {
                    const calculatedHC = volume / (rateValue * slaHours);
                    row.cells[j].textContent = calculatedHC.toFixed(2);
                } else {
                    row.cells[j].textContent = '0.00';
                }
            }
        }
    }
  initializeDispatchInteractivity();
     if (allRow) {
        let totalHC = 0;
        for (let i = 3; i < allRow.cells.length; i++) {
            const cellValue = parseFloat(allRow.cells[i].textContent) || 0;
            totalHC += cellValue;
        }

        // Update the HC value
        const hcValueElement = document.getElementById('hcValue');
        if (hcValueElement) {
            hcValueElement.textContent = totalHC.toFixed(2);
        }
    }
}



function initializeDispatchInteractivity() {
    console.log("Initializing dispatch interactivity");
    // Wait a short moment to ensure table is fully populated
    setTimeout(() => {
        addDispatchTableInteractivity();
    }, 1000); // Adjust timing if needed
}

function getCurrentBacklog() {
    const currentCPT = document.getElementById('cptSelect').value;
    const coraTable = document.querySelector('.CORA-table');
    if (!coraTable) {
        console.error('CORA table not found');
        return 0;
    }

    for (let i = 1; i < coraTable.rows.length; i++) {
        if (coraTable.rows[i].cells[0].textContent.trim() === currentCPT) {
            const backlog = parseInt(coraTable.rows[i].cells[1].textContent.trim().replace(/,/g, ''), 10);
            console.log(`Current Backlog (Column A) for CPT ${currentCPT}: ${backlog}`);
            return isNaN(backlog) ? 0 : backlog;
        }
    }

    console.warn(`No backlog data found for CPT ${currentCPT}`);
    return 0;
}

function getColumnEFromCORA() {
    const currentCPT = document.getElementById('cptSelect').value;
    const coraTable = document.querySelector('.CORA-table');
    if (!coraTable) {
        console.error('CORA table not found');
        return 0;
    }

    for (let i = 1; i < coraTable.rows.length; i++) {
        if (coraTable.rows[i].cells[0].textContent.trim() === currentCPT) {
            const columnE = parseInt(coraTable.rows[i].cells[3].textContent.trim().replace(/,/g, ''), 10);
            console.log(`Column E value for CPT ${currentCPT}: ${columnE}`);
            return isNaN(columnE) ? 0 : columnE;
        }
    }

    console.warn(`No Column E data found for CPT ${currentCPT}`);
    return 0;
}
}
// I know what you are thinking but don't worry about it. Okay. Move along
function getCORAData() {
    return getCORAData1();
}

function getATROPSData(cpt) {
    return getATROPSData1(cpt);
}

let planSummary2Container = document.createElement('div');
planSummary2Container.id = 'planSummary2Container';
planSummary2Container.style.cssText = `
    position: fixed;
    top: 1020px;
    right: 40px;
    width: 650px;
    background-color: #ffffff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 12px;
    padding: 20px;
    z-index: 10000;
    font-size: 20px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(-10px);
`;
document.body.appendChild(planSummary2Container);

// Animation entrance
setTimeout(() => {
    planSummary2Container.style.opacity = '1';
    planSummary2Container.style.transform = 'translateY(0)';
}, 100);


function updatePlanSummary2() {
    console.log("Starting updatePlanSummary2");

    const nextCPTSchedule = document.getElementById('NextCPTSchedule');
    if (!nextCPTSchedule) {
        console.error('NextCPTSchedule table not found');
        return;
    }

    const nextProductionTable = document.getElementById('nextCPTProductionGraphicTable');
    if (!nextProductionTable) {
        console.error('Next CPT Production table not found');
        return;
    }

const planSummary2Container = document.getElementById('planSummary2Container');
planSummary2Container.innerHTML = `
    <h3 style="
        margin: 0 0 20px 0;
        color: #2c3e50;
        font-size: 24px;
        font-weight: 600;
        border-bottom: 2px solid #ecf0f1;
        padding-bottom: 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    ">
        <span>Plan Summary 2</span>
        <span style="
            font-size: 14px;
            color: #64748b;
            font-weight: normal;
        ">Next CPT Plan</span>
    </h3>`;

const table = document.createElement('table');
table.style.cssText = `
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 10px;
    position: relative;
    max-height: calc(100vh - 400px);
    overflow-y: auto;
`;

const headerRow = table.insertRow();
headerRow.style.cssText = `
    position: sticky;
    top: 0;
    z-index: 1;
    background-color: white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
`;
['Window', 'Multis Capacity', 'Singles', 'Total Capacity', 'Effective Time', 'Window Planned Volume'].forEach(header => {
    const th = document.createElement('th');
    th.textContent = header;
    th.style.cssText = `
        padding: 12px;
        text-align: left;
        font-weight: 600;
        color: #2c3e50;
        background-color: #f8fafc;
        border-bottom: 2px solid #edf2f7;
        position: sticky;
        top: 0;
        transition: background-color 0.3s ease;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        letter-spacing: 0.3px;
    `;
    headerRow.appendChild(th);
});


    // Get relevant rows
    const timeRow = nextCPTSchedule.rows[0];
    const durationRow = nextCPTSchedule.rows[1];
    const blockTypeRow = nextCPTSchedule.rows[2];
    const packRow = Array.from(nextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'Pick2Rebin Pack');
    const vnaPackRow = Array.from(nextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');

    if (!blockTypeRow || !packRow || !vnaPackRow) {
        console.error('Required rows not found for Next CPT');
        return;
    }

    const packRateRow = packRow.nextElementSibling;
    const vnaPackRateRow = vnaPackRow.nextElementSibling;

    // Find production windows and their corresponding indices
    const productionWindows = [];
    for (let i = 0; i < blockTypeRow.cells.length; i++) {
        if (blockTypeRow.cells[i].textContent.trim() === 'Production') {
            productionWindows.push({
                index: i,
                time: timeRow.cells[i].textContent,
                duration: durationRow.cells[i].textContent
            });
        }
    }

    console.log("Next CPT Production windows:", productionWindows);

    let obPlannedVolume = 0;
    const currentCPT = document.getElementById('cptSelect').value;
    const nextCPT = getNextCPT(currentCPT);
    console.log("Next CPT:", nextCPT);

productionWindows.forEach((window, index) => {
    console.log(`\nProcessing window ${index + 1}:`, window);

    const row = table.insertRow();
    row.style.cssText = `
        transition: all 0.2s ease;
    `;

    // Add hover effect to row
    row.addEventListener('mouseover', () => {
        row.style.backgroundColor = '#f8fafc';
    });
    row.addEventListener('mouseout', () => {
        row.style.backgrounoundColor = 'transparent';
    });

    // Window time
    row.insertCell().textContent = window.time;

    // Multis Capacity
    const packHC = parseInt(packRow.cells[index + 1].textContent) || 0;
    const packRate = parseFloat(packRateRow.cells[index + 1].textContent) || 0;
    const multisCapacity = packHC * packRate;
    console.log(`Multis - HC: ${packHC}, Rate: ${packRate}, Capacity: ${multisCapacity}`);
    const multisCell = row.insertCell();
    multisCell.textContent = multisCapacity.toFixed(0);
    multisCell.style.cssText = `
        padding: 12px;
        text-align: right;
        color: #2563eb;
        font-weight: 500;
    `;

    // Singles
    const vnaPackHC = parseInt(vnaPackRow.cells[index + 1].textContent) || 0;
    const vnaPackRate = parseFloat(vnaPackRateRow.cells[index + 1].textContent) || 0;
    const singlesCapacity = vnaPackHC * vnaPackRate;
    console.log(`Singles - HC: ${vnaPackHC}, Rate: ${vnaPackRate}, Capacity: ${singlesCapacity}`);
    const singlesCell = row.insertCell();
    singlesCell.textContent = singlesCapacity.toFixed(0);
    singlesCell.style.cssText = `
        padding: 12px;
        text-align: right;
        color: #059669;
        font-weight: 500;
    `;

    // Total Capacity
    const totalCapacity = multisCapacity + singlesCapacity;
    console.log(`Total Capacity: ${totalCapacity}`);
    const totalCapacityCell = row.insertCell();
    totalCapacityCell.textContent = totalCapacity.toFixed(0);
    totalCapacityCell.style.cssText = `
        padding: 12px;
        text-align: right;
        color: #7c3aed;
        font-weight: 600;
        background-color: ${totalCapacity > 0 ? '#f5f3ff' : 'transparent'};
        border-radius: 4px;
    `;

        let effectiveTime;

        if (index === 0 && window.duration.includes('left in block')) {
            // For the first window, use the "left in block" time if available
            effectiveTime = convertLeftInBlockToHours(window.duration);
        } else if (index === productionWindows.length - 1) {
            // For the last window, calculate time until next CPT
            let [startTime, endTime] = window.time.split(' to ');
            let startMinutes = convertToMinutesSinceMidnight(startTime);
            let nextCPTMinutes = convertToMinutesSinceMidnight(nextCPT);

            // Adjust if next CPT is on the next day
            if (nextCPTMinutes < startMinutes) nextCPTMinutes += 24 * 60;

            effectiveTime = (nextCPTMinutes - startMinutes) / 60;
        } else {
            // For other windows, use the full duration
            effectiveTime = convertToHours(window.duration);
        }

            console.log(`Final Effective time: ${effectiveTime} hours`);
    const timeCell = row.insertCell();
    timeCell.textContent = effectiveTime.toFixed(2);
    timeCell.style.cssText = `
        padding: 12px;
        text-align: right;
        color: #dc2626;
        font-weight: 500;
    `;

    // Calculate OB Planned Volume for this window
    let windowPlannedVolume = totalCapacity * effectiveTime;
    console.log(`Window Planned Volume: ${windowPlannedVolume}`);
    const volumeCell = row.insertCell();
    volumeCell.textContent = windowPlannedVolume.toFixed(0);
    volumeCell.style.cssText = `
        padding: 12px;
        text-align: right;
        color: #0891b2;
        font-weight: 600;
        background-color: ${windowPlannedVolume > 0 ? '#f0f9ff' : 'transparent'};
        border-radius: 4px;
    `;
    obPlannedVolume += windowPlannedVolume;

    // Apply base styles to all cells in the row
    row.querySelectorAll('td').forEach((cell, cellIndex) => {
        cell.style.cssText += `
            border-bottom: 1px solid #edf2f7;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            transition: background-color 0.2s ease;
        `;

        // Text alignment for first column
        if (cellIndex === 0) {
            cell.style.textAlign = 'left';
        }
    });

    });

    // Round up the total OB Planned Volume
    obPlannedVolume = Math.ceil(obPlannedVolume);
    console.log(`\nFinal OB Planned Volume: ${obPlannedVolume}`);

    // Get Column A value for next CPT (assuming it's the current backlog)
    const columnAValue = getNextCPTCurrentBacklog(nextCPT);

    // Calculate Risk %
    const riskPercentage = Math.ceil((columnAValue / obPlannedVolume) * 100 * 100) / 100;

    // Get Column E value from CORA table for next CPT
    const columnEValue = getNextCPTColumnEFromCORA(nextCPT);

    // Calculate Risk with Expected Charge
    const riskWithExpectedCharge = Math.ceil((columnEValue / obPlannedVolume) * 100 * 100) / 100;

// Add separator row
const separatorRow = table.insertRow();
separatorRow.style.cssText = `
    height: 8px;
    background-color: #f8fafc;
`;

// Add a new row with three columns for summary information
const summaryRow = table.insertRow();
summaryRow.style.cssText = `
    background-color: #f8fafc;
    font-weight: 600;
    margin-top: 10px;
    border-radius: 0 0 8px 8px;
`;

// First column: OB Planned Volume
const plannedVolumeCell = summaryRow.insertCell();
plannedVolumeCell.innerHTML = `<span style="font-weight: 700">OB Planned Volume:</span> <span style="font-weight: normal">${obPlannedVolume}</span>`;
plannedVolumeCell.style.cssText = `
    padding: 16px;
    color: #1e293b;
    border-radius: 0 0 0 8px;
    font-size: 20px;
`;

// Second column: Risk %
const riskCell = summaryRow.insertCell();
riskCell.innerHTML = `<span style="font-weight: 700">Risk %:</span> <span style="font-weight: normal">${riskPercentage.toFixed(2)}%</span>`;
riskCell.style.cssText = `
    padding: 16px;
    text-align: center;
    font-size: 20px;
`;

// Third column: Risk with Expected Charge
const riskWithChargeCell = summaryRow.insertCell();
riskWithChargeCell.innerHTML = `<span style="font-weight: 700">Risk with Expected Charge:</span> <span style="font-weight: normal">${riskWithExpectedCharge.toFixed(2)}%</span>`;
riskWithChargeCell.style.cssText = `
    padding: 16px;
    text-align: right;
    color: #1e293b;
    border-radius: 0 0 8px 0;
    font-size: 20px;
`;

// Keep the existing risk percentage conditional styling but update colors
if (riskPercentage > 90) {
    riskCell.style.backgroundColor = '#fee2e2';
    riskCell.style.color = '#991b1b';
} else if (riskPercentage > 80) {
    riskCell.style.backgroundColor = '#fef9c3';
    riskCell.style.color = '#854d0e';
}

// Set the colspan for each cell to make them equal width
plannedVolumeCell.colSpan = 2;
riskCell.colSpan = 2;
riskWithChargeCell.colSpan = 2;


    // Append the new table to the container
    planSummary2Container.appendChild(table);

    console.log("Finished updatePlanSummary2");
}

function convertLeftInBlockToHours(leftInBlock) {
    const [hours, minutes] = leftInBlock.split(' ')[0].split(':').map(Number);
    return hours + minutes / 60;
}

function convertToHours(duration) {
    if (duration.includes('minutes')) {
        return parseInt(duration) / 60;
    } else {
        // Assume it's in "HH:MM" format
        const [hours, minutes] = duration.split(':').map(Number);
        return hours + minutes / 60;
    }
}

function getNextCPTCurrentBacklog(nextCPT) {
    const coraTable = document.querySelector('.CORA-table');
    if (!coraTable) {
        console.error('CORA table not found');
        return 0;
    }

    for (let i = 1; i < coraTable.rows.length; i++) {
        if (coraTable.rows[i].cells[0].textContent.trim() === nextCPT) {
            const backlog = parseInt(coraTable.rows[i].cells[1].textContent.trim().replace(/,/g, ''), 10);
            console.log(`Current Backlog (Column A) for Next CPT ${nextCPT}: ${backlog}`);
            return isNaN(backlog) ? 0 : backlog;
        }
    }

    console.warn(`No backlog data found for Next CPT ${nextCPT}`);
    return 0;
}

function getNextCPTColumnEFromCORA(nextCPT) {
    const coraTable = document.querySelector('.CORA-table');
    if (!coraTable) {
        console.error('CORA table not found');
        return 0;
    }

    for (let i = 1; i < coraTable.rows.length; i++) {
        if (coraTable.rows[i].cells[0].textContent.trim() === nextCPT) {
            const columnE = parseInt(coraTable.rows[i].cells[3].textContent.trim().replace(/,/g, ''), 10);
            console.log(`Column E value for Next CPT ${nextCPT}: ${columnE}`);
            return isNaN(columnE) ? 0 : columnE;
        }
    }

    console.warn(`No Column E data found for Next CPT ${nextCPT}`);
    return 0;
}
function createPopup(content) {
    const popup = document.createElement('div');
    popup.style.position = 'fixed';
    popup.style.left = '50%';
    popup.style.top = '50%';
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.backgroundColor = 'white';
    popup.style.padding = '20px';
    popup.style.border = '2px solid black';
    popup.style.zIndex = '10000';
    popup.style.maxHeight = '80vh';
    popup.style.overflowY = 'auto';
    popup.innerHTML = content;

    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.onclick = () => document.body.removeChild(popup);
    popup.appendChild(closeButton);

    document.body.appendChild(popup);
}
function fetchRTSData(siteCode) {
    console.log(`[DEBUG] Starting fetchRTSData for site: ${siteCode}`);
    const stationCode = complementaryStations[siteCode];
    if (!stationCode) {
        console.error(`[DEBUG] No complementary station found for site: ${siteCode}`);
        return Promise.resolve(0);
    }

    console.log(`[DEBUG] Fetching RTS data for station: ${stationCode}`);

    const payload = {
        "resourcePath": "/os/getDwellingPackageData",
        "httpMethod": "post",
        "processName": "oculus",
        "requestBody": {
            "nodeId": stationCode,
            "view": "RTS_VIEW",
            "filters": [
                {
                    "__type": "TermFilter:http://internal.amazon.com/coral/com.amazon.oculusservice.model.filter/",
                    "filterMap": {}
                },
                {
                    "__type": "RangeFilter:http://internal.amazon.com/coral/com.amazon.oculusservice.model.filter/",
                    "filterMap": {}
                }
            ],
            "leg": "REVERSE"
        }
    };

    return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
            method: "POST",
            url: "https://logistics.amazon.com/station/proxyapigateway/data",
            headers: {
                "Content-Type": "application/json",
                "X-Requested-With": "XMLHttpRequest",
                "Referer": `https://logistics.amazon.com/station/dashboard/rts?stationCode=${stationCode}`,
            },
            data: JSON.stringify(payload),
            onload: function(response) {
                if (response.status >= 200 && response.status < 300) {
                    try {
                        const data = JSON.parse(response.responseText);
                        console.log(`[DEBUG] Received data for ${stationCode}:`, data);

                        const rtsVolume = calculateSumForStatuses(data);
                        console.log(`[DEBUG] Calculated RTS volume for ${stationCode}: ${rtsVolume}`);

                        updateRTSVolume(rtsVolume);

                        resolve(rtsVolume);
                    } catch (error) {
                        console.error(`[DEBUG] Error processing RTS data for ${stationCode}:`, error);
                        reject(error);
                    }
                } else {
                    console.error(`[DEBUG] HTTP error! status: ${response.status}`);
                    reject(new Error(`HTTP error! status: ${response.status}`));
                }
            },
            onerror: function(error) {
                console.error(`[DEBUG] Error fetching RTS data for ${stationCode}:`, error);
                reject(error);
            }
        });
    });
}

function calculateSumForStatuses(data) {
    console.log(`[DEBUG] Starting calculateSumForStatuses`);
    const statusesToSum = [
        "Received",
        "RTS Received",
        "Marked For Reprocess",
        "Undeliverable",
        "Stowed",
        "In Transit",
        "Marked for Reprocess"
    ];

    let sum = 0;
    const uniqueStatuses = new Set();

    if (data.metricResult && Array.isArray(data.metricResult)) {
        console.log(`[DEBUG] Processing ${data.metricResult.length} metric results`);
        data.metricResult.forEach((item, index) => {
            console.log(`[DEBUG] Processing item ${index}:`, JSON.stringify(item, null, 2));
            const context = item.metaDataMap?.direction || "no-context";
            const key = `${item.packageStatus}-${context}-${item.columnToViewDataMap?.TOTAL?.value}`;
            if (statusesToSum.includes(item.packageStatus) && !uniqueStatuses.has(key) && !(item.packageStatus === "Received" && context === "DS -> Customer")) {
                const totalValue = parseInt(item.columnToViewDataMap?.TOTAL?.value || "0", 10);
                sum += totalValue;
                uniqueStatuses.add(key);
                console.log(`[DEBUG] Added ${totalValue} to sum for status: ${item.packageStatus}, context: ${context}`);
            } else {
                console.log(`[DEBUG] Skipped item. Status: ${item.packageStatus}, Context: ${context}, Key: ${key}`);
            }
        });
    } else {
        console.log(`[DEBUG] No metricResult array found in data`);
    }

    console.log(`[DEBUG] Final sum: ${sum}`);
    return sum;
}

function updateActivePendingVolume(siteCode, lineHaulId) {
    const stationCode = complementaryStations[siteCode];
    if (!stationCode) {
        console.error(`No complementary station found for site: ${siteCode}`);
        return Promise.resolve();
    }

    const payload = {
        "resourcePath": "/ivs/getLineHaulContainerDetail",
        "httpMethod": "post",
        "processName": "induct",
        "requestBody": {
            "nodeId": stationCode,
            "lineHaulId": [lineHaulId],
            "filters": {
                "Cycle": [],
                "EAD": [],
                "OtherAttributes": [],
                "Cluster": [],
                "PackageSize": [],
                "StationCode": []
            }
        }
    };

    return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
            method: "POST",
            url: "https://logistics.amazon.com/station/proxyapigateway/data",
            headers: {
                "Content-Type": "application/json",
                "X-Requested-With": "XMLHttpRequest",
                "Referer": `https://logistics.amazon.com/station/dashboard/receive?stationCode=${stationCode}`,
            },
            data: JSON.stringify(payload),
            onload: function(response) {
                if (response.status >= 200 && response.status < 300) {
                    try {
                        const data = JSON.parse(response.responseText);
                        const containerDetails = data.lineHaulsContainerDetail[lineHaulId];
                        if (containerDetails) {
                            const totalPendingInductVolume = containerDetails.reduce((sum, container) =>
                                sum + (container.pendingInductVolume || 0), 0);
                            console.log(`LineHaul ${lineHaulId} Pending Induct Volume: ${totalPendingInductVolume}`);
                            updateTableWithActivePendingVolume(lineHaulId, totalPendingInductVolume);
                            resolve(totalPendingInductVolume);
                        } else {
                            console.log(`No container details found for LineHaul ID: ${lineHaulId}`);
                            updateTableWithActivePendingVolume(lineHaulId, 'Loading...');
                            resolve();
                        }
                    } catch (error) {
                        console.error('Error processing container detail data:', error);
                        updateTableWithActivePendingVolume(lineHaulId, 'Loading...');
                        resolve();
                    }
                } else {
                    console.error(`HTTP error! status: ${response.status}`);
                    updateTableWithActivePendingVolume(lineHaulId, 'Loading...');
                    resolve();
                }
            },
            onerror: function(error) {
                console.error('Error fetching container detail data:', error);
                updateTableWithActivePendingVolume(lineHaulId, 'Loading...');
                resolve();
            }
        });
    });
}

function decrementPendingUpdates() {
    pendingUpdates--;
    console.log(`Pending updates: ${pendingUpdates}`);
    if (pendingUpdates === 0) {
        console.log('All updates completed. Updating Dispatch Recommendation table.');
        updateDispatchRecommendationTable();
    }
}
let totalArrivedActivePendingVolume = 0;
let pendingUpdates = 0;
function updateTableWithActivePendingVolume(lineHaulId, volume) {
    // Add 2-second delay before processing
    setTimeout(() => {
        const table = document.getElementById('lineHaulTable');
        if (!table) return;

        const rows = table.querySelectorAll('tr');
        let totalArrivedVolume = 0;

        for (let i = 1; i < rows.length; i++) { // Skip header row
            const row = rows[i];
            const idCell = row.cells[0];
            const statusCell = row.cells[1];

            // Update the specific linehaul's volume
            if (idCell && idCell.textContent === lineHaulId) {
                const activePendingVolumeCell = row.cells[5];
                if (activePendingVolumeCell) {
                    activePendingVolumeCell.textContent = volume;
                    activePendingVolumeCell.style.backgroundColor = '#FFFF00';
                    setTimeout(() => {
                        activePendingVolumeCell.style.backgroundColor = '';
                    }, 5000);
                }
            }

            // Calculate total volume from all ARRIVED linehuals
            if (statusCell && statusCell.textContent === 'ARRIVED') {
                const volumeCell = row.cells[5];
                if (volumeCell) {
                    totalArrivedVolume += parseInt(volumeCell.textContent) || 0;
                }
            }
        }

        // Update the Dispatch Recommendation table with the new total
        const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
        if (dispatchTable) {
            const injectionRow = Array.from(dispatchTable.rows)
                .find(row => row.cells[0].textContent.trim() === 'Injection');

            if (injectionRow && injectionRow.cells[1]) {
                injectionRow.cells[1].textContent = totalArrivedVolume;
                injectionRow.cells[1].style.backgroundColor = 'lightgreen';
            }
        }
    }, 2000); // 2-second delay
}


function updateDispatchRecommendationTable() {
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    const currentSite = document.getElementById('siteSelector').value;

    // Define CET schedules within the function
    const standardCETSchedule = {
        'CET1': [
            { name: 'Breakfast', time: '18:45' },
            { name: 'Brunch', time: '03:30' },
            { name: 'Bedtime', time: '14:00' }
        ],
        'CET2': [
            { name: 'Breakfast', time: '22:00' },
            { name: 'Brunch', time: '05:30' },
            { name: 'Lunch', time: '07:30' },
            { name: 'Dinner', time: '11:30' },
            { name: 'Bedtime', time: '16:00' }
        ]
    };

    const sny1CETSchedule = {
        'CET1': [
            { name: 'Breakfast', time: '16:00' }
        ],
        'CET2': [
            { name: 'Breakfast', time: '18:20' },
            { name: 'Bedtime', time: '10:30' }
        ],
        'CET3': [
            { name: 'Breakfast', time: '21:20' },
            { name: 'Brunch', time: '02:30' },
            { name: 'Dinner', time: '07:00' },
            { name: 'Bedtime', time: '12:30' }
        ]
    };

    // Helper function to convert time to minutes
    function convertTimeToMinutes(timeStr) {
        const [hours, minutes] = timeStr.split(':').map(Number);
        return hours * 60 + minutes;
    }

    // Helper function to check if CET has passed
    function isCETPassed(plannedTime, cetTime) {
        const now = new Date();
        const plannedDate = new Date(plannedTime);

        // If the planned date is in the future, CET hasn't passed
        if (plannedDate > now) {
            return false;
        }

        const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();
        const cetTimeMinutes = convertTimeToMinutes(cetTime);

        // Handle midnight crossing
        if (cetTimeMinutes < currentTimeMinutes) {
            return true;
        }

        return currentTimeMinutes >= cetTimeMinutes;
    }

    // Helper function to get CET for a given time
    function getCETForTime(plannedTime) {
        const plannedDateTime = new Date(plannedTime);
        const plannedHours = plannedDateTime.getHours();
        const plannedMinutes = plannedDateTime.getMinutes();
        const plannedTimeInMinutes = plannedHours * 60 + plannedMinutes;

        if (currentSite === 'SNY1') {
            // SNY1 specific CET windows
            const sny1Windows = [
                { start: '12:30', end: '16:00', cet: 'Breakfast - CET1' },
                { start: '16:00', end: '18:20', cet: 'Breakfast - CET2' },
                { start: '18:20', end: '21:20', cet: 'Breakfast - CET3' },
                { start: '21:20', end: '02:30', cet: 'Brunch - CET3' },
                { start: '02:30', end: '07:00', cet: 'Dinner - CET3' },
                { start: '07:00', end: '10:30', cet: 'Bedtime - CET2' },
                { start: '10:30', end: '12:30', cet: 'Bedtime - CET3' }
            ];

            for (const window of sny1Windows) {
                const startMinutes = convertTimeToMinutes(window.start);
                let endMinutes = convertTimeToMinutes(window.end);

                // Handle midnight crossing
                if (endMinutes < startMinutes) {
                    if (plannedTimeInMinutes >= startMinutes || plannedTimeInMinutes < endMinutes) {
                        return window.cet;
                    }
                } else if (plannedTimeInMinutes >= startMinutes && plannedTimeInMinutes < endMinutes) {
                    return window.cet;
                }
            }
        } else {
            // Standard site CET windows
            const standardWindows = [
                { start: '14:00', end: '16:00', cet: 'Bedtime - CET2' },
                { start: '16:00', end: '18:45', cet: 'Breakfast - CET1' },
                { start: '18:45', end: '22:00', cet: 'Breakfast - CET2' },
                { start: '22:00', end: '03:30', cet: 'Brunch - CET1' },
                { start: '03:30', end: '05:30', cet: 'Brunch - CET2' },
                { start: '05:30', end: '07:30', cet: 'Lunch - CET2' },
                { start: '07:30', end: '11:30', cet: 'Dinner - CET2' },
                { start: '11:30', end: '14:00', cet: 'Bedtime - CET1' }
            ];

            for (const window of standardWindows) {
                const startMinutes = convertTimeToMinutes(window.start);
                let endMinutes = convertTimeToMinutes(window.end);

                // Handle midnight crossing
                if (endMinutes < startMinutes) {
                    if (plannedTimeInMinutes >= startMinutes || plannedTimeInMinutes < endMinutes) {
                        return window.cet;
                    }
                } else if (plannedTimeInMinutes >= startMinutes && plannedTimeInMinutes < endMinutes) {
                    return window.cet;
                }
            }
        }

        return 'Unknown CET';
    }

    // Main table update logic
    if (dispatchTable) {
        let totalArrivedActivePendingVolume = 0;
        const lineHaulTable = document.getElementById('lineHaulTable');

        if (lineHaulTable) {
            const lineHaulRows = lineHaulTable.querySelectorAll('tr');
            lineHaulRows.forEach(row => {
                const statusCell = row.cells[1];
                const plannedTimeCell = row.cells[2];
                const cetCell = row.cells[3];
                const volumeCell = row.cells[5];

                if (statusCell &&
                    statusCell.textContent === 'ARRIVED' &&
                    plannedTimeCell &&
                    cetCell &&
                    volumeCell) {

                    const plannedTime = plannedTimeCell.textContent;
                    const cetInfo = cetCell.textContent;
                    const [cetMeal, cetType] = cetInfo.split(' - ');

                    // Get the appropriate CET schedule
                    const schedule = currentSite === 'SNY1' ? sny1CETSchedule : standardCETSchedule;

                    // Verify CET timing
                    if (schedule[cetType]) {
                        const cetTime = schedule[cetType].find(cet => cet.name === cetMeal)?.time;

                        if (cetTime && isCETPassed(plannedTime, cetTime)) {
                            const volume = parseInt(volumeCell.textContent) || 0;
                            totalArrivedActivePendingVolume += volume;
                            console.log(`Adding volume ${volume} from linehaul with CET ${cetMeal} - ${cetType}`);
                        }
                    }
                }
            });
        }

        // Update the Injection row in dispatch table
        const rows = dispatchTable.querySelectorAll('tr');
        for (let row of rows) {
            const pathCell = row.cells[0];
            if (pathCell && pathCell.textContent.trim() === 'Injection') {
                const volumeCell = row.cells[1];
                if (volumeCell) {
                    volumeCell.textContent = totalArrivedActivePendingVolume;
                    volumeCell.style.backgroundColor = '#90EE90'; // Light green
                    volumeCell.style.transition = 'background-color 0.5s ease';
                    console.log(`Updated Injection volume to: ${totalArrivedActivePendingVolume}`);
                }
                break;
            }
        }
    } else {
        console.error('Dispatch Recommendation table not found');
    }

    attachSettingsButton2();
}

window.addEventListener('load', createSettingsButton2);
let arrivedLineHaulsCount = 0;
function processLineHauls(siteCode) {
    const table = document.getElementById('lineHaulTable');
    if (table) {
        const rows = table.querySelectorAll('tr');
        pendingUpdates = [];
        arrivedLineHaulsCount = 0;
        totalArrivedActivePendingVolume = 0;

        rows.forEach(row => {
            const idCell = row.cells[0];
            if (idCell) {
                const lineHaulId = idCell.textContent;
                pendingUpdates.push(updateActivePendingVolume(siteCode, lineHaulId));
            }
        });

        Promise.all(pendingUpdates)
            .then(() => {
                console.log('All Active Pending Volume updates completed.');
                // Final check to ensure we've captured all ARRIVED volumes
                totalArrivedActivePendingVolume = 0;
                table.querySelectorAll('tr').forEach(row => {
                    if (row.cells[1] && row.cells[1].textContent === 'ARRIVED' && row.cells[4]) {
                        totalArrivedActivePendingVolume += parseInt(row.cells[4].textContent) || 0;
                    }
                });
                console.log(`Total Arrived Active Pending Volume: ${totalArrivedActivePendingVolume}`);
                updateDispatchRecommendationTable();
            })
            .catch(error => {
                console.error('Error updating Active Pending Volumes:', error);
            });
    }
}
function fetchProblemSolveData(siteCode) {
    console.log(`[DEBUG] Starting fetchProblemSolveData for site: ${siteCode}`);
    const stationCode = complementaryStations[siteCode];
    if (!stationCode) {
        console.error(`[DEBUG] No complementary station found for site: ${siteCode}`);
        updateRolledVolume(null);
        return Promise.resolve(0);
    }
    const now = Math.floor(Date.now() / 1000);
    const startDate = now - 86400; // 86400 seconds in 24 hours

    const payload = {
        "resourcePath": "/nevs/nevs/getExceptionShipments",
        "httpMethod": "post",
        "processName": "exceptions",
        "requestBody": {
            "categories": ["MISSORT", "DRIVER_LEFT_BEHIND", "DRIVER_REJECTED", "MISSING", "CUBE_OUT", "PICK_LEFT_BEHIND"],
            "startDate": startDate, // 24 hours back, not sure if this is how that works for rolled but it would be resolved by then right? Ask someone later cause reasons.
            "endDate": now, // The Future is now old man
            "shipmentDetailsRequired": false,
            "targetStatus": "OPEN",
            "stationCode": stationCode
        }
    };

    console.log(`[DEBUG] Fetching problem solve data for station: ${stationCode}`);

    return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
            method: "POST",
            url: "https://logistics.amazon.com/station/proxyapigateway/data",
            headers: {
                "Content-Type": "application/json",
                "X-Requested-With": "XMLHttpRequest",
                "Referer": `https://logistics.amazon.com/station/dashboard/problemsolve?stationCode=${stationCode}`,
            },
            data: JSON.stringify(payload),
            onload: function(response) {
                if (response.status >= 200 && response.status < 300) {
                    try {
                        const data = JSON.parse(response.responseText);
                        console.log(`[DEBUG] Received data for ${stationCode}:`, data);

                        // Count all exception shipments
                        const rolledCount = data.exceptionShipments ? data.exceptionShipments.length : 0;

                        console.log(`[DEBUG] Rolled count (exception shipments) for ${stationCode}: ${rolledCount}`);
                        updateRolledVolume(rolledCount);
                        resolve(rolledCount);
                    } catch (error) {
                        console.error(`[DEBUG] Error processing problem solve data for ${stationCode}:`, error);
                        updateRolledVolume(null);
                        reject(error);
                    }
                } else {
                    console.error(`[DEBUG] HTTP error! status: ${response.status}`);
                    updateRolledVolume(null);
                    reject(new Error(`HTTP error! status: ${response.status}`));
                }
            },
            onerror: function(error) {
                console.error(`[DEBUG] Error fetching problem solve data for ${stationCode}:`, error);
                updateRolledVolume(null);
                reject(error);
            }
        });
    });
}

function updateRolledVolume(volume) {
    console.log(`[DEBUG] Updating Rolled volume: ${volume}`);
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    if (dispatchTable) {
        const rolledRow = Array.from(dispatchTable.rows).find(row => row.cells[0].textContent.trim() === 'Rolled');
        if (rolledRow && rolledRow.cells.length > 1) {
            const volumeCell = rolledRow.cells[1];

            if (volume !== null && volume !== undefined) {
                volumeCell.textContent = volume;
                volumeCell.style.backgroundColor = 'yellow';
                setTimeout(() => {
                    volumeCell.style.backgroundColor = 'lightgreen';
                }, 2000); // Change to light green after 2 seconds
                console.log(`[DEBUG] Rolled volume updated successfully to: ${volume}`);
            } else {
                volumeCell.textContent = 'Update failed';
                volumeCell.style.backgroundColor = 'lightcoral';
                console.error('[DEBUG] Failed to update Rolled volume: Invalid volume');
            }
        } else {
            console.error('[DEBUG] Rolled row or volume cell not found in Dispatch Recommendation table');
        }
    } else {
        console.error('[DEBUG] Dispatch Recommendation table not found');
    }
}


document.getElementById('siteSelector').addEventListener('change', updateSiteData, fetchShiftPlanSettings);
function fetchAndUpdateHeldData(siteCode) {
    console.log(`[DEBUG] Starting fetchAndUpdateHeldData for site: ${siteCode}`);
    const stationCode = complementaryStations[siteCode];
    if (!stationCode) {
        console.error(`[DEBUG] No complementary station found for site: ${siteCode}`);
        updateHeldVolume(null);
        return Promise.resolve(0);
    }

    const payload = {
        "resourcePath": "/os/getDwellingPackageData",
        "httpMethod": "post",
        "processName": "oculus",
        "requestBody": {
            "nodeId": stationCode,
            "view": "SD_DWELLING_VIEW",
            "filters": [{
                "__type": "TermFilter:http://internal.amazon.com/coral/com.amazon.oculusservice.model.filter/",
                "filterMap": {
                    "SHIPMENT_TYPE": ["Delivery"]
                }
            }, {
                "__type": "RangeFilter:http://internal.amazon.com/coral/com.amazon.oculusservice.model.filter/",
                "filterMap": {}
            }],
            "leg": "FORWARD"
        }
    };

    return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
            method: "POST",
            url: "https://logistics.amazon.com/station/proxyapigateway/data",
            headers: {
                "Content-Type": "application/json",
                "X-Requested-With": "XMLHttpRequest",
                "Referer": `https://logistics.amazon.com/station/dashboard/dwell?stationCode=${stationCode}`
            },
            data: JSON.stringify(payload),
            onload: function(response) {
                if (response.status >= 200 && response.status < 300) {
                    try {
                        const data = JSON.parse(response.responseText);
                        console.log(`[DEBUG] Received data for ${stationCode}`);

                        // Find the "Held On Ead" entry
                        const heldOnEadEntry = data.metricResult.find(item =>
                            item.packageStatus === "Held On Ead"
                        );

                        let totalHeldCount = 0;
                        if (heldOnEadEntry && heldOnEadEntry.columnToViewDataMap) {
                            // Sum up all values across all time frames
                            totalHeldCount = Object.values(heldOnEadEntry.columnToViewDataMap)
                                .reduce((sum, timeFrame) => {
                                    return sum + (parseInt(timeFrame.value) || 0);
                                }, 0);
                        }

                        console.log(`[DEBUG] Total Held On Ead count for ${stationCode}: ${totalHeldCount}`);
                        updateHeldVolume(totalHeldCount);
                        resolve(totalHeldCount);

                    } catch (error) {
                        console.error(`[DEBUG] Error processing held data for ${stationCode}:`, error);
                        updateHeldVolume(null);
                        reject(error);
                    }
                } else {
                    console.error(`[DEBUG] HTTP error! status: ${response.status}`);
                    updateHeldVolume(null);
                    reject(new Error(`HTTP error! status: ${response.status}`));
                }
            },
            onerror: function(error) {
                console.error(`[DEBUG] Error fetching held data for ${stationCode}:`, error);
                updateHeldVolume(null);
                reject(error);
            }
        });
    });
}
function updateHeldVolume(volume) {
    console.log(`[DEBUG] Updating Held volume: ${volume}`);
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    if (dispatchTable) {
        const heldRow = Array.from(dispatchTable.rows).find(row => row.cells[0].textContent.trim() === 'Held');
        if (heldRow && heldRow.cells.length > 1) {
            const volumeCell = heldRow.cells[1];

            if (volume !== null && volume !== undefined) {
                volumeCell.textContent = volume;
                volumeCell.style.backgroundColor = 'yellow';
                setTimeout(() => {
                    volumeCell.style.backgroundColor = 'lightgreen';
                }, 2000); // Change to light green after 2 seconds
                console.log(`[DEBUG] Held volume updated successfully to: ${volume}`);
            } else {
                volumeCell.textContent = 'Update failed';
                volumeCell.style.backgroundColor = 'lightcoral';
                console.error('[DEBUG] Failed to update Held volume: Invalid volume');
            }
        } else {
            console.error('[DEBUG] Held row or volume cell not found in Dispatch Recommendation table');
        }
    } else {
        console.error('[DEBUG] Dispatch Recommendation table not found');
    }
}
function fetchShiftPlanSettings() {
    const selectedSite = document.getElementById('siteSelector').value;
    const stationCode = complementaryStations[selectedSite];

    if (!stationCode) {
        console.error(`No station code found for site: ${selectedSite}`);
        alert(`No station code found for site: ${selectedSite}`);
        return;
    }

    console.log(`Fetching shift plan settings for station: ${stationCode}`);

    GM_xmlhttpRequest({
        method: 'GET',
        url: `https://logistics.amazon.com/station/shift-plan-settings/get?stationCode=${stationCode}`,
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        },
        onload: function(response) {
            console.log(`Request status: ${response.status}`);
            try {
                const data = JSON.parse(response.responseText);
                if (data && data.url) {
                    console.log(`Settings URL: ${data.url}`);
                    displayJsonInIframe(data.url, stationCode);
                } else {
                    throw new Error('URL not found in the response');
                }
            } catch (error) {
                const errorMessage = `Error processing response: ${error.message}`;
                console.error(errorMessage);
                alert(errorMessage);
            }
        },
        onerror: function(error) {
            const errorMessage = `Error fetching settings: ${error.message || 'Unknown error'}`;
            console.error(errorMessage);
            alert(errorMessage);
        }
    });
}
function displayJsonInIframe(url, stationCode) {
  let popup = document.createElement('div');
    popup.style.position = 'fixed';
    popup.style.left = '10%';
    popup.style.top = '10%';
    popup.style.width = '80%';
    popup.style.height = '80%';
    popup.style.backgroundColor = 'white';
    popup.style.padding = '20px';
    popup.style.border = '1px solid black';
    popup.style.zIndex = '10000';
    popup.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
    popup.style.display = 'flex';
    popup.style.flexDirection = 'column';

    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.style.position = 'fixed';
    closeButton.style.top = '10%';
    closeButton.style.right = '10%';
    closeButton.style.zIndex = '10002';
    closeButton.onclick = () => document.body.removeChild(popup);

    const extractButton = document.createElement('button');
    extractButton.textContent = 'Extract Data';
    extractButton.style.position = 'fixed';
    extractButton.style.top = '10%';
    extractButton.style.right = 'calc(10% + 60px)';
    extractButton.style.zIndex = '10002';

    const iframe = document.createElement('iframe');
    iframe.src = url;
    iframe.style.width = '100%';
    iframe.style.height = 'calc(100% - 40px)';
    iframe.style.border = 'none';
    iframe.style.marginTop = '40px';

    const jsonContainer = document.createElement('textarea');
    jsonContainer.style.width = '100%';
    jsonContainer.style.height = '20%';
    jsonContainer.style.marginTop = '10px';
    jsonContainer.placeholder = 'JSON data will appear here after extraction';
    jsonContainer.style.display = 'none';

    const tableContainer = document.createElement('div');
    tableContainer.id = 'tableContainer';
    tableContainer.style.width = '100%';
    tableContainer.style.height = '40%';
    tableContainer.style.overflowY = 'auto';
    tableContainer.style.marginTop = '10px';
    tableContainer.innerHTML = '<p>Table will appear here after data extraction.</p>';
    tableContainer.style.display = 'none';

    extractButton.onclick = function() {
        // Your extraction logic here
        jsonContainer.style.display = 'block';
        tableContainer.style.display = 'block';
        iframe.style.height = 'calc(40% - 40px)';
    };

    popup.appendChild(closeButton);
    popup.appendChild(extractButton);
    popup.appendChild(iframe);
    popup.appendChild(jsonContainer);
    popup.appendChild(tableContainer);
    document.body.appendChild(popup);

    console.log('Popup created and added to body');
}

function addFetchButton() {
    const buttonContainer = document.createElement('div');
    buttonContainer.style.position = 'fixed';
    buttonContainer.style.top = '100px';
    buttonContainer.style.right = '300px';
    buttonContainer.style.zIndex = '9999';

    const fetchButton = document.createElement('button');
    fetchButton.textContent = 'Fetch Shift Plan Settings';
    fetchButton.style.marginRight = '10px';
    fetchButton.onclick = () => fetchShiftPlanSettings('VGA1');

    const pasteButton = document.createElement('button');
    pasteButton.textContent = 'Paste JSON';

    buttonContainer.appendChild(fetchButton);
    buttonContainer.appendChild(pasteButton);
    document.body.appendChild(buttonContainer);
}


// Run the function to add the button when the script loads
addFetchButton();

const defaultSettings = {
    "Induct": { defaultRate: 1400, minHC: 0, maxHC: 4, minRate: 900, maxRate: 1800, maxThroughput: 3400 },
    "Buffer": { defaultRate: 300, minHC: 3, maxHC: 17, minRate: "-", maxRate: "-", maxThroughput: 4500 },
    "Stow": { defaultRate: 275, minHC: 3, maxHC: 9, minRate: 100, maxRate: 400, maxThroughput: 4500 },
    "Stage": { defaultRate: 750, minHC: 1, maxHC: 6, minRate: 600, maxRate: 1200, maxThroughput: 4500 },
    "RTS": { defaultRate: "-", minHC: 1, maxHC: "-", minRate: "-", maxRate: "-", maxThroughput: "-" },
    "Empty Cart Return": { defaultRate: "-", minHC: "-", maxHC: "-", minRate: "-", maxRate: "-", maxThroughput: "-" },
    "Spotter (Cart Return)": { defaultRate: "-", minHC: "-", maxHC: "-", minRate: "-", maxRate: "-", maxThroughput: "-" },
    "Unload": { defaultRate: 1200, minHC: 0, maxHC: 2, minRate: 525, maxRate: 1800, maxThroughput: "-" },
    "Outbound Problem Solve": { defaultRate: "-", minHC: 1, maxHC: "-", minRate: "-", maxRate: "-", maxThroughput: "-" },
    "Sortation Problem Solve": { defaultRate: "-", minHC: 1, maxHC: "-", minRate: "-", maxRate: "-", maxThroughput: "-" },
    "Process Assistant": { defaultRate: "-", minHC: 1, maxHC: "-", minRate: "-", maxRate: "-", maxThroughput: "-" }
};


// Global variable to store settings for all sites
let allSiteSettings = {};
let settingsButton2;


// Function to create the settings button
function createSettingsButton2() {
    if (!settingsButton2) {
        settingsButton2 = document.createElement('button');
        settingsButton2.textContent = 'Settings';
        settingsButton2.style.marginLeft = '10px';
        settingsButton2.addEventListener('click', showSettingsPopup);
    }
    attachSettingsButton2();
}
function attachSettingsButton2() {
    const container = document.getElementById('dispatchRecommendationContainer');
    if (!container) {
        console.log('Dispatch Recommendation container not found');
        return;
    }
    if (!settingsButton2) {
        createSettingsButton2();
    }
    const title = container.querySelector('h2');
    if (title && !title.contains(settingsButton2)) {
        title.appendChild(settingsButton2);
        console.log('Settings button attached to container');
    }
}


function showSettingsPopup() {
    const popup = document.createElement('div');
    popup.style.position = 'fixed';
    popup.style.left = '50%';
    popup.style.top = '50%';
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.backgroundColor = 'white';
    popup.style.padding = '20px';
    popup.style.border = '1px solid black';
    popup.style.zIndex = '10000';
    popup.style.maxHeight = '80vh';
    popup.style.overflowY = 'auto';

    const table = createSettingsTable();
    popup.appendChild(table);

    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '10px';
    buttonContainer.style.display = 'flex';
    buttonContainer.style.gap = '10px';
    buttonContainer.style.justifyContent = 'center'; // Center the buttons

    const extractButton = document.createElement('button');
    extractButton.textContent = 'Extract All Settings';
    extractButton.onclick = () => {
        const settingsString = generateDefaultSettingsString();
        navigator.clipboard.writeText(settingsString).then(() => {
            alert('Default settings copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy settings: ', err);
            alert('Failed to copy settings. See console for details.');
        });
    };

    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.onclick = () => document.body.removeChild(popup);

    const saveButton = document.createElement('button');
    saveButton.textContent = 'Save Settings';
    saveButton.onclick = () => saveSettings(table);

    const importButton = document.createElement('button');
    importButton.textContent = 'Import JSON';
    importButton.onclick = () => importJSON();

    // Add the Clear Data button
    const clearDataButton = document.createElement('button');
    clearDataButton.textContent = 'Clear All Data';
    clearDataButton.style.backgroundColor = '#ff4444';
    clearDataButton.style.color = 'white';
    clearDataButton.style.padding = '5px 10px';
    clearDataButton.style.border = '1px solid #cc0000';
    clearDataButton.style.borderRadius = '3px';
    clearDataButton.onmouseover = () => {
        clearDataButton.style.backgroundColor = '#ff6666';
    };
    clearDataButton.onmouseout = () => {
        clearDataButton.style.backgroundColor = '#ff4444';
    };
    clearDataButton.onclick = function() {
        if (confirm('Are you sure you want to clear all saved settings? This cannot be undone.')) {
            localStorage.removeItem('siteSettings');
            localStorage.removeItem('lastSelectedSite');
            allSiteSettings = {};
            alert('All settings have been cleared. The page will now refresh.');
            window.location.reload();
        }
    };

    const iframeButton = document.createElement('button');
    iframeButton.textContent = 'Fetch Shift Plan Settings';
    iframeButton.onclick = () => {
        const selectedSite = document.getElementById('siteSelector').value;
        if (selectedSite) {
            fetchShiftPlanSettings();
        } else {
            alert('Please select a site first');
        }
    };

    // Add buttons to container
    buttonContainer.appendChild(extractButton);
    buttonContainer.appendChild(closeButton);
    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(importButton);
    buttonContainer.appendChild(clearDataButton); // Add the new button
    buttonContainer.appendChild(iframeButton);

    popup.appendChild(buttonContainer);
    document.body.appendChild(popup);
}

function createSettingsTable() {
    const table = document.createElement('table');
    table.id = 'settingsTable';
    table.style.borderCollapse = 'collapse';
    table.style.width = '100%';
    table.style.fontSize = '14px';

    // Create header row
    const headerRow = table.insertRow();
    ['Process Role', 'Default Rate', 'Min HC (Time Ranges)', 'Max HC', 'Min Rate', 'Max Rate', 'Max Throughput'].forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        th.style.backgroundColor = '#d9edf7';
        th.style.padding = '8px';
        th.style.border = '1px solid black';
        headerRow.appendChild(th);
    });

    const currentSite = document.getElementById('siteSelector').value;
    const siteSettings = allSiteSettings[currentSite] || defaultSettings;

    // Process roles and their configurations
    Object.entries(siteSettings).forEach(([role, values]) => {
        const row = table.insertRow();

        // Process Role cell
        const roleCell = row.insertCell();
        roleCell.style.padding = '8px';
        roleCell.style.border = '1px solid black';
        roleCell.textContent = role;

        // Default Rate cell
        const rateCell = row.insertCell();
        rateCell.style.padding = '8px';
        rateCell.style.border = '1px solid black';
        rateCell.textContent = values.defaultRate || '-';

// Min HC with Time Ranges cell
const minHCCell = row.insertCell();
minHCCell.style.padding = '8px';
minHCCell.style.border = '1px solid black';
if (values.timeRanges && values.timeRanges.length > 0) {
    // Create a div to contain all time ranges
    const timeRangesDiv = document.createElement('div');
    timeRangesDiv.style.margin = '0';
    timeRangesDiv.style.fontSize = '12px';

    // Add each formatted time range on a new line
    values.timeRanges.forEach(range => {
        const rangeDiv = document.createElement('div');
        rangeDiv.style.marginBottom = '5px';
        rangeDiv.textContent = range.formatted || `Min HC = ${range.value} ${range.days ? 'on ' + range.days : ''} between ${range.start} - ${range.end}`;
        timeRangesDiv.appendChild(rangeDiv);
    });

    minHCCell.appendChild(timeRangesDiv);
} else {
    minHCCell.textContent = values.minHC || '-';
}

        // Remaining cells
        ['maxHC', 'minRate', 'maxRate', 'maxThroughput'].forEach(key => {
            const cell = row.insertCell();
            cell.style.padding = '8px';
            cell.style.border = '1px solid black';
            cell.textContent = values[key] || '-';
        });
    });

    return table;
}


// Function to save settings
function saveSettings(table) {
    const currentSite = document.getElementById('siteSelector').value;
    const settings = {};

    for (let i = 1; i < table.rows.length; i++) {
        const row = table.rows[i];
        const role = row.cells[0].textContent;
        settings[role] = {
            defaultRate: row.cells[1].firstChild.value,
            minHC: row.cells[2].firstChild.value,
            maxHC: row.cells[3].firstChild.value,
            minRate: row.cells[4].firstChild.value,
            maxRate: row.cells[5].firstChild.value,
            maxThroughput: row.cells[6].firstChild.value
        };
    }

    allSiteSettings[currentSite] = settings;
    localStorage.setItem('siteSettings', JSON.stringify(allSiteSettings));
    alert('Settings saved successfully!');
}
function importJSON() {
    const jsonInput = prompt("Paste your JSON settings here:");
    if (!jsonInput) return;

    const currentSite = document.getElementById('siteSelector').value;
    if (!currentSite) {
        alert('Please select a site first');
        return;
    }

    try {
        const siteIdMatch = jsonInput.match(/"site_id"\s*:\s*"([^"]+)"/);
        const fcMatch = jsonInput.match(/"fc"\s*:\s*"([^"]+)"/);

        if (siteIdMatch || fcMatch) {
            const siteIdValue = siteIdMatch ? siteIdMatch[1] : null;
            const fcValue = fcMatch ? fcMatch[1] : null;
            if (siteIdValue !== currentSite && fcValue !== currentSite) {
                alert(`Error: JSON is for a different site (${siteIdValue || fcValue}) but current selected site is ${currentSite}. Please select the correct site or use appropriate JSON data.`);
                return;
            }
        }

        if (!jsonInput.trim().startsWith('{')) {
            throw new Error('Invalid JSON format');
        }

        const data = JSON.parse(jsonInput);
        if (!data || (!data.roles && !data.indirect_process_config)) {
            throw new Error('Invalid data structure');
        }

        const extractedSettings = {};

        const getDayNames = (daysArray) => {
            const dayMap = {
                0: 'Sun',
                1: 'Mon',
                2: 'Tues',
                3: 'Wed',
                4: 'Thur',
                5: 'Fri',
                6: 'Sat'
            };
            return [...new Set(daysArray)].map(day => dayMap[day]).join(', ');
        };

        const groupTimeRanges = (timeRanges) => {
            const grouped = {};
            timeRanges.forEach(range => {
                const key = `${range.value}_${range.start}_${range.end}`;
                if (!grouped[key]) {
                    grouped[key] = {
                        value: range.value,
                        start: range.start,
                        end: range.end,
                        days: []
                    };
                }
                grouped[key].days.push(range.day_of_week);
            });
            return Object.values(grouped);
        };

        [...(data.roles || []), ...(data.indirect_process_config || [])].forEach(role => {
            if (!role.label) return;

            if (role.department_name) {
                const roleNameWithDept = `${role.label} (${role.department_name})`;

                const settings = {
                    defaultRate: 'Fixed',
                    minHC: '-',
                    maxHC: '-',
                    minRatRate: '-',
                    maxRate: '-',
                    maxThroughput: '-',
                    timeRanges: []
                };

                // Add SFL8 exception for Stow (sortation)
                if (currentSite === 'SFL8' && roleNameWithDept === 'Stow (sortation)') {
                    settings.defaultRate = '265';
                    settings.maxHC = '9';
                }

                if (role.value && Array.isArray(role.value) && role.value.length > 0) {
                    if (role.value[0].hasOwnProperty('day_of_week')) {
                        const groupedRanges = groupTimeRanges(role.value);
                        settings.timeRanges = groupedRanges.map(group => ({
                            value: group.value,
                            start: group.start,
                            end: group.end,
                            days: getDayNames(group.days),
                            formatted: `Min HC = ${group.value} on ${getDayNames(group.days)} between ${group.start} - ${group.end}`
                        }));
                    } else {
                        settings.timeRanges = role.value.map(v => ({
                            value: v.value,
                            start: v.start,
                            end: v.end,
                            formatted: `Min HC = ${v.value} between ${v.start} - ${v.end}`
                        }));
                    }
                    settings.minHC = role.value[0].value;
                } else {
                    // Skip the default rate calculation for SFL8 Stow (sortation)
                    if (!(currentSite === 'SFL8' && roleNameWithDept === 'Stow (sortation)')) {
                        if (!role.default_rate && role.min_rate && role.max_rate) {
                            settings.defaultRate = Math.floor((parseInt(role.min_rate) + parseInt(role.max_rate)) / 2);
                        } else {
                            settings.defaultRate = role.default_rate || 'Fixed';
                        }
                        settings.minHC = role.min_hc || '-';
                        settings.maxHC = role.max_hc || '-';
                        settings.minRate = role.min_rate || '-';
                        settings.maxRate = role.max_rate || '-';
                        settings.maxThroughput = role.max_throughput || '-';
                    }
                }

                extractedSettings[roleNameWithDept] = settings;
            }
        });

        allSiteSettings[currentSite] = extractedSettings;
        localStorage.setItem('siteSettings', JSON.stringify(allSiteSettings));
        updateSettingsDisplay();
        updateSiteOptionStyling();
        alert('Settings imported successfully! The Page will now refresh.');
        setTimeout(() => {
            localStorage.setItem('lastSelectedSite', currentSite);
            window.location.reload();
        }, 1000);

    } catch (error) {
        console.error('Error:', error);
        if (error instanceof SyntaxError) {
            alert('Invalid JSON format. Please check your input.');
        } else {
            alert(error.message || 'Error importing settings.');
        }
    }
}



function processRoleConfig(jsonData) {
    const roleConfigs = {};

    // Process both roles array and indirect_process_config
    [...(jsonData.roles || []), ...(jsonData.indirect_process_config || [])]
        .forEach(role => {
            // Skip if no proper identification
            if (!role.name && !role.process_role) {
                return;
            }

            const roleName = role.label || role.process_role;

            // Check if it's a rule-based role with min_headcount
            if ((role.category === 'rule' || role.type === 'min_headcount') && role.value && role.value.length > 0) {
                const timeConfig = role.value[0];
                roleConfigs[roleName] = {
                    defaultRate: 'Fixed',
                    minHC: timeConfig.value, // This is the min HC value
                    maxHC: '-',
                    minRate: '-',
                    maxRate: '-',
                    maxThroughput: '-',
                    timeRange: {
                        start: timeConfig.start,
                        end: timeConfig.end,
                        value: timeConfig.value // Store the min HC value here too
                    }
                };
            }
            // Handle standard roles
            else if (role.department_name && role.label) {
                roleConfigs[role.label] = {
                    defaultRate: role.default_rate || '-',
                    minHC: role.min_hc || '-',
                    maxHC: role.max_hc || '-',
                    minRate: role.min_rate || '-',
                    maxRate: role.max_rate || '-',
                    maxThroughput: role.max_throughput || '-'
                };
            }
        });

    // Handle special fixed-rate roles
    const fixedRateRoles = ['RTS', 'Empty Cart Return', 'Spotter (Cart Return)',
                           'Outbound Problem Solve', 'Sortation Problem Solve',
                           'Process Assistant'];

    fixedRateRoles.forEach(roleName => {
        if (roleConfigs[roleName]) {
            roleConfigs[roleName].defaultRate = 'Fixed';
        }
    });

    return roleConfigs;
}


function updateSettingsDisplay() {
    // Get the settings table by its ID
    const table = document.querySelector('#settingsTable');
    if (!table) return; // Exit if table not found

    // Get current selected site
    const currentSite = document.getElementById('siteSelector').value;
    // Get settings for current site
    const settings = allSiteSettings[currentSite];

    // Loop through all rows except header (first row)
    Array.from(table.rows).slice(1).forEach(row => {
        // Get the role name from first cell
        const roleNameWithDept = row.cells[0].textContent;
        // Get settings for this specific role
        const roleSettings = settings[roleNameWithDept];

        // If we have settings for this role
        if (roleSettings) {
            // Check if we have time range settings
            const timeRange = roleSettings.timeRange;
            if (timeRange) {
                // Update cell content to include time range info
                row.cells[0].innerHTML = `${roleNameWithDept}<br>
                    <small style="color: #666; font-size: 0.85em;">
                        ${roleSettings.minHC === 'Fixed' ? 'Fixed' : 'Min HC = ' + roleSettings.minHC}
                        between ${timeRange.start} - ${timeRange.end}
                    </small>`;

                // Special styling for fixed rates
                if (roleSettings.defaultRate === 'Fixed') {
                    row.cells[1].innerHTML = `<span style="color: blue;">Fixed</span>`;
                }

                // Add tooltip for full information
                row.cells[0].title = `${roleNameWithDept}\nMin HC: ${roleSettings.minHC}\nTime Range: ${timeRange.start} - ${timeRange.end}`;
            }

            // Update other cells with their respective values
            if (roleSettings.defaultRate) row.cells[1].textContent = roleSettings.defaultRate;
            if (roleSettings.minHC) row.cells[2].textContent = roleSettings.minHC;
            if (roleSettings.maxHC) row.cells[3].textContent = roleSettings.maxHC;
            if (roleSettings.minRate) row.cells[4].textContent = roleSettings.minRate;
            if (roleSettings.maxRate) row.cells[5].textContent = roleSettings.maxRate;
            if (roleSettings.maxThroughput) row.cells[6].textContent = roleSettings.maxThroughput;

            // Add special styling for problem solve roles
            if (roleNameWithDept.toLowerCase().includes('problem solve') ||
                roleNameWithDept.includes('RTS') ||
                roleNameWithDept.includes('Empty Cart Return') ||
                roleNameWithDept.includes('Spotter (Cart Return)')) {
                row.style.backgroundColor = '#fff7e6'; // Light yellow background
                if (roleSettings.defaultRate === 'Fixed') {
                    row.cells[1].innerHTML = '<span style="color: blue;">Fixed</span>';
                }
            }

            // Add standard rates for specific roles
            if (roleNameWithDept.includes('Induct')) row.cells[1].textContent = '1800';
            if (roleNameWithDept.includes('Buffer')) row.cells[1].textContent = '300';
            if (roleNameWithDept.includes('Stow')) row.cells[1].textContent = '300';
        }
    });
}


function updateDispatchTableWithTimeRange(roleName, minHC, timeRange, siteTimeZone) {
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    if (!dispatchTable) return;

    // Get current time in site's timezone
    const siteTime = new Date().toLocaleString("en-US", { timeZone: siteTimeZone });
    const siteDateTime = new Date(siteTime);
    const currentHour = siteDateTime.getHours();
    const currentMinute = siteDateTime.getMinutes();

    // Convert current time to minutes for comparison
    const currentTimeInMinutes = currentHour * 60 + currentMinute;

    // Convert range times to minutes
    const [startHour, startMinute] = timeRange.start.split(':').map(Number);
    const [endHour, endMinute] = timeRange.end.split(':').map(Number);
    const startTimeInMinutes = startHour * 60 + startMinute;
    const endTimeInMinutes = endHour * 60 + endMinute;

    // Check if current time is within range
    const isInRange = currentTimeInMinutes >= startTimeInMinutes &&
                     currentTimeInMinutes <= endTimeInMinutes;

    // Update the table if in range
    if (isInRange) {
        Array.from(dispatchTable.rows).forEach(row => {
            if (row.cells[0].textContent.toLowerCase().includes(roleName.toLowerCase())) {
                // Update min HC in the appropriate cell
                // The exact column index will depend on your table structure
                const cell = row.cells[1]; // Adjust index as needed
                cell.textContent = minHC;
                cell.style.backgroundColor = 'lightgreen';
            }
        });
    }
}
function updateSiteOptionStyling() {
    const siteSelector = document.getElementById('siteSelector');
    const options = siteSelector.options;

    for (let i = 0; i < options.length; i++) {
        const siteCode = options[i].value;
        if (siteCode) { // Skip the default "Select a site" option
            if (!allSiteSettings[siteCode]) {
                options[i].classList.add('no-settings');
            } else {
                options[i].classList.remove('no-settings');
            }
        }
    }
}
window.addEventListener('load', () => {
    const savedSettings = localStorage.getItem('siteSettings');
    if (savedSettings) {
        allSiteSettings = JSON.parse(savedSettings);
    }
    createSettingsButton2();
    updateSiteOptionStyling();
});

// Update blinking effect when site is changed
document.getElementById('siteSelector').addEventListener('change', updateSiteOptionStyling);

function generateDefaultSettingsString() {
    const settingsString = JSON.stringify(allSiteSettings, null, 2);
    return `const defaultAllSiteSettings = ${settingsString};`;
}
function updateDispatchTableFromSettings() {
    console.log('Updating Dispatch table from settings');
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    const currentSite = document.getElementById('siteSelector').value;
    const settings = allSiteSettings[currentSite];

    if (!dispatchTable || !settings) {
        console.error('Dispatch table or settings not found');
        return;
    }

    function getCurrentTimeInfo(siteTimeZone) {
        const siteTime = new Date().toLocaleString("en-US", { timeZone: siteTimeZone });
        const siteDateTime = new Date(siteTime);
        const currentHour = siteDateTime.getHours();
        const currentMinute = siteDateTime.getMinutes();
        const currentDay = siteDateTime.getDay();
        const currentTimeInMinutes = currentHour * 60 + currentMinute;
        return { currentTimeInMinutes, currentDay, siteDateTime };
    }

    function checkTimeRange(currentTime, startTime, endTime, days, currentDay) {
        if (endTime < startTime) {
            return currentTime >= startTime || currentTime <= endTime;
        }

        const inTimeRange = currentTime >= startTime && currentTime <= endTime;

        if (!days) return inTimeRange;

        const dayList = days.split(', ').map(day =>
            ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat'].indexOf(day));

        return inTimeRange && dayList.includes(currentDay);
    }

    function getApplicableHC(config, currentTimeInMinutes, currentDay) {
        if (config.defaultRate === 'Fixed' && config.timeRanges) {
            const twentyFourSeven = config.timeRanges.find(range =>
                range.start === '00:00' &&
                range.end === '00:00' &&
                range.value
            );

            if (twentyFourSeven) {
                return twentyFourSeven.value;
            }
        }

        if (!config.timeRanges || config.timeRanges.length === 0) {
            return config.defaultRate === 'Fixed' ? '0' : (config.minHC || '1');
        }

        function roundUpFixed(value) {
            if (config.defaultRate === 'Fixed') {
                return Math.ceil(parseFloat(value)).toString();
            }
            return value;
        }

        for (const range of config.timeRanges) {
            const [startHour, startMinute] = range.start.split(':').map(Number);
            const [endHour, endMinute] = range.end.split(':').map(Number);
            let startTimeInMinutes = startHour * 60 + startMinute;
            let endTimeInMinutes = endHour * 60 + endMinute;

            if (endTimeInMinutes < startTimeInMinutes) {
                endTimeInMinutes += 24 * 60;
                if (currentTimeInMinutes < startTimeInMinutes) {
                    currentTimeInMinutes += 24 * 60;
                }
            }

            const days = range.days ? range.days.split(', ') : null;
            const dayNames = ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat'];
            const isCorrectDay = !days || days.includes(dayNames[currentDay]);

            if (isCorrectDay &&
                currentTimeInMinutes >= startTimeInMinutes &&
                currentTimeInMinutes < endTimeInMinutes) {
                return roundUpFixed(range.value);
            }
        }

        return config.defaultRate === 'Fixed' ? '0' : '1';
    }

    const headerRow = dispatchTable.rows[0];
    const rateRow = dispatchTable.rows[1];
    const allRow = dispatchTable.rows[2];

    while (headerRow.cells.length > 3) {
        headerRow.deleteCell(3);
        rateRow.deleteCell(3);
        allRow.deleteCell(3);
    }

    const rolesWithRates = [];
    const rolesWithoutRates = [];

    Object.entries(settings).forEach(([role, config]) => {
        if (role.includes('(sortation)')) {
            const displayName = role.replace('(sortation)', '').trim();
            if (config.defaultRate && config.defaultRate !== 'Fixed') {
                rolesWithRates.push({ name: displayName, config });
            } else {
                rolesWithoutRates.push({ name: displayName, config });
            }
        }
    });

    const siteTimeZone = timeZones[siteTimeZones[currentSite]];
    const { currentTimeInMinutes, currentDay } = getCurrentTimeInfo(siteTimeZone);

    [...rolesWithRates, ...rolesWithoutRates].forEach(({ name, config }) => {
        const headerCell = headerRow.insertCell();
        headerCell.textContent = name;
        headerCell.style.padding = '12px';
        headerCell.style.backgroundColor = '#f8fafc';
        headerCell.style.color = '#475569';
        headerCell.style.fontWeight = '600';
        headerCell.style.fontSize = '16px';
        headerCell.style.borderBottom = '2px solid #e2e8f0';
        headerCell.style.borderRight = '1px solid #e2e8f0';
        headerCell.style.textAlign = 'center';

        const rateCell = rateRow.insertCell();
        rateCell.textContent = config.defaultRate || '-';
        rateCell.style.backgroundColor = '#dcfce7';
        rateCell.style.padding = '12px';
        rateCell.style.textAlign = 'center';
        rateCell.style.color = '#166534';
        rateCell.style.fontSize = '16px';
        rateCell.style.borderBottom = '1px solid #e2e8f0';
        rateCell.style.borderRight = '1px solid #e2e8f0';

        const allCell = allRow.insertCell();
        if (config.defaultRate === 'Fixed') {
            const applicableHC = getApplicableHC(config, currentTimeInMinutes, currentDay);
            allCell.textContent = applicableHC;
        } else {
            allCell.textContent = '1';
        }
        allCell.style.padding = '12px';
        allCell.style.backgroundColor = '#fff7ed';
        allCell.style.textAlign = 'center';
        allCell.style.color = '#9a3412';
        allCell.style.fontSize = '16px';
        allCell.style.borderBottom = '1px solid #e2e8f0';
        allCell.style.borderRight = '1px solid #e2e8f0';
    });

    for (let i = 3; i < dispatchTable.rows.length; i++) {
        const row = dispatchTable.rows[i];
        while (row.cells.length > 3) {
            row.deleteCell(3);
        }

        [...rolesWithRates, ...rolesWithoutRates].forEach(() => {
            const cell = row.insertCell();
            cell.style.padding = '12px';
            cell.style.textAlign = 'center';
            cell.style.backgroundColor = i % 2 === 0 ? '#f8fafc' : 'white';
            cell.style.fontSize = '16px';
            cell.style.borderBottom = '1px solid #e2e8f0';
            cell.style.borderRight = '1px solid #e2e8f0';
            cell.textContent = '';
        });
    }

    dispatchTable.style.width = '100%';
    dispatchTable.style.borderCollapse = 'collapse';
    dispatchTable.style.marginTop = '10px';
    dispatchTable.style.fontSize = '16px';
    dispatchTable.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
    dispatchTable.style.borderRadius = '8px';
    dispatchTable.style.overflow = 'hidden';
}

function checkTimeRange(currentTime, startTime, endTime, days, currentDay) {
    // Handle midnight crossing
    if (endTime < startTime) {
        return currentTime >= startTime || currentTime <= endTime;
    }

    const inTimeRange = currentTime >= startTime && currentTime <= endTime;

    if (!days) return inTimeRange;

    const dayList = days.split(', ').map(day =>
        ['Sun', 'Mon', 'Tues', 'Wed', 'Thur', 'Fri', 'Sat'].indexOf(day));

    return inTimeRange && dayList.includes(currentDay);
}

function verifyUpdates(table, settings) {
    // Add verification logic here
    const rateRow = table.rows[1];
    const allRow = table.rows[2];

    Array.from(rateRow.cells).forEach((cell, index) => {
        if (cell.textContent === 'Fixed' && !cell.style.backgroundColor) {
            console.warn(`Missing styling for Fixed rate at column ${index}`);
        }
    });
}

document.getElementById('siteSelector').addEventListener('change', updateDispatchTableFromSettings);

function addDispatchTableInteractivity() {
    console.log("Adding dispatch table interactivity");
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    if (!dispatchTable) {
        console.log("Dispatch table not found");
        return;
    }

    // Get the rates row and ALL row
    const ratesRow = dispatchTable.rows[1];
    const allRow = dispatchTable.rows[2];
    if (!ratesRow || !allRow) {
        console.log("Required rows not found");
        return;
    }

    // Make cells interactive
    for (let i = 3; i < ratesRow.cells.length; i++) {
        const rateCell = ratesRow.cells[i];
        const hcCell = allRow.cells[i];

        // Handle rate cells
        if (rateCell.textContent !== 'Fixed') {
            rateCell.style.cursor = 'pointer';
            rateCell.style.backgroundColor = '#e3f2fd'; // Light blue background to indicate clickable
            rateCell.title = 'Click to update rate';

            rateCell.addEventListener('click', function() {
                showDispatchInputPopup(
                    'Update Rate',
                    this.textContent,
                    (newRate) => {
                        if (!isNaN(newRate)) {
                            this.textContent = newRate;
                            this.style.backgroundColor = '#ffeb3b';
                            recalculateDispatchRecommendations();
                        }
                    }
                );
            });
        }

        // Handle HC cells for Fixed processes
        if (ratesRow.cells[i].textContent === 'Fixed') {
            hcCell.style.cursor = 'pointer';
            hcCell.style.backgroundColor = '#fff3e0'; // Light orange background to indicate clickable
            hcCell.title = 'Click to update headcount';

            hcCell.addEventListener('click', function() {
                showDispatchInputPopup(
                    'Update Headcount',
                    this.textContent,
                    (newHC) => {
                        if (!isNaN(newHC)) {
                            this.textContent = newHC;
                            this.style.backgroundCodColor = '#ffeb3b';
                        }
                    }
                );
            });
        }
    }
    console.log("Dispatch table interactivity added successfully");
}

function showDispatchInputPopup(title, currentValue, onConfirm) {
    // Remove any existing popups
    const existingPopup = document.querySelector('.dispatch-input-popup');
    if (existingPopup) {
        existingPopup.remove();
    }

    const modal = document.createElement('div');
    modal.className = 'dispatch-input-popup'; // Add class for easy identification
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 10000;
    `;

    modal.innerHTML = `
        <h3 style="margin-top:0">${title}</h3>
        <input type="number" value="${currentValue}" style="width:80%;margin:10px 0;padding:5px">
        <div style="text-align:right">
            <button id="cancelBtn" style="padding:5px 10px">Cancel</button>
            <button id="confirmBtn" style="margin-left:10px;background:#4CAF50;color:white;border:none;padding:5px 10px;cursor:pointer">
                Confirm
            </button>
        </div>
    `;

    document.body.appendChild(modal);

    const input = modal.querySelector('input');
    const confirmBtn = modal.querySelector('#confirmBtn');
    const cancelBtn = modal.querySelector('#cancelBtn');

    // Focus input field when modal opens
    setTimeout(() => input.focus(), 0);

    // Handle Enter key
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            onConfirm(input.value);
            modal.remove();
        }
    });

    // Handle Escape key
    document.addEventListener('keydown', function escapeHandler(e) {
        if (e.key === 'Escape') {
            modal.remove();
            document.removeEventListener('keydown', escapeHandler);
        }
    });

    // Handle confirm button click
    confirmBtn.addEventListener('click', () => {
        onConfirm(input.value);
        modal.remove();
    });

    // Handle cancel button click
    cancelBtn.addEventListener('click', () => {
        modal.remove();
    });

    // Click outside to close
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}


function recalculateDispatchRecommendations() {
    const dispatchTable = document.querySelector('#dispatchRecommendationContainer table');
    if (!dispatchTable) return;

    const rows = Array.from(dispatchTable.rows);
    const headerRow = rows[0];
    const ratesRow = rows[1];
    const currentSite = document.getElementById('siteSelector').value;
    const settings = allSiteSettings[currentSite];

    function getSLAHours(slaText) {
        if (!slaText) return 0;
        if (slaText.includes('h')) return parseFloat(slaText);
        if (slaText.includes('m')) return parseFloat(slaText) / 60;
        return 0;
    }

    function enforceConstraints(value, config) {
        if (!value || isNaN(value)) return 0;
        const min = parseFloat(config.minHC) || 0;
        const max = parseFloat(config.maxHC) || Infinity;
        return Math.min(Math.max(Math.ceil(value), min), max);
    }

    const outboundRow = rows.find(row => row.cells[0].textContent.trim() === 'Outbound');
    if (outboundRow) {
        const volume = parseFloat(outboundRow.cells[1].textContent) || 0;
        const slaHours = getSLAHours(outboundRow.cells[2].textContent);

        for (let j = 3; j < outboundRow.cells.length; j++) {
            const headerText = headerRow.cells[j].textContent.trim();
            const rate = ratesRow.cells[j].textContent.trim();

            if (rate !== 'Fixed') {
                const rateValue = parseFloat(rate);
                if (rateValue > 0 && slaHours > 0) {
                    const calculatedHC = volume / (rateValue * slaHours);
                    outboundRow.cells[j].textContent = calculatedHC.toFixed(2);
                    outboundRow.cells[j].style.backgroundColor = '#a5d6a7';
                } else {
                    outboundRow.cells[j].textContent = '0.00';
                }
            }
        }
    }

    for (let i = 3; i < rows.length; i++) {
        const row = rows[i];
        if (row === outboundRow) continue;
        if (row.cells[0].textContent.trim() === 'All') continue;

        const volume = parseFloat(row.cells[1].textContent) || 0;
        const slaHours = getSLAHours(row.cells[2].textContent);

        for (let j = 3; j < row.cells.length; j++) {
            const rate = ratesRow.cells[j].textContent.trim();

            if (rate !== 'Fixed') {
                const rateValue = parseFloat(rate);
                if (rateValue > 0 && slaHours > 0) {
                    const calculatedHC = volume / (rateValue * slaHours);
                    row.cells[j].textContent = calculatedHC.toFixed(2);
                    row.cells[j].style.backgroundColor = '#a5d6a7';
                } else {
                    row.cells[j].textContent = '0.00';
                }
            }
        }
    }

    const allRow = rows.find(row => row.cells[0].textContent.trim() === 'All');
    if (allRow) {
        const allRowIndex = rows.indexOf(allRow);

        let totalVolume = 0;
        for (let i = allRowIndex + 1; i < rows.length; i++) {
            const volumeCell = rows[i].cells[1].textContent.trim();
            if (volumeCell !== 'Pending') {
                totalVolume += parseFloat(volumeCell) || 0;
            }
        }
        allRow.cells[1].textContent = totalVolume;
        allRow.cells[1].style.backgroundColor = 'lightgreen';

        for (let j = 3; j < allRow.cells.length; j++) {
            const headerText = headerRow.cells[j].textContent.trim();
            const rate = ratesRow.cells[j].textContent.trim();

            if (rate === 'Fixed') {
                allRow.cells[j].style.backgroundColor = '#FFE4B5';
                continue;
            }

            let sum = 0;
            for (let i = allRowIndex + 1; i < rows.length; i++) {
                const value = parseFloat(rows[i].cells[j].textContent) || 0;
                sum += value;
            }

            const roleName = headerText + ' (sortation)';
            const roleSettings = settings[roleName];

            if (roleSettings) {
                sum = Math.ceil(sum);
                const finalValue = enforceConstraints(sum, roleSettings);
                allRow.cells[j].textContent = finalValue;
                allRow.cells[j].style.backgroundColor = '#FFE4B5';
            }
        }
    }
    if (allRow) {
        let totalHC = 0;
        for (let i = 3; i < allRow.cells.length; i++) {
            const cellValue = parseFloat(allRow.cells[i].textContent) || 0;
            totalHC += cellValue;
        }

        // Update the HC value
        const hcValueElement = document.getElementById('hcValue');
        if (hcValueElement) {
            hcValueElement.textContent = totalHC.toFixed(2);
            }
        }
    }


////////////////////////////////WEB Hooks and stuff/////////////////////////////////

function addLagrangeUpdateButton() {
    console.log('Adding Lagrange update button');
    const siteHeader = document.getElementById('siteHeader');
    if (!siteHeader) {
        console.error('Site header not found');
        return;
    }
    // Check if button already exists
    if (document.getElementById('lagrangeUpdateButton')) {
        return; // Don't create duplicate button
    }
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'inline-block';
    buttonContainer.style.marginLeft = '20px';
    const updateButton = document.createElement('button');
    updateButton.id = 'lagrangeUpdateButton';
    updateButton.textContent = 'Send Plan and Update Lagrange';
    updateButton.style.padding = '10px 20px';
    updateButton.style.padding = '5px 15px';
    updateButton.style.backgroundColor = '#4CAF50';
    updateButton.style.color = 'white';
    updateButton.style.border = 'none';
    updateButton.style.borderRadius = '6px';
    updateButton.style.cursor = 'pointer';
    updateButton.style.marginRight = '10px';
    updateButton.style.fontWeight = '500';
    updateButton.style.fontSize = '18px';
    updateButton.style.height = '40px';
    const statusIndicator = document.createElement('span');
    statusIndicator.id = 'lagrangeUpdateStatus';
    statusIndicator.style.marginLeft = '10px';
    statusIndicator.style.display = 'none';
    buttonContainer.appendChild(updateButton);
    buttonContainer.appendChild(statusIndicator);
    siteHeader.appendChild(buttonContainer);
    updateButton.onclick = () => {
        const selectedSite = document.getElementById('siteSelector').value;
        if (!selectedSite) {
            alert('Please select a site first');
            return;
        }
        const confirmUpdate = confirm(`Do you wish to send plan to ${selectedSite} and update Lagrange?`);
        if (confirmUpdate) {
            updateButton.disabled = true;
            updateButton.style.backgroundColor = '#cccccc';
            showStatus('Updating Lagrange...', 'blue');

            // Get current date/time in DTG format
            const now = new Date();
            const dtg = formatDTG(now); // You'll need to implement this function

            // Send Slack notification
            sendSlackNotification(selectedSite, dtg);

            updateLagrangeFromPlanSummary(updateButton, statusIndicator);
        }
    };
}

// Helper function to format date as DTG (Date Time Group)
function formatDTG(date) {
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getUTCHours()).padStart(2, '0');
    const minutes = String(date.getUTCMinutes()).padStart(2, '0');
    const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                    'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
    const month = months[date.getUTCMonth()];
    const year = date.getUTCFullYear();

    return `${day}${hours}${minutes}Z ${month} ${year}`;
}

// Function to send Slack notification
function sendSlackNotification(site, dtg) {
    const message = `SSD has initiated a UFO Plan for ${site} at ${dtg}`;
    const slackWebhookUrl = 'https://hooks.slack.com/triggers/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';

    GM_xmlhttpRequest({
        method: 'POST',
        url: slackWebhookUrl,
        headers: {
            'Content-Type': 'application/json'
        },
        data: JSON.stringify({
            text: message
        }),
        onload: function(response) {
            if (response.status >= 200 && response.status < 300) {
                console.log('Slack notification sent successfully');
            } else {
                console.error('Failed to send Slack notification:', response.statusText);
            }
        },
        onerror: function(error) {
            console.error('Error sending Slack notification:', error);
        }
    });
}

function showStatus(message, color) {
    const statusIndicator = document.getElementById('lagrangeUpdateStatus');
    if (statusIndicator) {
        statusIndicator.textContent = message;
        statusIndicator.style.color = color;
        statusIndicator.style.display = 'inline';
    }
}

function getLG(siteName) {
    let url = 'https://throughput-iad.iad.proxy.amazon.com/' + siteName + '/granular/';

    return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
            method: 'GET',
            url: url,
            headers: { "Content-Type": "application/json" },
            onload: function(response) {
                let parser = new DOMParser();
                let doc = parser.parseFromString(response.responseText, 'text/html');

                let text = doc.children[0].innerText.split("modelAndView = ")[1]
                .split(';')[0]
                .replaceAll('\n', '')
                .replaceAll('"', 'tempReplacement')
                .replaceAll("'", '"')
                .replaceAll('tempReplacement', "'");

                let data = JSON.parse(text);

                let lgWindowData = data.LocalTimeSchedule.replaceAll('[', '').replaceAll("]", '').replaceAll(", ", ',').split(',');
                let lgData = JSON.parse(data.DataByMainProcess.replaceAll('"', 'tempReplacement').replaceAll("'", '"').replaceAll('tempReplacement', "'"));
                let lgBlocks = lgData.OUTBOUND.defaultThroughputs.throughputByShiftDivision;
                let overrides = lgData.OUTBOUND.throughputOverrides.throughputByShiftDivision;

                let blocksSorted = [];
                for(let block in lgBlocks) {
                    if(overrides[block] !== undefined) blocksSorted.push([block, overrides[block]]);
                    else blocksSorted.push([block, lgBlocks[block]]);
                }
                blocksSorted = blocksSorted.sort();

                resolve({ windowData: lgWindowData, fullData: lgData, sortedBlocks: blocksSorted });
            }
        });
    });
}
function resetButton(button, statusIndicator) {
    button.textContent = 'Send Plan and Update Granular';
    button.style.backgroundColor = '#4CAF50';
    button.style.color = 'white';
    button.disabled = false;
    button.style.cursor = 'pointer';
    if (statusIndicator) {
        statusIndicator.style.display = 'none';
    }
}
function updateLagrangeFromPlanSummary(button, statusIndicator) {
    const selectedSite = document.getElementById('siteSelector').value;
    if (!selectedSite) {
        alert('Please select a site first');
        return;
    }

    try {
        // Extract from all 6 planSummary containers (Current CPT through CPT+5)
        let allPlanSummaries = [];

        for (let i = 1; i <= 6; i++) {
            const containerId = `planSummary${i}Container`;
            const container = document.getElementById(containerId);

            if (container) {
                const containerData = extractTableData(containerId);
                if (containerData && containerData.length > 0) {
                    console.log(`Container ${i} found ${containerData.length} windows`);
                    allPlanSummaries.push(...containerData);
                } else {
                    console.log(`Container ${i} exists but has no data`);
                }
            } else {
                console.log(`Container ${i} not found`);
            }
        }

        console.log(`Total windows collected from all containers: ${allPlanSummaries.length}`);

        const siteTimeZoneCode = siteTimeZones[selectedSite];
        const siteTimezone = timeZones[siteTimeZoneCode];

        // Get site's current time and UTC hours
        const siteDateTime = getSiteDateTime(selectedSite, siteTimezone);
        const currentUTCHours = siteDateTime.getUTCHours();

        let overrideData = {
            outboundPPG: { "PC_PickToRebin": {}, "PC_Single": {} },
            trans: '{}',
            transPPG: '{"TransDefault":{}}',
            other: '{}',
            otherPPG: '{"OtherDefault":{}}',
            originalOutboundOverrides: "{}",
            originalOutboundPPGOverrides: "{\"PC_PickToRebin\":{},\"PC_Single\":{}}",
            warehouseId: selectedSite,
            reasonCode: "noSelect"
        };

        let previousWindowEnd = null;
        let isFirstWindow = true;

        allPlanSummaries.forEach((window, index) => {
            if (!window.window || window.multis === undefined || window.singles === undefined) {
                console.warn(`Skipping window ${index + 1} - Missing required data`, window);
                return;
            }

            const [startTime, endTime] = window.window.split(' to ').map(t => t.trim());

            const startUTC = convertToUTC(startTime, siteTimezone, false, previousWindowEnd, siteDateTime, isFirstWindow);
            const endUTC = convertToUTC(endTime, siteTimezone, true, startUTC, siteDateTime, isFirstWindow);

            const timeWindow = `${startUTC.toISOString()}/${endUTC.toISOString()}`;
            const duration = (endUTC - startUTC) / (1000 * 60);

            // Skip windows with invalid duration (negative or zero)
            if (duration <= 0) {
                console.warn(`‚ö†Ô∏è SKIPPING window ${index + 1} - Invalid duration: ${duration} minutes`, {
                    startTime,
                    endTime,
                    startUTC: startUTC.toISOString(),
                    endUTC: endUTC.toISOString(),
                    timeWindow
                });
                return;
            }

            console.log(`‚úì Window ${index + 1} processed:`, {
                startTime,
                endTime,
                timeWindow,
                duration,
                multis: window.multis,
                singles: window.singles,
                total: window.multis + window.singles
            });

            overrideData.outboundPPG.PC_PickToRebin[timeWindow] = window.multis * duration / 60;
            overrideData.outboundPPG.PC_Single[timeWindow] = window.singles * duration / 60;

            previousWindowEnd = endUTC;
            isFirstWindow = false;
        });

        overrideData.outboundPPG = JSON.stringify(overrideData.outboundPPG);
        const finalData = JSON.stringify(overrideData);

        console.log('Final request data:', finalData);
        console.log('PC_PickToRebin data:', JSON.parse(overrideData.outboundPPG).PC_PickToRebin);
        console.log('PC_Single data:', JSON.parse(overrideData.outboundPPG).PC_Single);

        // Function to get current values from the page
        function getCurrentPageValues() {
            const currentValues = {
                PC_PickToRebin: {},
                PC_Single: {}
            };

            // Find all override input fields for PC_PickToRebin
            const pickToRebinInputs = document.querySelectorAll('input[id^="PC_PickToRebinthroughputOverrides"]');
            console.log(`Found ${pickToRebinInputs.length} PC_PickToRebin input fields`);
            pickToRebinInputs.forEach(input => {
                const value = parseFloat(input.value) || 0;
                currentValues.PC_PickToRebin[input.id] = value;
                console.log(`  ${input.id} = ${value}`);
            });

            // Find all override input fields for PC_Single
            const singleInputs = document.querySelectorAll('input[id^="PC_SinglethroughputOverrides"]');
            console.log(`Found ${singleInputs.length} PC_Single input fields`);
            singleInputs.forEach(input => {
                const value = parseFloat(input.value) || 0;
                currentValues.PC_Single[input.id] = value;
                console.log(`  ${input.id} = ${value}`);
            });

            return currentValues;
        }

        // Get values before update
        const beforeValues = getCurrentPageValues();
        console.log('Values BEFORE update:', beforeValues);

        GM_xmlhttpRequest({
            method: 'POST',
            url: `https://throughput-iad.iad.proxy.amazon.com/save/granular/${selectedSite}`,
            headers: { "Content-Type": "application/json;charset=UTF-8"},
            data: finalData,
            onload: function(response) {
                console.log('Response status:', response.status);
                console.log('Response text:', response.responseText);

                // Wait a moment for the page to update, then check values
                setTimeout(() => {
                    const afterValues = getCurrentPageValues();
                    console.log('Values AFTER update:', afterValues);

                    // Check if values actually changed
                    let changesDetected = false;
                    let changesSummary = {
                        PC_PickToRebin: [],
                        PC_Single: []
                    };

                    // Check PC_PickToRebin changes
                    Object.keys(afterValues.PC_PickToRebin).forEach(fieldId => {
                        const before = beforeValues.PC_PickToRebin[fieldId] || 0;
                        const after = afterValues.PC_PickToRebin[fieldId] || 0;
                        if (Math.abs(before - after) > 0.01) {
                            changesDetected = true;
                            changesSummary.PC_PickToRebin.push({
                                field: fieldId,
                                before: before,
                                after: after,
                                change: after - before
                            });
                        }
                    });

                    // Check PC_Single changes
                    Object.keys(afterValues.PC_Single).forEach(fieldId => {
                        const before = beforeValues.PC_Single[fieldId] || 0;
                        const after = afterValues.PC_Single[fieldId] || 0;
                        if (Math.abs(before - after) > 0.01) {
                            changesDetected = true;
                            changesSummary.PC_Single.push({
                                field: fieldId,
                                before: before,
                                after: after,
                                change: after - before
                            });
                        }
                    });

                    console.log('Changes detected:', changesDetected);
                    console.log('Changes summary:', changesSummary);

                    if (changesDetected) {
                        button.textContent = "Update Successful!";
                        button.style.backgroundColor = '#4CAF50';
                        showStatus(`Updated! PC_PickToRebin: ${changesSummary.PC_PickToRebin.length} fields, PC_Single: ${changesSummary.PC_Single.length} fields`, 'green');

                        try {
                            sendWebhookData();
                            console.log('Webhook data sent after Lagrange update');
                        } catch (error) {
                            console.error('Error sending webhook data:', error);
                            showStatus('Lagrange updated but webhook send failed', 'orange');
                        }
                    } else {
                        console.error('No changes detected on page after update');
                        console.error('Response status:', response.status);
                        console.error('Expected values to send:', {
                            PC_PickToRebin: JSON.parse(overrideData.outboundPPG).PC_PickToRebin,
                            PC_Single: JSON.parse(overrideData.outboundPPG).PC_Single
                        });
                        button.textContent = "Update Failed - No Changes";
                        button.style.backgroundColor = '#f44336';
                        showStatus('No changes detected on page', 'red');
                    }

                    setTimeout(() => resetButton(button), 10000);
                }, 2000); // Wait 2 seconds for page to update
            },
            onerror: function(error) {
                console.error('Request error:', error);
                button.textContent = "Update Failed";
                button.style.backgroundColor = '#f44336';
                showStatus('Request error', 'red');
                setTimeout(() => resetButton(button), 10000);
            }
        });

    } catch (error) {
        console.error('Process error:', error);
        button.textContent = "Update Failed";
        button.style.backgroundColor = '#f44336';
        showStatus('Process error', 'red');
        setTimeout(() => resetButton(button), 10000);
    }
}

function getSiteDateTime(selectedSite, siteTimezone) {
    // Convert current time to site's timezone then to UTC
    const siteNowUTC = new Date(new Date().toLocaleString("en-US", { timeZone: siteTimezone }));
    console.log('Site DateTime:', siteNowUTC);
    return siteNowUTC;
}

function getCurrentSiteDate(timezone) {
    // Get current site date in site's timezone
    const siteTime = new Date(new Date().toLocaleString("en-US", { timeZone: timezone }));
    console.log('Site current date:', siteTime);
    return siteTime;
}
function convertToUTC(timeStr, siteTimezone, isEndTime, previousTime, siteDateTime, isFirstWindow) {
    try {
        // 1. Convert AM/PM to 24-hour format
        const [rawHours, minutes] = timeStr.replace(/\s?(?:AM|PM)/, '').split(':').map(Number);
        const hours = timeStr.includes('PM') ?
            (rawHours === 12 ? 12 : rawHours + 12) :
            (rawHours === 12 ? 0 : rawHours);

        // Get UTC offset
        let utcOffset;
        switch(siteTimezone) {
            case "America/New_York":
            case "US/Eastern":
                utcOffset = 5;
                break;
            case "America/Chicago":
            case "US/Central":
                utcOffset = 6;
                break;
            case "America/Denver":
            case "US/Mountain":
                utcOffset = 7;
                break;
            case "America/Phoenix":
            case "US/Arizona":
                utcOffset = 7;
                break;
            case "America/Los_Angeles":
            case "US/Pacific":
                utcOffset = 8;
                break;
            default:
                utcOffset = 7;
        }

        // DST adjustment
        const dstStart = new Date("2025-03-09T02:00:00");
        const dstEnd = new Date("2025-11-02T02:00:00");
        if (siteDateTime >= dstStart && siteDateTime < dstEnd &&
            siteTimezone !== "America/Phoenix" &&
            siteTimezone !== "US/Arizona") {
            utcOffset -= 1;
        }

        // 2. Calculate UTC hours without affecting date
        let utcHours = hours + utcOffset;
        if (utcHours >= 24) {
            utcHours -= 24;
        }

        // 3. Create UTC date with the base site date
        let utcDate = new Date(Date.UTC(
            siteDateTime.getUTCFullYear(),
            siteDateTime.getUTCMonth(),
            siteDateTime.getUTCDate(),
            utcHours,
            minutes,
            0,
            0
        ));

        // 4. Only now apply our date adjustment rules
        if (isFirstWindow) {
            const utcHours = utcDate.getUTCHours();
            if ((!isEndTime && utcHours >= 20) || (isEndTime && utcHours <= 4)) {
                if (!isEndTime) {
                    utcDate.setUTCDate(utcDate.getUTCDate() - 1);
                }
            }
        } else if (previousTime && utcDate < previousTime) {
            utcDate.setUTCDate(utcDate.getUTCDate() + 1);
        }

        console.log('Converted time:', {
            original: timeStr,
            localHours: hours,
            utcHours: utcDate.getUTCHours(),
            utcOffset,
            result: utcDate.toISOString()
        });

        return utcDate;

    } catch (error) {
        console.error('Time conversion error:', error);
        throw error;
    }
}

function getTimezoneOffset(timezone) {
    const offsets = {
        "America/New_York": -5 * 60,  // EST = UTC-5
        "US/Eastern": -5 * 60,
        "America/Chicago": -6 * 60,   // CST = UTC-6
        "US/Central": -6 * 60,
        "America/Denver": -7 * 60,    // MST = UTC-7
        "US/Mountain": -7 * 60,
        "America/Phoenix": -7 * 60,   // MST no DST
        "US/Arizona": -7 * 60,
        "America/Los_Angeles": -8 * 60, // PST = UTC-8
        "US/Pacific": -8 * 60
    };

    let offset = offsets[timezone] || -7 * 60; // Default to AZ time if not found

    // Apply DST adjustment except for Arizona
    const dstStart = new Date("2024-03-10T02:00:00");
    const dstEnd = new Date("2024-11-03T02:00:00");
    const today = new Date();

    if (today >= dstStart && today < dstEnd &&
        timezone !== "America/Phoenix" &&
        timezone !== "US/Arizona") {
        offset += 60; // Add 1 hour during DST
    }

    return offset;
}

function formatWindowWithDate(window, currentDate, previousEndTime) {
    console.log('Formatting window:', window);
    try {
        const [startTimeStr, endTimeStr] = window.window.split(' to ');
        const startDate = currentDate.toISOString().split('T')[0]; // Get just the date part

        // Keep the original times and just add the date
        const formattedStart = `${startDate}T${startTimeStr}:00.000Z`;
        const formattedEnd = `${startDate}T${endTimeStr}:00.000Z`;

        // If end time is before start time, it's next day
        if (endTimeStr < startTimeStr) {
            const nextDate = new Date(currentDate);
            nextDate.setDate(nextDate.getDate() + 1);
            const tomorrowDate = nextDate.toISOString().split('T')[0];
            formattedEnd = `${tomorrowDate}T${endTimeStr}:00.000Z`;
        }

        const timeWindow = `${formattedStart}/${formattedEnd}`;

        return {
            timeWindow,
            values: {
                multisValue: window.multis,
                singlesValue: window.singles,
                totalValue: window.multis + window.singles
            }
        };
    } catch (error) {
        console.error('Error formatting window with date:', error);
        console.error('Window data that caused error:', window);
        return null;
    }
}
function processWindowsWithDates(windows, throughputByShiftDivision, throughputByPPG, siteNow, selectedSite) {
    console.log('Processing windows with dates');
    let baseDate = new Date(siteNow);

    // Check if site date is different from AZ date
    const siteTime = new Date(baseDate.toLocaleString("en-US", { timeZone: timeZones[siteTimeZones[selectedSite]] }));
    const needsDateRollover = siteTime.getDate() !== baseDate.getDate();

    // Get the base date string
    let dateStr = baseDate.toISOString().split('T')[0];
    // If we need to roll over, get next day's date string
    let nextDateStr = needsDateRollover ?
        new Date(baseDate.setDate(baseDate.getDate() + 1)).toISOString().split('T')[0] :
        dateStr;

    windows.forEach((window, index) => {
        console.log(`Processing window ${index}:`, window);
        const [startTime, endTime] = window.window.split(' to ');

        // Use the rolled over date if needed
        let timeWindow = `${nextDateStr}T${startTime.trim()}:00.000Z/${nextDateStr}T${endTime.trim()}:00.000Z`;

        console.log('Final timeWindow:', timeWindow);

        throughputByPPG.Multis[timeWindow] = window.multis;
        throughputByPPG.Singles[timeWindow] = window.singles;
        throughputByShiftDivision[timeWindow] = window.multis + window.singles;

        console.log(`Window ${index} processed:`, {
            timeWindow,
            multis: window.multis,
            singles: window.singles,
            total: window.multis + window.singles
        });
    });
}


function extractTableData(containerId) {
    const container = document.getElementById(containerId);
    if (!container) {
        console.error(`Container ${containerId} not found`);
        return [];
    }

    const rows = container.querySelectorAll('table tr');
    const windows = [];

    rows.forEach((row, index) => {
        const cells = row.cells;
        if (cells && cells.length >= 5) {
            const timeWindow = cells[0].textContent;
            if (timeWindow && timeWindow.includes('to') && !timeWindow.includes('OB Planned Volume')) {
                const windowData = {
                    window: timeWindow,
                    // Set minimum value of 0.2 for multis and singles
                    multis: Math.max(0.2, parseFloat(cells[1].textContent) || 0.2),
                    singles: Math.max(0.2, parseFloat(cells[2].textContent) || 0.2)
                };
                console.log(`Extracted window data:`, windowData);
                windows.push(windowData);
            }
        }
    });

    return windows;
}

function compareData(original, updated) {
    try {
        const originalOutbound = original.OUTBOUND.throughputOverrides;
        const updatedOutbound = updated.OUTBOUND.throughputOverrides;
        return JSON.stringify(originalOutbound) === JSON.stringify(updatedOutbound);
    } catch (error) {
        console.error('Error comparing data:', error);
        return false;
    }
}

// Add the button when a site is selected
document.getElementById('siteSelector').addEventListener('change', function() {
    createAndUpdateNextNextCPTMathTable();
    addLagrangeUpdateButton();
});


function sendWebhookData() {
    // Get the selected site
   const selectedSite = document.getElementById('siteSelector').value;
    let slackUrl;
    switch(selectedSite) {
        case 'SAH1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SAX1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SAX2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SAX3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SAX5':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SAX6':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SAX7':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SAZ1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SAZ2':
            slackUrl = 'https://hooks.slack.com/triggers/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'; //https://hooks.slack.com/triggers/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
            break;
        case 'SAZ3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SBW1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SCA2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SCA3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SCA4':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SCA5':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SCA7':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SCO1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SCO2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SDC1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SFL1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SFL2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SFL3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SFL4':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SFL6':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SFL7':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SFL8':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SGA1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SGA2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SIA2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SID1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SIL1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SIL2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SIL3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SIL4':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SIN9':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SKY2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SMA1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SMA2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SMD1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SMI1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SMN1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SMO1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SMO2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNC2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNC3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNC6':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNE1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNJ2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNJ3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNJ1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNL1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNV1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNY1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNY2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SNY5':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SOH1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SOH2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SOH3':
            slackUrl = 'https://hooks.slack.com/triggers/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'; //https://hooks.slack.com/triggers/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
            break;
        case 'SOK1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SOR3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SPA1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SSC3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SSC4':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STN1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STW1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STX2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STX3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STX4':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STX5':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STX6':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STX7':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STX8':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'STX9':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SUT1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SUT2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SVA2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SWA1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SWA2':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SWI1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SYS3':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        case 'SSY1':
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
        default:
            slackUrl = 'https://hooks.slack.com/triggers/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';
            break;
    }

    const planSummary1Container = document.getElementById('planSummary1Container');
    let shiftPlan = "1";
    let shiftPlan2 = "1";
    let shiftPlan2FromPS2 = false;

    const currentCPTInfoBox = document.getElementById('currentCPTInfoBox');
    let cpt = "1";
    let four = "1";
    let Cap = "1";
    let one = "1";
    let two = "1";
    let three = "1";

if (planSummary1Container) {
    const table = planSummary1Container.querySelector('table');
    if (table) {
        const lastRow = table.rows[table.rows.length - 1];
        if (lastRow) {
            const riskCell = lastRow.cells[1]; // Second cell
            if (riskCell) {
                // Changed regex to handle "Risk %: XX.XX%"
                const riskMatch = riskCell.textContent.match(/Risk %: ([\d.]+)%/);
                if (riskMatch) {
                    const riskValue = parseFloat(riskMatch[1]);
                    // Add alert emoji if risk is over 90%
                    three = riskValue > 90 ? `:alert: ${riskValue}% :alert:` : `${riskValue}%`;
                }
            }
        }
    }
}

    if (currentCPTInfoBox) {
        const timeMatch = currentCPTInfoBox.textContent.match(/Current CPT: (\d{2}:\d{2})/);
        if (timeMatch) {
            cpt = timeMatch[1];

            const coraTable = document.querySelector('.CORA-table');
            if (coraTable) {
                const rows = coraTable.rows;
                for (let i = 0; i < rows.length; i++) {
                    if (rows[i].cells[0].textContent.trim() === cpt) {
                        two = rows[i].cells[3].textContent.trim();
                        break;
                    }
                }
            }
        }

        // New way to extract Cap, % Schedule, and Current Backlog
        const capSpan = currentCPTInfoBox.querySelector('span[style*="color: #4CAF50"]');
        if (capSpan) {
            const capText = capSpan.nextElementSibling?.textContent;
            four = capText ? capText.replace(/[^\d]/g, '') : "1";
        }

        const scheduleSpan = currentCPTInfoBox.querySelector('span[style*="color: #2196F3"]');
        if (scheduleSpan) {
            const scheduleText = scheduleSpan.nextElementSibling?.textContent;
            Cap = scheduleText || "1";
        }

        const backlogSpan = currentCPTInfoBox.querySelector('span[style*="color: #9C27B0"]');
        if (backlogSpan) {
            const backlogText = backlogSpan.nextElementSibling?.textContent;
            one = backlogText ? parseFloat(backlogText.replace(/[^\d.]/g, '')).toFixed(2) : "1";
        }
    }

    if (planSummary1Container) {
        const table = planSummary1Container.querySelector('table');
        if (table) {
            const windowRows = Array.from(table.rows).filter(row =>
                row.cells[0] && row.cells[0].textContent.includes(" to ")
            );

            if (windowRows[0]) {
                shiftPlan = windowRows[0].cells[0].textContent.trim();

                if (windowRows[1]) {
                    shiftPlan2 = windowRows[1].cells[0].textContent.trim();
                } else {
                    const planSummary2Container = document.getElementById('planSummary2Container');
                    if (planSummary2Container) {
                        const table2 = planSummary2Container.querySelector('table');
                        const windowRows2 = Array.from(table2.rows).filter(row =>
                            row.cells[0] && row.cells[0].textContent.includes(" to ")
                        );
                        if (windowRows2[0]) {
                            shiftPlan2 = windowRows2[0].cells[0].textContent.trim();
                            shiftPlan2FromPS2 = true;
                        }
                    }
                }
            }
        }
    }

    const productionTable = document.getElementById('productionGraphic');
    let pickHC = "1";
    let packHC = "1";
    let pickRate = "1";
    let packRate = "1";
    let pickUPH = "1";
    let packUPH = "1";
    let pickHC2 = "1";
    let packHC2 = "1";
    let pickRate2 = "1";
    let packRate2 = "1";
    let pickUPH2 = "1";
    let packUPH2 = "1";

    if (productionTable) {
        const rows = productionTable.rows;
        for (let i = 0; i < rows.length; i++) {
            const firstCell = rows[i].cells[0];
            if (firstCell) {
                const rowName = firstCell.textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '');
                if (rowName === 'Pick2Rebin Pick') {
                    pickHC = rows[i].cells[1] ? rows[i].cells[1].textContent.trim() : "1";
                    if (rows[i+1] && rows[i+1].cells[1]) {
                        pickRate = rows[i+1].cells[1].textContent.trim();
                        pickUPH = (parseInt(pickHC) * parseInt(pickRate)).toString();
                    }
                }
                if (rowName === 'Pick2Rebin Pack') {
                    packHC = rows[i].cells[1] ? rows[i].cells[1].textContent.trim() : "1";
                    if (rows[i+1] && rows[i+1].cells[1]) {
                        packRate = rows[i+1].cells[1].textContent.trim();
                        packUPH = (parseInt(packHC) * parseInt(packRate)).toString();
                    }
                }
            }
        }
    }

    if (shiftPlan2FromPS2) {
        const nextCPTTable = document.getElementById('nextCPTProductionGraphicTable');
        if (nextCPTTable) {
            const nextCPTRows = nextCPTTable.rows;
            for (let i = 0; i < nextCPTRows.length; i++) {
                const firstCell = nextCPTRows[i].cells[0];
                if (firstCell) {
                    const rowName = firstCell.textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '');
                    if (rowName === 'Pick2Rebin Pick') {
                        pickHC2 = nextCPTRows[i].cells[1] ? nextCPTRows[i].cells[1].textContent.trim() : "1";
                        if (nextCPTRows[i+1] && nextCPTRows[i+1].cells[1]) {
                            pickRate2 = nextCPTRows[i+1].cells[1].textContent.trim();
                            pickUPH2 = (parseInt(pickHC2) * parseInt(pickRate2)).toString();
                        }
                    }
                    if (rowName === 'Pick2Rebin Pack') {
                        packHC2 = nextCPTRows[i].cells[1] ? nextCPTRows[i].cells[1].textContent.trim() : "1";
                        if (nextCPTRows[i+1] && nextCPTRows[i+1].cells[1]) {
                            packRate2 = nextCPTRows[i+1].cells[1].textContent.trim();
                            packUPH2 = (parseInt(packHC2) * parseInt(packRate2)).toString();
                        }
                    }
                }
            }
        }
    } else if (productionTable) {
        const rows = productionTable.rows;
        if (rows[0].cells.length > 2) {
            for (let i = 0; i < rows.length; i++) {
                const firstCell = rows[i].cells[0];
                if (firstCell) {
                    const rowName = firstCell.textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '');
                    if (rowName === 'Pick2Rebin Pick') {
                        pickHC2 = rows[i].cells[2] ? rows[i].cells[2].textContent.trim() : "1";
                        if (rows[i+1] && rows[i+1].cells[2]) {
                            pickRate2 = rows[i+1].cells[2].textContent.trim();
                            pickUPH2 = (parseInt(pickHC2) * parseInt(pickRate2)).toString();
                        }
                    }
                    if (rowName === 'Pick2Rebin Pack') {
                        packHC2 = rows[i].cells[2] ? rows[i].cells[2].textContent.trim() : "1";
                        if (rows[i+1] && rows[i+1].cells[2]) {
                            packRate2 = rows[i+1].cells[2].textContent.trim();
                            packUPH2 = (parseInt(packHC2) * parseInt(packRate2)).toString();
                        }
                    }
                }
            }
        }
    }
    const messageString = ` A new UFO plan is available. LG has been updated to match the UPH of the plan so please review the details below! :dancing_duck:

Shift - ${shiftPlan}
Path\t\t\t\t\t\tHC\t\tRate\tUPH
PPPickToRebin - P2R Pick\t\t${pickHC}\t\t${pickRate}\t\t${pickUPH}
PPPickToRebin - P2R Pack\t\t${packHC}\t\t${packRate}\t\t${packUPH}

Shift - ${shiftPlan2}
Path\t\t\t\t\t\tHC\t\tRate\tUPH
PPPickToRebin - P2R Pick\t\t${pickHC2}\t\t${pickRate2}\t\t${pickUPH2}
PPPickToRebin - P2R Pack\t\t${packHC2}\t\t${packRate2}\t\t${packUPH2}

CPT plan:  ${cpt}
Current Cap:                            \t\t\t${four}
Current Schedule:                  \t\t\t${Cap}
Current Schedule %:   \t\t\t\t\t${one}
Units Due [Backlog + Forecast]: \t\t\t${two}
Projected Risk with plan:               \t\t${three}`;

    const data = JSON.stringify({
        "FullPlan": messageString
    });

    GM_xmlhttpRequest({
        method: 'POST',
        url: slackUrl,
        headers: { "Content-Type": "application/json"},
        data: data,
        onerror: function(response) {
            alert("Message send failed.");
        },
        onload: function(response) {
            alert("Message sent!");
        }
    });
}

function updateRiskModelBasedOnTime() {
        if (userSelectedRiskModel) {
        return;
    }
    const selectedSite = document.getElementById('siteSelector').value;
    const currentCPT = document.getElementById('cptSelect').value;

    // Convert AZ time (MST) to site's local time
    const azTimeZone = 'America/Phoenix';
    const siteTimeZone = timeZones[siteTimeZones[selectedSite]];

    // Get current time in AZ
    const azTime = new Date().toLocaleString("en-US", { timeZone: azTimeZone });
    const azDate = new Date(azTime);
    const azHour = azDate.getHours();

    // Get time remaining until CPT
    const scheduleTable = document.querySelector('#SelectedCPTSchedule');
    let timeRemainingMinutes = 0;

    if (scheduleTable) {
        const timeRow = scheduleTable.rows[0];
        const lastCell = timeRow.cells[timeRow.cells.length - 1];
        if (lastCell) {
            const [, endTime] = lastCell.textContent.split(' to ');
            const endMinutes = convertToMinutesSinceMidnight(endTime);
            const currentMinutes = azDate.getHours() * 60 + azDate.getMinutes();
            timeRemainingMinutes = endMinutes - currentMinutes;
            if (timeRemainingMinutes < 0) timeRemainingMinutes += 1440; // Add 24 hours if negative
        }
    }

    // Determine risk model
    let newRiskModel;

    if (timeRemainingMinutes <= 80) { // 1 hour and 20 minutes
        newRiskModel = 'Low Backlog';
    } else if (azHour >= 6 && azHour < 18) { // 6 AM to 6 PM AZ time
        newRiskModel = 'MIXED';
    } else {
        newRiskModel = 'CORA';
    }

    // Simulate risk model selection and save
    setTimeout(() => {
        const riskModelSelect = document.getElementById('riskModel');
        if (riskModelSelect && riskModelSelect.value !== newRiskModel) {
            riskModelSelect.value = newRiskModel;
            localStorage.setItem('riskModel', newRiskModel);

            // Trigger save button click
            const saveButton = document.querySelector('#saveSettings');
            if (saveButton) {
                saveButton.click();
            }

            // Update recommendations
            updatePickRebinPackRecommendations();
            createAndUpdateMathTable();
        }
    }, 1000); // 1 second delay
}
// Ensure the risk model is checked when CPT changes
document.getElementById('cptSelect').addEventListener('change', () => {
    setTimeout(updateRiskModelBasedOnTime, 1000);
});

// Add check when site is changed
document.getElementById('siteSelector').addEventListener('change', () => {
    setTimeout(updateRiskModelBasedOnTime, 1000);
});
//SNY1 expections, for now going stick with the default rates only but adding stuff
document.getElementById('siteSelector').addEventListener('change', function() {
    userSelectedRiskModel = false;
    const selectedSite = this.value;
    const pickRateInput = document.getElementById('pickRate');
    const packRateInput = document.getElementById('packRate');
    const updateRatesButton = document.getElementById('updateRatesButton');

    if (selectedSite === 'SNY1') {
        pickRateInput.value = '250';
        packRateInput.value = '175';
    } else {
        // Reset to default values for all other sites
        pickRateInput.value = '300';
        packRateInput.value = '300';
    }

    // Trigger the update rates button click to apply the changes
    updateRatesButton.click();
});

// Adding the 3rd CPT, it will be gone and not visible for the user, so don't worry about it. YOu know who you are.
let nextNextCPTTableContainer = document.createElement('div');
nextNextCPTTableContainer.id = 'nextNextCPTTableContainer';
nextNextCPTTableContainer.style.position = 'fixed';
nextNextCPTTableContainer.style.top = '1800px';
nextNextCPTTableContainer.style.left = '54%';
nextNextCPTTableContainer.style.transform = 'translateX(-60%)';
nextNextCPTTableContainer.style.backgroundColor = 'white';
nextNextCPTTableContainer.style.border = '1px solid black';
nextNextCPTTableContainer.style.padding = '15px';
nextNextCPTTableContainer.style.zIndex = '10000';
nextNextCPTTableContainer.style.width = '45%';
nextNextCPTTableContainer.style.visibility = 'hidden';
document.body.appendChild(nextNextCPTTableContainer);

function getNextNextCPT(currentCPT) {
    const selectedSite = document.getElementById('siteSelector').value;

    // If site is in specialCPTs, use those times and add '20:20'
    // If not in specialCPTs, use default times without '20:20'
    const baseTimes = specialCPTs[selectedSite] || ['00:20', '06:20', '11:20', '14:20', '18:20'];
    const cptTimes = specialCPTs[selectedSite] ? [...baseTimes, '20:20'] : baseTimes;

    const currentIndex = cptTimes.indexOf(currentCPT);
    return cptTimes[(currentIndex + 2) % cptTimes.length];
}

function loadNextNextCPTScheduleColumn() {
    setTimeout(() => {
        const originalTable = document.querySelector('.SiteSchedule');
        let selectedSite = document.getElementById('siteSelector').value;
        let currentCPT = document.getElementById('cptSelect').value;
        let nextNextCPT = getNextNextCPT(currentCPT);

        if (!originalTable) {
            return;
        }

        let timeRow = originalTable.rows[0];
        let nextNextCPTColumnIndex = null;

        // Get the Next CPT schedule table
        let nextCPTTable = document.getElementById('NextCPTSchedule');

        if (nextCPTTable && nextCPTTable.rows[0].cells.length > 0) {
            // Get the last time window from Next CPT schedule
            let nextCPTLastWindow = nextCPTTable.rows[0].cells[nextCPTTable.rows[0].cells.length - 1].innerText;

            // Find this window in the original table and get the next index
            for (let i = 0; i < timeRow.cells.length; i++) {
                if (timeRow.cells[i].innerText === nextCPTLastWindow) {
                    nextNextCPTColumnIndex = (i + 1) % timeRow.cells.length;
                    break;
                }
            }
        }

        if (nextNextCPTColumnIndex !== null) {
            let filteredTable = document.createElement('table');
            filteredTable.classList.add('SiteSchedule');
            filteredTable.style.width = '100%';
            filteredTable.style.borderCollapse = 'collapse';
            filteredTable.id = 'NextNextCPTSchedule';
            filteredTable.classList.add('NextNextCPTSchedule');

            let headerRow = filteredTable.insertRow();
            let currentIndex = nextNextCPTColumnIndex;
            let nextNextCPTReached = false;

            while (true) {
                let cell = headerRow.insertCell();
                cell.innerHTML = timeRow.cells[currentIndex].innerHTML;
                cell.style.border = '1px solid black';
                cell.style.padding = '10px';
                cell.style.textAlign = 'center';
                cell.style.backgroundColor = '#e6f3ff';

                let cptTimeWindow = timeRow.cells[currentIndex].innerText;
                let [cptStartTime, cptEndTime] = cptTimeWindow.split(' to ');
                let cptStartMinutes = convertToMinutesSinceMidnight(cptStartTime);
                let cptEndMinutes = convertToMinutesSinceMidnight(cptEndTime);
                let nextNextCPTMinutes = convertToMinutesSinceMidnight(nextNextCPT);

                if (cptEndMinutes < cptStartMinutes) cptEndMinutes += 1440;

                if ((nextNextCPTMinutes === 20 || nextNextCPTMinutes === 95) && cptEndMinutes > 1440) {
                    cptStartMinutes -= 1440;
                    cptEndMinutes -= 1440;
                }

                if (cptStartMinutes <= nextNextCPTMinutes && nextNextCPTMinutes < cptEndMinutes) {
                    nextNextCPTReached = true;
                    break;
                }

                currentIndex++;
                if (currentIndex >= timeRow.cells.length) {
                    currentIndex = 0;
                }

                if (currentIndex === nextNextCPTColumnIndex) {
                    break;
                }
            }
            for (let rowIndex = 1; rowIndex < originalTable.rows.length; rowIndex++) {
                let row = originalTable.rows[rowIndex];
                let newRow = filteredTable.insertRow();
                currentIndex = nextNextCPTColumnIndex;
                nextNextCPTReached = false;

                while (true) {
                    let cell = newRow.insertCell();
                    let originalContent = row.cells[currentIndex].innerHTML;

                    if (rowIndex === 2) {
                        cell.textContent = originalContent.includes("Production") ? "Production" :
                                         originalContent.includes("Break") ? "Break" : "Downtime";
                        cell.style.cursor = 'pointer';
                        cell.addEventListener('click', function() {
                            toggleBlockType(this, this.textContent, false, true);
                        });
                    } else {
                        cell.innerHTML = originalContent;
                    }

                    cell.style.border = '1px solid black';
                    cell.style.padding = '5px';
                    cell.style.textAlign = 'center';

                    if (rowIndex === 2) {
                        if (cell.textContent === "Production") {
                            cell.style.backgroundColor = 'yellow';
                            cell.style.color = 'black';
                        } else if (cell.textContent === "Break") {
                            cell.style.backgroundColor = 'red';
                            cell.style.color = 'white';
                        } else {
                            cell.style.backgroundColor = 'gray';
                            cell.style.color = 'white';
                        }
                    }

                    let cptTimeWindow = timeRow.cells[currentIndex].innerText;
                    let [cptStartTime, cptEndTime] = cptTimeWindow.split(' to ');
                    let cptStartMinutes = convertToMinutesSinceMidnight(cptStartTime);
                    let cptEndMinutes = convertToMinutesSinceMidnight(cptEndTime);
                    let nextNextCPTMinutes = convertToMinutesSinceMidnight(nextNextCPT);

                    if (cptEndMinutes < cptStartMinutes) cptEndMinutes += 1440;

                    if ((nextNextCPTMinutes === 20 || nextNextCPTMinutes === 95) && cptEndMinutes > 1440) {
                        cptStartMinutes -= 1440;
                        cptEndMinutes -= 1440;
                    }

                    if (cptStartMinutes <= nextNextCPTMinutes && nextNextCPTMinutes < cptEndMinutes) {
                        nextNextCPTReached = true;
                        break;
                    }

                    currentIndex++;
                    if (currentIndex >= timeRow.cells.length) {
                        currentIndex = 0;
                    }

                    if (currentIndex === nextNextCPTColumnIndex) {
                        break;
                    }
                }
            }

            nextNextCPTTableContainer.innerHTML = '';
            let nextNextCPTSchedule = document.createElement('div');
            nextNextCPTSchedule.id = 'nextNextCPTSchedule';
            nextNextCPTSchedule.innerHTML = `<h3>CPT+2 Schedule (${nextNextCPT})</h3>`;
            nextNextCPTSchedule.appendChild(filteredTable);
            nextNextCPTTableContainer.appendChild(nextNextCPTSchedule);

            // Add production graphic container
            let productionGraphicContainer = document.createElement('div');
            productionGraphicContainer.id = 'nextNextCPTProductionGraphicContainer';
            nextNextCPTTableContainer.appendChild(productionGraphicContainer);

            // Create the production graphic after a small delay
            setTimeout(() => {
            createNextNextCPTProductionGraphic('nextNextCPTProductionGraphicContainer');
            }, 1000);

        } else {
            nextNextCPTTableContainer.innerHTML = '<p>No CPT+2 schedule available</p>';
        }
    }, 2000);
}

function createNextNextCPTProductionGraphic(containerId) {
    const container = document.getElementById(containerId);
    if (!container) {
        return;
    }

    // Clear the container
    container.innerHTML = '';

    const table = document.createElement('table');
    table.id = 'nextNextCPTProductionGraphicTable';
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    table.style.marginTop = '20px';
    table.style.marginBottom = '20px';

    const pickRate = document.getElementById('pickRate').value;
    const packRate = document.getElementById('packRate').value;

    // Header row
    const headerRow = table.insertRow();
    headerRow.insertCell().textContent = 'Recommendation';
    headerRow.cells[0].style.fontWeight = 'bold';
    headerRow.cells[0].style.backgroundColor = '#f0f0f0';
    headerRow.cells[0].style.padding = '5px';
    headerRow.cells[0].style.border = '1px solid #ddd';

    const scheduleTable = document.querySelector('#NextNextCPTSchedule');
    const productionWindows = getProductionWindows(scheduleTable);

    // Add production windows to header
    productionWindows.forEach(window => {
        const cell = headerRow.insertCell();
        cell.textContent = window.timeWindow;
        cell.style.fontWeight = 'bold';
        cell.style.backgroundColor = '#f0f0f0';
        cell.style.padding = '5px';
        cell.style.border = '1px solid #ddd';
    });

    // Rows
    const rows = [
        { name: 'Pick2Rebin Pick', defaultValue: 'X', isToggleable: true, defaultRate: pickRate },
        { name: 'Pick2Rebin Pack', defaultValue: 'X', isToggleable: true, defaultRate: packRate },
        { name: 'VNA Pick', defaultValue: 'X', isToggleable: true, defaultRate: 100 },
        { name: 'VNA Pack', defaultValue: 'X', isToggleable: true, defaultRate: 100 },
        { name: 'Outbound Problem Solve', defaultValue: 1, isToggleable: false }
    ];

    rows.forEach(row => addCustomRow(table, row.name, productionWindows, row.defaultValue, row.isToggleable, row.defaultRate));

    addOutboundTotalsRow(table);

    container.appendChild(table);

    updateOutboundTotals(table);

    // Update the next next CPT production table
    updateNextNextCPTProductionTable();
}
function updateNextNextCPTProductionTable() {
    const nextNextCPTScheduleTable = document.querySelector('#NextNextCPTSchedule');
    const nextNextProductionTable = document.getElementById('nextNextCPTProductionGraphicTable');

    if (!nextNextCPTScheduleTable || !nextNextProductionTable) {
        return;
    }

    const productionWindows = getProductionWindows(nextNextCPTScheduleTable);

    if (productionWindows.length === 0) {
        return;
    }

    // Get the CPT+2 time
    const currentCPT = document.getElementById('cptSelect').value;
    const nextNextCPT = getNextNextCPT(currentCPT);

    // Set VNA Pick and Pack to 1
    const vnaPickRow = Array.from(nextNextProductionTable.rows)
        .find(row => row.cells[0].textContent.trim().includes('VNA Pick'));
    const vnaPackRow = Array.from(nextNextProductionTable.rows)
        .find(row => row.cells[0].textContent.trim().includes('VNA Pack'));

    if (vnaPickRow && vnaPackRow) {
        for (let i = 1; i < vnaPickRow.cells.length; i++) {
            vnaPickRow.cells[i].textContent = '1';
            vnaPackRow.cells[i].textContent = '1';
        }
    }

    getNextNextCPTPickRebinPackRow(nextNextProductionTable)
        .then(pickRebinPackRow => {
            const expectedRates = getExpectedRates(nextNextProductionTable, pickRebinPackRow, productionWindows);

            // Get the MIXED Set 4 value from the math table
            const mathTable = document.querySelector('#nextNextCPTMathTableContainer table');
            let mixedSet4Value = 0;

            if (mathTable) {
                const mixedRow = Array.from(mathTable.rows).find(row => row.cells[0].textContent === 'MIXED');
                if (mixedRow && mixedRow.cells[4]) {
                    mixedSet4Value = parseInt(mixedRow.cells[4].textContent) || 0;
                }
            }

            const recommendations = calculateHCRecommendations(mixedSet4Value, productionWindows, expectedRates, {}, nextNextCPT);

            updateNextNextCPTPickRebinPackRow(pickRebinPackRow, recommendations);

            // Add manual override listeners
            addNextNextCPTManualOverrideListeners(pickRebinPackRow);

            // Update Pick HC after Pack HC is set
            updateNextNextCPTPickHCBasedOnPackHC(nextNextProductionTable);

            updateOutboundTotals(nextNextProductionTable);
            updateNextNextCPTProductionGraphic();
            updatePlanSummary3();
        })
        .catch(error => {
            console.error("Error in updateNextNextCPTProductionTable:", error);
        });

}


function getNextNextCPTPickRebinPackRow(nextNextProductionTable, retries = 5) {
    return new Promise((resolve, reject) => {
        function findRow() {
            for (let i = 0; i < nextNextProductionTable.rows.length; i++) {
                const row = nextNextProductionTable.rows[i];
                const firstCellContent = row.cells[0].textContent.trim();

                if (firstCellContent.includes('Pick2Rebin Pack')) {
                    resolve(row);
                    return;
                }
            }

            if (retries > 0) {
                setTimeout(() => {
                    retries--;
                    findRow();
                }, 1000);
            } else {
                reject('Row not found');
            }
        }

        findRow();
    });
}

function updateNextNextCPTPickRebinPackRow(pickRebinPackRow, recommendations, userOverrides = {}) {
    const maxWalls = getMaxWalls();

    for (let i = 0; i < recommendations.length; i++) {
        const cell = pickRebinPackRow.cells[i + 1];

        if (i in userOverrides) {
            cell.textContent = Math.min(userOverrides[i], maxWalls);
            cell.style.backgroundColor = 'pink';
            cell.dataset.userOverride = 'true';
        } else {
            const recommendedHC = Math.min(recommendations[i], maxWalls);
            cell.textContent = recommendedHC;
            cell.style.backgroundColor = '';
            cell.dataset.userOverride = 'false';
        }

        cell.dataset.recommended = Math.min(recommendations[i], maxWalls);
    }
}

function updateNextNextCPTPickHCBasedOnPackHC(nextNextProductionTable) {
    const packRow = nextNextProductionTable.querySelector('tr:nth-child(5)');
    const pickRow = nextNextProductionTable.querySelector('tr:nth-child(3)');
    const packRateRow = packRow?.nextElementSibling;
    const pickRateRow = pickRow?.nextElementSibling;

    if (!packRow || !pickRow || !packRateRow || !pickRateRow) {
        return;
    }

    for (let i = 1; i < packRow.cells.length; i++) {
        const packHC = parseInt(packRow.cells[i].textContent);
        const packRate = parseFloat(packRateRow.cells[i].textContent);
        const pickRate = parseFloat(pickRateRow.cells[i].textContent);

        if (!isNaN(packHC) && !isNaN(packRate) && !isNaN(pickRate) && pickRate > 0) {
            const newPickHC = Math.ceil((packHC * packRate) / pickRate);
            if (!pickRow.cells[i].dataset.userOverride) {
                pickRow.cells[i].textContent = newPickHC;
                pickRow.cells[i].style.backgroundColor = '';
            }
        }
    }

    updateOutboundTotals(nextNextProductionTable);
}
function createAndUpdateNextNextCPTMathTable() {
    let nextNextCPTMathTableContainer = document.getElementById('nextNextCPTMathTableContainer');
    if (!nextNextCPTMathTableContainer) {
        nextNextCPTMathTableContainer = document.createElement('div');
        nextNextCPTMathTableContainer.id = 'nextNextCPTMathTableContainer';
        nextNextCPTMathTableContainer.style.position = 'fixed';
        nextNextCPTMathTableContainer.style.right = '10px';
        nextNextCPTMathTableContainer.style.top = '800px';
        nextNextCPTMathTableContainer.style.width = '300px';
        nextNextCPTMathTableContainer.style.backgroundColor = 'white';
        nextNextCPTMathTableContainer.style.border = '1px solid black';
        nextNextCPTMathTableContainer.style.padding = '10px';
        nextNextCPTMathTableContainer.style.zIndex = '10000';
        nextNextCPTMathTableContainer.style.display = 'none'; // Hide the original container
        document.body.appendChild(nextNextCPTMathTableContainer);
    }

    let mathTable = document.createElement('table');
    mathTable.style.width = '100%';
    mathTable.style.borderCollapse = 'collapse';

    let header = mathTable.createTHead();
    let headerRow = header.insertRow();
    ['Type', 'Set 1', 'Set 2', 'Set 3', 'Set 4'].forEach(text => {
        let th = document.createElement('th');
        th.textContent = text;
        th.style.border = '1px solid black';
        th.style.padding = '5px';
        headerRow.appendChild(th);
    });

    let body = mathTable.createTBody();
    ['CORA', 'ATROPS', 'MIXED', 'Low Backlog'].forEach(rowName => {
        let row = body.insertRow();
        let cell = row.insertCell();
        cell.textContent = rowName;
        cell.style.border = '1px solid black';
        cell.style.padding = '5px';

        for (let i = 0; i < 4; i++) {
            let cell = row.insertCell();
            cell.style.border = '1px solid black';
            cell.style.padding = '5px';
        }
    });

    nextNextCPTMathTableContainer.innerHTML = '';
    nextNextCPTMathTableContainer.appendChild(mathTable);

    updateNextNextCPTMathTableCalculations();
}

function updateNextNextCPTMathTableCalculations() {
    const mathTable = document.querySelector('#nextNextCPTMathTableContainer table');
    if (!mathTable) {
        return;
    }

    let currentCPT = document.getElementById('cptSelect').value;
    let nextNextCPT = getNextNextCPT(currentCPT);

    let allCoraData = getCORAData();
    let atropsData = getATROPSData(nextNextCPT);

    const multiplier = 1.3; // Fixed at 1.3 for CPT+2

    if (allCoraData && allCoraData[nextNextCPT]) {
        let columnE = allCoraData[nextNextCPT].columnE;
        let currentBacklog = allCoraData[nextNextCPT].currentBacklog;

        // CORA Set 1
        let coraSet1Value = columnE - currentBacklog;
        let coraRow = mathTable.rows[1];
        coraRow.cells[1].textContent = `${columnE} - ${currentBacklog} = ${coraSet1Value.toFixed(2)}`;

        // ATROPS calculations
        let atropsRow = mathTable.rows[2];
        if (atropsData && allCoraData[nextNextCPT]) {
            let cap = parseFloat(atropsData.cap);
            let percentSchedule = parseFloat(atropsData.percentSchedule);

            // ATROPS Set 1
            let atropsSet1Value = cap * Math.max(0, (1 - percentSchedule/100)) * 1.6;
            atropsRow.cells[1].textContent = `${cap} * max(0, (1 - ${(percentSchedule/100).toFixed(2)})) * 1.6 = ${atropsSet1Value.toFixed(2)}`;

            // ATROPS Set 2
            let atropsSet2Value;
            if (percentSchedule > 100) {
                atropsSet2Value = allCoraData[nextNextCPT].columnD || atropsSet1Value;
            } else {
                   atropsSet2Value = atropsSet1Value;
            }
            atropsRow.cells[2].textContent = `${percentSchedule} > 100% ? ${atropsSet2Value.toFixed(2)} : ${atropsSet1Value.toFixed(2)}`;

            // ATROPS Set 3
            let atropsSet3Value = atropsSet2Value + currentBacklog;
            atropsRow.cells[3].textContent = `${atropsSet2Value.toFixed(2)} + ${currentBacklog} = ${atropsSet3Value.toFixed(2)}`;

            // CORA Set 2 and Set 3 Calculations
            let coraSet2Value, coraSet3Value;
            if (atropsSet1Value > coraSet1Value) {
                coraSet2Value = columnE;
            } else {
                coraSet2Value = currentBacklog + atropsSet1Value;
            }

            coraRow.cells[2].textContent = `${atropsSet1Value.toFixed(2)} > ${coraSet1Value.toFixed(2)} ? ${columnE} : ${currentBacklog} + ${atropsSet1Value.toFixed(2)} = ${coraSet2Value.toFixed(2)}`;

            coraSet3Value = coraSet2Value;
            coraRow.cells[3].textContent = `${coraSet2Value.toFixed(2)} = ${coraSet3Value.toFixed(2)}`;

            let mixedSet3Value = (coraSet3Value + atropsSet3Value) / 2;
            let mixedRow = mathTable.rows[3];
            mixedRow.cells[3].textContent = `(${coraSet3Value.toFixed(2)} + ${atropsSet3Value.toFixed(2)}) / 2 = ${mixedSet3Value.toFixed(2)}`;

            // Calculate Set 4 values
            let coraSet4Value = Math.ceil(coraSet3Value * multiplier);
            coraRow.cells[4].textContent = `${coraSet4Value}`;

            let atropsSet4Value = Math.ceil(atropsSet3Value * multiplier);
            atropsRow.cells[4].textContent = `${atropsSet4Value}`;

            let mixedSet4Value = Math.ceil(mixedSet3Value * multiplier);
            mixedRow.cells[4].textContent = `${mixedSet4Value}`;

            // Low Backlog Set 4 (placeholder)
            mathTable.rows[4].cells[4].textContent = '0';

            // Always use MIXED for CPT+2
            let selectedRiskRow = mathTable.rows[5] || mathTable.insertRow(-1);
            let riskModelCell = selectedRiskRow.cells[0] || selectedRiskRow.insertCell(0);
            riskModelCell.textContent = `Selected Risk Model (MIXED)`;
            riskModelCell.style.fontWeight = 'bold';
            riskModelCell.style.border = '1px solid black';
            riskModelCell.style.padding = '5px';

            let riskValueCell = selectedRiskRow.cells[1] || selectedRiskRow.insertCell(1);
            riskValueCell.textContent = mixedSet4Value;
            riskValueCell.style.border = '1px solid black';
            riskValueCell.style.padding = '5px';
            riskValueCell.colSpan = 4;
        }
    }
}

function addNextNextCPTManualOverrideListeners(row) {
    for (let i = 1; i < row.cells.length; i++) {
        const cell = row.cells[i];
        cell.addEventListener('click', function(event) {
            event.preventDefault();
            const currentValue = this.textContent.trim();
            const newValue = prompt(`Enter new HC value for CPT+2 or 'R' to remove override:\nCurrent value: ${currentValue}`);
            if (newValue !== null) {
                this.textContent = newValue;
                handleNextNextCPTManualOverride({ target: this });
            }
        });
    }
}

function handleNextNextCPTManualOverride(event) {
    const cell = event.target;
    const newValue = cell.textContent.trim();
    const row = cell.parentElement;
    const nextNextProductionTable = cell.closest('table');

    const maxWalls = getMaxWalls();

    if (newValue.toUpperCase() === 'R' || isNaN(parseFloat(newValue)) || parseFloat(newValue) < 1) {
        cell.dataset.userOverride = 'false';
        cell.style.backgroundColor = '';
    } else {
        const cappedValue = Math.min(parseFloat(newValue), maxWalls);
        cell.textContent = cappedValue;
        cell.dataset.userOverride = 'true';
        cell.style.backgroundColor = 'pink';
    }

    const scheduleTable = document.querySelector('#NextNextCPTSchedule');
    if (!scheduleTable) {
        return;
    }

    const productionWindows = getProductionWindows(scheduleTable);
    const expectedRates = getExpectedRates(nextNextProductionTable, row, productionWindows);
    const nextNextCPT = getNextNextCPT(document.getElementById('cptSelect').value);

    const userOverrides = {};
    for (let i = 1; i < row.cells.length; i++) {
        const overrideCell = row.cells[i];
        if (overrideCell.dataset.userOverride === 'true') {
            userOverrides[i - 1] = Math.min(parseFloat(overrideCell.textContent), maxWalls);
        }
    }

    const mathTable = document.querySelector('#nextNextCPTMathTableContainer table');
    let mixedSet4Value = 0;
    if (mathTable) {
        const mixedRow = Array.from(mathTable.rows).find(row => row.cells[0].textContent === 'MIXED');
        if (mixedRow && mixedRow.cells[4]) {
            mixedSet4Value = parseInt(mixedRow.cells[4].textContent) || 0;
        }
    }

    const newRecommendations = calculateHCRecommendations(mixedSet4Value, productionWindows, expectedRates, userOverrides, nextNextCPT);
    updateNextNextCPTPickRebinPackRow(row, newRecommendations, userOverrides);

    updateOutboundTotals(nextNextProductionTable);
    updateNextNextCPTProductionGraphic();

    // Update Pick HC after Pack HC is set
    updateNextNextCPTPickHCBasedOnPackHC(nextNextProductionTable);
}

function updateNextNextCPTProductionGraphic() {
    const nextNextCPTScheduleTable = document.querySelector('#NextNextCPTSchedule');
    const nextNextProductionTable = document.getElementById('nextNextCPTProductionGraphicTable');

    if (nextNextCPTScheduleTable && nextNextProductionTable) {
        const productionWindows = getProductionWindows(nextNextCPTScheduleTable);
        updateGraphicBasedOnSchedule(nextNextCPTScheduleTable, nextNextProductionTable);
    }
}
// More stuff, don't worry about it

let planSummary3Container = document.createElement('div');
planSummary3Container.id = 'planSummary3Container';
planSummary3Container.style.position = 'fixed';
planSummary3Container.style.top = '1800px'; // Same height as planSummary2
planSummary3Container.style.right = '10px'; // Position to the right of planSummary2
planSummary3Container.style.width = '800px';
planSummary3Container.style.backgroundColor = 'white';
planSummary3Container.style.border = '1px solid black';
planSummary3Container.style.padding = '10px';
planSummary3Container.style.zIndex = '10000';
planSummary3Container.style.fontSize = '20px';
planSummary3Container.style.display = 'none';

document.body.appendChild(planSummary3Container);

function updatePlanSummary3() {
    const nextNextCPTSchedule = document.getElementById('NextNextCPTSchedule');
    if (!nextNextCPTSchedule) {
        return;
    }

    const nextNextProductionTable = document.getElementById('nextNextCPTProductionGraphicTable');
    if (!nextNextProductionTable) {
        return;
    }

    const planSummary3Container = document.getElementById('planSummary3Container');
    planSummary3Container.innerHTML = `
        <h3 style="
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 24px;
            font-weight: 600;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        ">
            <span>Plan Summary 3</span>
            <span style="
                font-size: 14px;
                color: #64748b;
                font-weight: normal;
            ">CPT+2 Plan</span>
        </h3>`;

    const table = document.createElement('table');
    table.style.cssText = `
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-top: 10px;
        position: relative;
        max-height: calc(100vh - 400px);
        overflow-y: auto;
    `;

    const headerRow = table.insertRow();
    headerRow.style.cssText = `
        position: sticky;
        top: 0;
        z-index: 1;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    `;
    ['Window', 'Multis Capacity', 'Singles', 'Total Capacity', 'Effective Time', 'Window Planned Volume'].forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        th.style.cssText = `
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            background-color: #f8fafc;
            border-bottom: 2px solid #edf2f7;
            position: sticky;
            top: 0;
            transition: background-color 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            letter-spacing: 0.3px;
        `;
        headerRow.appendChild(th);
    });

    const timeRow = nextNextCPTSchedule.rows[0];
    const durationRow = nextNextCPTSchedule.rows[1];
    const blockTypeRow = nextNextCPTSchedule.rows[2];
    const packRow = Array.from(nextNextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'Pick2Rebin Pack');
    const vnaPackRow = Array.from(nextNextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');

    if (!blockTypeRow || !packRow || !vnaPackRow) {
        return;
    }

    const packRateRow = packRow.nextElementSibling;
    const vnaPackRateRow = vnaPackRow.nextElementSibling;

    const productionWindows = [];
    for (let i = 0; i < blockTypeRow.cells.length; i++) {
        if (blockTypeRow.cells[i].textContent.trim() === 'Production') {
            productionWindows.push({
                index: i,
                time: timeRow.cells[i].textContent,
                duration: durationRow.cells[i].textContent
            });
        }
    }

    let obPlannedVolume = 0;
    const currentCPT = document.getElementById('cptSelect').value;
    const nextNextCPT = getNextNextCPT(currentCPT);

    productionWindows.forEach((window, index) => {
        const row = table.insertRow();
        row.style.cssText = `
            transition: all 0.2s ease;
        `;

        row.addEventListener('mouseover', () => {
            row.style.backgroundColor = '#f8fafc';
        });
        row.addEventListener('mouseout', () => {
            row.style.backgroundColor = 'transparent';
        });

        const timeCell = row.insertCell();
        timeCell.textContent = window.time;

        const packHC = parseInt(packRow.cells[index + 1].textContent) || 0;
        const packRate = parseFloat(packRateRow.cells[index + 1].textContent) || 0;
        const multisCapacity = packHC * packRate;
        const multisCell = row.insertCell();
        multisCell.textContent = multisCapacity.toFixed(0);
        multisCell.style.cssText = `
            padding: 12px;
            text-align: right;
            color: #2563eb;
            font-weight: 500;
        `;

        const vnaPackHC = parseInt(vnaPackRow.cells[index + 1].textContent) || 0;
        const vnaPackRate = parseFloat(vnaPackRateRow.cells[index + 1].textContent) || 0;
        const singlesCapacity = vnaPackHC * vnaPackRate;
        const singlesCell = row.insertCell();
        singlesCell.textContent = singlesCapacity.toFixed(0);
        singlesCell.style.cssText = `
            padding: 12px;
            text-align: right;
            color: #059669;
            font-weight: 500;
        `;

        const totalCapacity = multisCapacity + singlesCapacity;
        const totalCapacityCell = row.insertCell();
        totalCapacityCell.textContent = totalCapacity.toFixed(0);
        totalCapacityCell.style.cssText = `
            padding: 12px;
            text-align: right;
            color: #7c3aed;
            font-weight: 600;
            background-color: ${totalCapacity > 0 ? '#f5f3ff' : 'transparent'};
            border-radius: 4px;
        `;

        let effectiveTime;
        if (index === 0 && window.duration.includes('left in block')) {
            effectiveTime = convertLeftInBlockToHours(window.duration);
        } else if (index === productionWindows.length - 1) {
            let [startTime, endTime] = window.time.split(' to ');
            let startMinutes = convertToMinutesSinceMidnight(startTime);
            let nextNextCPTMinutes = convertToMinutesSinceMidnight(nextNextCPT);
            if (nextNextCPTMinutes < startMinutes) nextNextCPTMinutes += 24 * 60;
            effectiveTime = (nextNextCPTMinutes - startMinutes) / 60;
        } else {
            effectiveTime = convertToHours(window.duration);
        }

        const timeLeftCell = row.insertCell();
        timeLeftCell.textContent = effectiveTime.toFixed(2);
        timeLeftCell.style.cssText = `
            padding: 12px;
            text-align: right;
            color: #dc2626;
            font-weight: 500;
        `;

        const windowPlannedVolume = totalCapacity * effectiveTime;
        const volumeCell = row.insertCell();
        volumeCell.textContent = windowPlannedVolume.toFixed(0);
        volumeCell.style.cssText = `
            padding: 12px;
            text-align: right;
            color: #0891b2;
            font-weight: 600;
            background-color: ${windowPlannedVolume > 0 ? '#f0f9ff' : 'transparent'};
            border-radius: 4px;
        `;

        obPlannedVolume += windowPlannedVolume;
    });

    // Add summary row
    const summaryRow = table.insertRow();
    summaryRow.style.cssText = `
        background-color: #f8fafc;
        font-weight: 600;
        margin-top: 10px;
        border-radius: 0 0 8px 8px;
    `;

    const columnAValue = getNextNextCPTCurrentBacklog(nextNextCPT);
    const riskPercentage = Math.ceil((columnAValue / obPlannedVolume) * 100 * 100) / 100;
    const columnEValue = getNextNextCPTColumnEFromCORA(nextNextCPT);
    const riskWithExpectedCharge = Math.ceil((columnEValue / obPlannedVolume) * 100 * 100) / 100;

    // OB Planned Volume
    const plannedVolumeCell = summaryRow.insertCell();
    plannedVolumeCell.innerHTML = `<span style="font-weight: 700">OB Planned Volume:</span> <span style="font-weight: normal">${obPlannedVolume}</span>`;
    plannedVolumeCell.style.cssText = `
        padding: 16px;
        color: #1e293b;
        border-radius: 0 0 0 8px;
        font-size: 20px;
    `;
    plannedVolumeCell.colSpan = 2;

    // Risk %
    const riskCell = summaryRow.insertCell();
    riskCell.innerHTML = `<span style="font-weight: 700">Risk %:</span> <span style="font-weight: normal">${riskPercentage.toFixed(2)}%</span>`;
    riskCell.style.cssText = `
        padding: 16px;
        text-align: center;
        font-size: 20px;
        ${riskPercentage > 90 ? 'background-color: #fee2e2; color: #991b1b;' :
          riskPercentage > 80 ? 'background-color: #fef9c3; color: #854d0e;' : ''}
    `;
    riskCell.colSpan = 2;

    // Risk with Expected Charge
    const riskWithChargeCell = summaryRow.insertCell();
    riskWithChargeCell.innerHTML = `<span style="font-weight: 700">Risk with Expected Charge:</span> <span style="font-weight: normal">${riskWithExpectedCharge.toFixed(2)}%</span>`;
    riskWithChargeCell.style.cssText = `
        padding: 16px;
        text-align: right;
        color: #1e293b;
        border-radius: 0 0 8px 0;
        font-size: 20px;
    `;
    riskWithChargeCell.colSpan = 2;

    planSummary3Container.appendChild(table);
}

    // ==================== PLAN SUMMARY 4 ====================
let planSummary4Container = document.createElement('div');
planSummary4Container.id = 'planSummary4Container';
planSummary4Container.style.cssText = `
    position: fixed;
    top: 2600px;
    right: 40px;
    width: 650px;
    background-color: #ffffff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 12px;
    padding: 20px;
    z-index: 10000;
    font-size: 20px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(-10px);
    display: none;
`;
document.body.appendChild(planSummary4Container);

function updatePlanSummary4() {
    console.log("Starting updatePlanSummary4");

    const nextNextNextCPTSchedule = document.getElementById('NextNextNextCPTSchedule');
    if (!nextNextNextCPTSchedule) {
        console.error('NextNextNextCPTSchedule table not found');
        return;
    }

    const nextNextNextProductionTable = document.getElementById('nextNextNextCPTProductionGraphicTable');
    if (!nextNextNextProductionTable) {
        console.error('Next Next Next CPT Production table not found');
        return;
    }

    const planSummary4Container = document.getElementById('planSummary4Container');
    planSummary4Container.innerHTML = `
        <h3 style="
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 24px;
            font-weight: 600;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        ">
            <span>Plan Summary 4</span>
            <span style="
                font-size: 14px;
                color: #64748b;
                font-weight: normal;
            ">CPT+3 Plan</span>
        </h3>`;

    const table = document.createElement('table');
    table.style.cssText = `
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-top: 10px;
        position: relative;
        max-height: calc(100vh - 400px);
        overflow-y: auto;
    `;

    const headerRow = table.insertRow();
    headerRow.style.cssText = `
        position: sticky;
        top: 0;
        z-index: 1;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    `;
    ['Window', 'Multis Capacity', 'Singles', 'Total Capacity', 'Effective Time', 'Window Planned Volume'].forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        th.style.cssText = `
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            background-color: #f8fafc;
            border-bottom: 2px solid #edf2f7;
            position: sticky;
            top: 0;
            transition: background-color 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            letter-spacing: 0.3px;
        `;
        headerRow.appendChild(th);
    });

    const timeRow = nextNextNextCPTSchedule.rows[0];
    const durationRow = nextNextNextCPTSchedule.rows[1];
    const blockTypeRow = nextNextNextCPTSchedule.rows[2];
    const packRow = Array.from(nextNextNextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'Pick2Rebin Pack');
    const vnaPackRow = Array.from(nextNextNextProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');

    if (!blockTypeRow || !packRow || !vnaPackRow) {
        console.error('Required rows not found for CPT+3');
        return;
    }

    const packRateRow = packRow.nextElementSibling;
    const vnaPackRateRow = vnaPackRow.nextElementSibling;

    const productionWindows = [];
    for (let i = 0; i < blockTypeRow.cells.length; i++) {
        if (blockTypeRow.cells[i].textContent.trim() === 'Production') {
            productionWindows.push({
                index: i,
                time: timeRow.cells[i].textContent,
                duration: durationRow.cells[i].textContent
            });
        }
    }

    console.log("CPT+3 Production windows:", productionWindows);

    let obPlannedVolume = 0;
    const currentCPT = document.getElementById('cptSelect').value;
    const cptPlus3 = getNextNextNextCPT(currentCPT);

    productionWindows.forEach((window, index) => {
        console.log(`\nProcessing window ${index + 1}:`, window);

        const row = table.insertRow();
        row.style.cssText = `transition: all 0.2s ease;`;

        row.addEventListener('mouseover', () => { row.style.backgroundColor = '#f8fafc'; });
        row.addEventListener('mouseout', () => { row.style.backgroundColor = 'transparent'; });

        row.insertCell().textContent = window.time;

        const packHC = parseInt(packRow.cells[index + 1].textContent) || 0;
        const packRate = parseFloat(packRateRow.cells[index + 1].textContent) || 0;
        const multisCapacity = packHC * packRate;
        const multisCell = row.insertCell();
        multisCell.textContent = multisCapacity.toFixed(0);
        multisCell.style.cssText = `padding: 12px; text-align: right; color: #2563eb; font-weight: 500;`;

        const vnaPackHC = parseInt(vnaPackRow.cells[index + 1].textContent) || 0;
        const vnaPackRate = parseFloat(vnaPackRateRow.cells[index + 1].textContent) || 0;
        const singlesCapacity = vnaPackHC * vnaPackRate;
        const singlesCell = row.insertCell();
        singlesCell.textContent = singlesCapacity.toFixed(0);
        singlesCell.style.cssText = `padding: 12px; text-align: right; color: #059669; font-weight: 500;`;

        const totalCapacity = multisCapacity + singlesCapacity;
        const totalCapacityCell = row.insertCell();
        totalCapacityCell.textContent = totalCapacity.toFixed(0);
        totalCapacityCell.style.cssText = `padding: 12px; text-align: right; color: #7c3aed; font-weight: 600; background-color: ${totalCapacity > 0 ? '#f5f3ff' : 'transparent'}; border-radius: 4px;`;

        let effectiveTime;
        if (index === 0 && window.duration.includes('left in block')) {
            effectiveTime = convertLeftInBlockToHours(window.duration);
        } else if (index === productionWindows.length - 1) {
            let [startTime, endTime] = window.time.split(' to ');
            let startMinutes = convertToMinutesSinceMidnight(startTime);
            let cptPlus3Minutes = convertToMinutesSinceMidnight(cptPlus3);
            if (cptPlus3Minutes < startMinutes) cptPlus3Minutes += 24 * 60;
            effectiveTime = (cptPlus3Minutes - startMinutes) / 60;
        } else {
            effectiveTime = convertToHours(window.duration);
        }

        const timeCell = row.insertCell();
        timeCell.textContent = effectiveTime.toFixed(2);
        timeCell.style.cssText = `padding: 12px; text-align: right; color: #dc2626; font-weight: 500;`;

        const windowPlannedVolume = totalCapacity * effectiveTime;
        const volumeCell = row.insertCell();
        volumeCell.textContent = windowPlannedVolume.toFixed(0);
        volumeCell.style.cssText = `padding: 12px; text-align: right; color: #0891b2; font-weight: 600; background-color: ${windowPlannedVolume > 0 ? '#f0f9ff' : 'transparent'}; border-radius: 4px;`;
        obPlannedVolume += windowPlannedVolume;

        row.querySelectorAll('td').forEach((cell, cellIndex) => {
            cell.style.cssText += `border-bottom: 1px solid #edf2f7; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; transition: background-color 0.2s ease;`;
            if (cellIndex === 0) cell.style.textAlign = 'left';
        });
    });

    obPlannedVolume = Math.ceil(obPlannedVolume);

    const summaryRow = table.insertRow();
    summaryRow.style.cssText = `background-color: #f8fafc; font-weight: 600; margin-top: 10px; border-radius: 0 0 8px 8px;`;

    const plannedVolumeCell = summaryRow.insertCell();
    plannedVolumeCell.innerHTML = `<span style="font-weight: 700">OB Planned Volume:</span> <span style="font-weight: normal">${obPlannedVolume}</span>`;
    plannedVolumeCell.style.cssText = `padding: 16px; color: #1e293b; border-radius: 0 0 0 8px; font-size: 20px;`;
    plannedVolumeCell.colSpan = 6;

    planSummary4Container.appendChild(table);
    console.log("Finished updatePlanSummary4");
}

// ==================== PLAN SUMMARY 5 ====================
let planSummary5Container = document.createElement('div');
planSummary5Container.id = 'planSummary5Container';
planSummary5Container.style.cssText = `
    position: fixed;
    top: 3400px;
    right: 40px;
    width: 650px;
    background-color: #ffffff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 12px;
    padding: 20px;
    z-index: 10000;
    font-size: 20px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(-10px);
    display: none;
`;
document.body.appendChild(planSummary5Container);

function updatePlanSummary5() {
    console.log("Starting updatePlanSummary5");

    const cptPlus4Schedule = document.getElementById('CPTPlus4Schedule');
    if (!cptPlus4Schedule) {
        console.error('CPTPlus4Schedule table not found');
        return;
    }

    const cptPlus4ProductionTable = document.getElementById('cptPlus4ProductionGraphicTable');
    if (!cptPlus4ProductionTable) {
        console.error('CPT+4 Production table not found');
        return;
    }

    const planSummary5Container = document.getElementById('planSummary5Container');
    planSummary5Container.innerHTML = `
        <h3 style="
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 24px;
            font-weight: 600;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        ">
            <span>Plan Summary 5</span>
            <span style="
                font-size: 14px;
                color: #64748b;
                font-weight: normal;
            ">CPT+4 Plan</span>
        </h3>`;

    const table = document.createElement('table');
    table.style.cssText = `
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-top: 10px;
        position: relative;
        max-height: calc(100vh - 400px);
        overflow-y: auto;
    `;

    const headerRow = table.insertRow();
    headerRow.style.cssText = `
        position: sticky;
        top: 0;
        z-index: 1;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    `;
    ['Window', 'Multis Capacity', 'Singles', 'Total Capacity', 'Effective Time', 'Window Planned Volume'].forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        th.style.cssText = `
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            background-color: #f8fafc;
            border-bottom: 2px solid #edf2f7;
            position: sticky;
            top: 0;
            transition: background-color 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            letter-spacing: 0.3px;
        `;
        headerRow.appendChild(th);
    });

    const timeRow = cptPlus4Schedule.rows[0];
    const durationRow = cptPlus4Schedule.rows[1];
    const blockTypeRow = cptPlus4Schedule.rows[2];
    const packRow = Array.from(cptPlus4ProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'Pick2Rebin Pack');
    const vnaPackRow = Array.from(cptPlus4ProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');

    if (!blockTypeRow || !packRow || !vnaPackRow) {
        console.error('Required rows not found for CPT+4');
        return;
    }

    const packRateRow = packRow.nextElementSibling;
    const vnaPackRateRow = vnaPackRow.nextElementSibling;

    const productionWindows = [];
    for (let i = 0; i < blockTypeRow.cells.length; i++) {
        if (blockTypeRow.cells[i].textContent.trim() === 'Production') {
            productionWindows.push({
                index: i,
                time: timeRow.cells[i].textContent,
                duration: durationRow.cells[i].textContent
            });
        }
    }

    console.log("CPT+4 Production windows:", productionWindows);

    let obPlannedVolume = 0;
    const currentCPT = document.getElementById('cptSelect').value;
    const cptPlus4 = getCPTPlus4(currentCPT);

    productionWindows.forEach((window, index) => {
        console.log(`\nProcessing window ${index + 1}:`, window);

        const row = table.insertRow();
        row.style.cssText = `transition: all 0.2s ease;`;

        row.addEventListener('mouseover', () => { row.style.backgroundColor = '#f8fafc'; });
        row.addEventListener('mouseout', () => { row.style.backgroundColor = 'transparent'; });

        row.insertCell().textContent = window.time;

        const packHC = parseInt(packRow.cells[index + 1].textContent) || 0;
        const packRate = parseFloat(packRateRow.cells[index + 1].textContent) || 0;
        const multisCapacity = packHC * packRate;
        const multisCell = row.insertCell();
        multisCell.textContent = multisCapacity.toFixed(0);
        multisCell.style.cssText = `padding: 12px; text-align: right; color: #2563eb; font-weight: 500;`;

        const vnaPackHC = parseInt(vnaPackRow.cells[index + 1].textContent) || 0;
        const vnaPackRate = parseFloat(vnaPackRateRow.cells[index + 1].textContent) || 0;
        const singlesCapacity = vnaPackHC * vnaPackRate;
        const singlesCell = row.insertCell();
        singlesCell.textContent = singlesCapacity.toFixed(0);
        singlesCell.style.cssText = `padding: 12px; text-align: right; color: #059669; font-weight: 500;`;

        const totalCapacity = multisCapacity + singlesCapacity;
        const totalCapacityCell = row.insertCell();
        totalCapacityCell.textContent = totalCapacity.toFixed(0);
        totalCapacityCell.style.cssText = `padding: 12px; text-align: right; color: #7c3aed; font-weight: 600; background-color: ${totalCapacity > 0 ? '#f5f3ff' : 'transparent'}; border-radius: 4px;`;

        let effectiveTime;
        if (index === 0 && window.duration.includes('left in block')) {
            effectiveTime = convertLeftInBlockToHours(window.duration);
        } else if (index === productionWindows.length - 1) {
            let [startTime, endTime] = window.time.split(' to ');
            let startMinutes = convertToMinutesSinceMidnight(startTime);
            let cptPlus4Minutes = convertToMinutesSinceMidnight(cptPlus4);
            if (cptPlus4Minutes < startMinutes) cptPlus4Minutes += 24 * 60;
            effectiveTime = (cptPlus4Minutes - startMinutes) / 60;
        } else {
            effectiveTime = convertToHours(window.duration);
        }

        const timeCell = row.insertCell();
        timeCell.textContent = effectiveTime.toFixed(2);
        timeCell.style.cssText = `padding: 12px; text-align: right; color: #dc2626; font-weight: 500;`;

        const windowPlannedVolume = totalCapacity * effectiveTime;
        const volumeCell = row.insertCell();
        volumeCell.textContent = windowPlannedVolume.toFixed(0);
        volumeCell.style.cssText = `padding: 12px; text-align: right; color: #0891b2; font-weight: 600; background-color: ${windowPlannedVolume > 0 ? '#f0f9ff' : 'transparent'}; border-radius: 4px;`;
        obPlannedVolume += windowPlannedVolume;

        row.querySelectorAll('td').forEach((cell, cellIndex) => {
            cell.style.cssText += `border-bottom: 1px solid #edf2f7; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; transition: background-color 0.2s ease;`;
            if (cellIndex === 0) cell.style.textAlign = 'left';
        });
    });

    obPlannedVolume = Math.ceil(obPlannedVolume);

    const summaryRow = table.insertRow();
    summaryRow.style.cssText = `background-color: #f8fafc; font-weight: 600; margin-top: 10px; border-radius: 0 0 8px 8px;`;

    const plannedVolumeCell = summaryRow.insertCell();
    plannedVolumeCell.innerHTML = `<span style="font-weight: 700">OB Planned Volume:</span> <span style="font-weight: normal">${obPlannedVolume}</span>`;
    plannedVolumeCell.style.cssText = `padding: 16px; color: #1e293b; border-radius: 0 0 0 8px; font-size: 20px;`;
    plannedVolumeCell.colSpan = 6;

    planSummary5Container.appendChild(table);
    console.log("Finished updatePlanSummary5");
}

// ==================== PLAN SUMMARY 6 ====================
let planSummary6Container = document.createElement('div');
planSummary6Container.id = 'planSummary6Container';
planSummary6Container.style.cssText = `
    position: fixed;
    top: 4200px;
    right: 40px;
    width: 650px;
    background-color: #ffffff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border-radius: 12px;
    padding: 20px;
    z-index: 10000;
    font-size: 20px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    transition: all 0.3s ease;
    opacity: 0;
    transform: translateY(-10px);
    display: none;
`;
document.body.appendChild(planSummary6Container);

function updatePlanSummary6() {
    console.log("Starting updatePlanSummary6");

    const cptPlus5Schedule = document.getElementById('CPTPlus5Schedule');
    if (!cptPlus5Schedule) {
        console.error('CPTPlus5Schedule table not found');
        return;
    }

    const cptPlus5ProductionTable = document.getElementById('cptPlus5ProductionGraphicTable');
    if (!cptPlus5ProductionTable) {
        console.error('CPT+5 Production table not found');
        return;
    }

    const planSummary6Container = document.getElementById('planSummary6Container');
    planSummary6Container.innerHTML = `
        <h3 style="
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 24px;
            font-weight: 600;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        ">
            <span>Plan Summary 6</span>
            <span style="
                font-size: 14px;
                color: #64748b;
                font-weight: normal;
            ">CPT+5 Plan</span>
        </h3>`;

    const table = document.createElement('table');
    table.style.cssText = `
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-top: 10px;
        position: relative;
        max-height: calc(100vh - 400px);
        overflow-y: auto;
    `;

    const headerRow = table.insertRow();
    headerRow.style.cssText = `
        position: sticky;
        top: 0;
        z-index: 1;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    `;
    ['Window', 'Multis Capacity', 'Singles', 'Total Capacity', 'Effective Time', 'Window Planned Volume'].forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        th.style.cssText = `
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            background-color: #f8fafc;
            border-bottom: 2px solid #edf2f7;
            position: sticky;
            top: 0;
            transition: background-color 0.3s ease;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            letter-spacing: 0.3px;
        `;
        headerRow.appendChild(th);
    });

    const timeRow = cptPlus5Schedule.rows[0];
    const durationRow = cptPlus5Schedule.rows[1];
    const blockTypeRow = cptPlus5Schedule.rows[2];
    const packRow = Array.from(cptPlus5ProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'Pick2Rebin Pack');
    const vnaPackRow = Array.from(cptPlus5ProductionTable.rows).find(row => row.cells[0].textContent.trim().replace(/^[‚ñº‚ñ∂]\s*/, '') === 'VNA Pack');

    if (!blockTypeRow || !packRow || !vnaPackRow) {
        console.error('Required rows not found for CPT+5');
        return;
    }

    const packRateRow = packRow.nextElementSibling;
    const vnaPackRateRow = vnaPackRow.nextElementSibling;

    const productionWindows = [];
    for (let i = 0; i < blockTypeRow.cells.length; i++) {
        if (blockTypeRow.cells[i].textContent.trim() === 'Production') {
            productionWindows.push({
                index: i,
                time: timeRow.cells[i].textContent,
                duration: durationRow.cells[i].textContent
            });
        }
    }

    console.log("CPT+5 Production windows:", productionWindows);

    let obPlannedVolume = 0;
    const currentCPT = document.getElementById('cptSelect').value;
    const cptPlus5 = getCPTPlus5(currentCPT);

    productionWindows.forEach((window, index) => {
        console.log(`\nProcessing window ${index + 1}:`, window);

        const row = table.insertRow();
        row.style.cssText = `transition: all 0.2s ease;`;

        row.addEventListener('mouseover', () => { row.style.backgroundColor = '#f8fafc'; });
        row.addEventListener('mouseout', () => { row.style.backgroundColor = 'transparent'; });

        row.insertCell().textContent = window.time;

        const packHC = parseInt(packRow.cells[index + 1].textContent) || 0;
        const packRate = parseFloat(packRateRow.cells[index + 1].textContent) || 0;
        const multisCapacity = packHC * packRate;
        const multisCell = row.insertCell();
        multisCell.textContent = multisCapacity.toFixed(0);
        multisCell.style.cssText = `padding: 12px; text-align: right; color: #2563eb; font-weight: 500;`;

        const vnaPackHC = parseInt(vnaPackRow.cells[index + 1].textContent) || 0;
        const vnaPackRate = parseFloat(vnaPackRateRow.cells[index + 1].textContent) || 0;
        const singlesCapacity = vnaPackHC * vnaPackRate;
        const singlesCell = row.insertCell();
        singlesCell.textContent = singlesCapacity.toFixed(0);
        singlesCell.style.cssText = `padding: 12px; text-align: right; color: #059669; font-weight: 500;`;

        const totalCapacity = multisCapacity + singlesCapacity;
        const totalCapacityCell = row.insertCell();
        totalCapacityCell.textContent = totalCapacity.toFixed(0);
        totalCapacityCell.style.cssText = `padding: 12px; text-align: right; color: #7c3aed; font-weight: 600; background-color: ${totalCapacity > 0 ? '#f5f3ff' : 'transparent'}; border-radius: 4px;`;

        let effectiveTime;
        if (index === 0 && window.duration.includes('left in block')) {
            effectiveTime = convertLeftInBlockToHours(window.duration);
        } else if (index === productionWindows.length - 1) {
            let [startTime, endTime] = window.time.split(' to ');
            let startMinutes = convertToMinutesSinceMidnight(startTime);
            let cptPlus5Minutes = convertToMinutesSinceMidnight(cptPlus5);
            if (cptPlus5Minutes < startMinutes) cptPlus5Minutes += 24 * 60;
            effectiveTime = (cptPlus5Minutes - startMinutes) / 60;
        } else {
            effectiveTime = convertToHours(window.duration);
        }

        const timeCell = row.insertCell();
        timeCell.textContent = effectiveTime.toFixed(2);
        timeCell.style.cssText = `padding: 12px; text-align: right; color: #dc2626; font-weight: 500;`;

        const windowPlannedVolume = totalCapacity * effectiveTime;
        const volumeCell = row.insertCell();
        volumeCell.textContent = windowPlannedVolume.toFixed(0);
        volumeCell.style.cssText = `padding: 12px; text-align: right; color: #0891b2; font-weight: 600; background-color: ${windowPlannedVolume > 0 ? '#f0f9ff' : 'transparent'}; border-radius: 4px;`;
        obPlannedVolume += windowPlannedVolume;

        row.querySelectorAll('td').forEach((cell, cellIndex) => {
            cell.style.cssText += `border-bottom: 1px solid #edf2f7; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; transition: background-color 0.2s ease;`;
            if (cellIndex === 0) cell.style.textAlign = 'left';
        });
    });

    obPlannedVolume = Math.ceil(obPlannedVolume);

    const summaryRow = table.insertRow();
    summaryRow.style.cssText = `background-color: #f8fafc; font-weight: 600; margin-top: 10px; border-radius: 0 0 8px 8px;`;

    const plannedVolumeCell = summaryRow.insertCell();
    plannedVolumeCell.innerHTML = `<span style="font-weight: 700">OB Planned Volume:</span> <span style="font-weight: normal">${obPlannedVolume}</span>`;
    plannedVolumeCell.style.cssText = `padding: 16px; color: #1e293b; border-radius: 0 0 0 8px; font-size: 20px;`;
    plannedVolumeCell.colSpan = 6;

    planSummary5Container.appendChild(table);
    console.log("Finished updatePlanSummary6");
}

function getNextNextCPTCurrentBacklog(nextNextCPT) {
    const coraTable = document.querySelector('.CORA-table');
    if (!coraTable) {
        return 0;
    }

    for (let i = 1; i < coraTable.rows.length; i++) {
        if (coraTable.rows[i].cells[0].textContent.trim() === nextNextCPT) {
            const backlog = parseInt(coraTable.rows[i].cells[1].textContent.trim().replace(/,/g, ''), 10);
            return isNaN(backlog) ? 0 : backlog;
        }
    }

    return 0;
}

function getNextNextCPTColumnEFromCORA(nextNextCPT) {
    const coraTable = document.querySelector('.CORA-table');
    if (!coraTable) {
        return 0;
    }

    for (let i = 1; i < coraTable.rows.length; i++) {
        if (coraTable.rows[i].cells[0].textContent.trim() === nextNextCPT) {
            const columnE = parseInt(coraTable.rows[i].cells[3].textContent.trim().replace(/,/g, ''), 10);
            return isNaN(columnE) ? 0 : columnE;
        }
    }

    return 0;
}
// So it has come to this. Adding Grocery stuff

 // Create a container for the Grocery Rodeo data
let groceryRodeoContainer = document.createElement('div');
groceryRodeoContainer.id = 'groceryRodeoContainer';
groceryRodeoContainer.style.position = 'fixed';
groceryRodeoContainer.style.left = '1500px';
groceryRodeoContainer.style.top = '360px';
groceryRodeoContainer.style.border = '1px solid black';
groceryRodeoContainer.style.padding = '10px';
groceryRodeoContainer.style.width = '310px';
groceryRodeoContainer.style.backgroundColor = 'white';
groceryRodeoContainer.style.display = 'none';
document.body.appendChild(groceryRodeoContainer);

function generateGroceryRodeoURL(site) {
    const baseURL = "https://rodeo-iad.amazon.com/";
    return `${baseURL}${site}/ExSD?yAxis=PROCESS_PATH&zAxis=WORK_POOL&shipmentTypes=ALL&exSDRange.quickRange=PLUS_MINUS_1_DAY&exSDRange.dailyStart=00%3A00&exSDRange.dailyEnd=00%3A00&giftOption=ALL&fulfillmentServiceClass=ALL&fracs=ALL&isEulerExSDMiss=ALL&isEulerPromiseMiss=ALL&isEulerUpgraded=ALL&isReactiveTransfer=ALL&workPool=PlannedShipment&_workPool=on&workPool=ReadyToPick&workPool=ReadyToPickHardCapped&workPool=ReadyToPickUnconstrained&workPool=PickingNotYetPicked&workPool=PickingNotYetPickedPrioritized&workPool=PickingNotYetPickedNotPrioritized&workPool=PickingNotYetPickedHardCapped&workPool=CrossdockNotYetPicked&_workPool=on&workPool=PickingPicked&workPool=PickingPickedInProgress&workPool=PickingPickedInTransit&workPool=PickingPickedRouting&workPool=PickingPickedAtDestination&workPool=Inducted&workPool=RebinBuffered&workPool=Sorted&workPool=GiftWrap&workPool=Packing&workPool=Scanned&workPool=ProblemSolving&workPool=ProcessPartial&workPool=SoftwareException&workPool=Crossdock&workPool=PreSort&workPool=TransshipSorted&workPool=Palletized&workPool=PalletizedStaged&_workPool=on&workPool=ManifestPending&workPool=ManifestPendingVerification&workPool=Manifested&workPool=Slammed&workPool=ReceivedBySorter&workPool=InterceptProblemSolve&workPool=STaRSSlammed&workPool=STaRSReceivedBySorter&workPool=STaRSDiverted&workPool=STaRSStacked&workPool=STaRSStaged&workPool=STaRSLoaded&workPool=Diverted&workPool=Stacked&workPool=Staged&workPool=Loaded&workPool=TransshipManifested&_workPool=on&processPath=PPChilled&processPath=PPAmbient&processPath=PPFrozen&processPath=&minPickPriority=MIN_PRIORITY&shipMethod=&shipOption=&sortCode=&fnSku=`;
}

let groceryRodeoButton = document.createElement('button');
groceryRodeoButton.id = 'groceryRodeoButton';
groceryRodeoButton.textContent = 'Grocery Rodeo';
groceryRodeoButton.style.position = 'fixed';
groceryRodeoButton.style.top = '180px';
groceryRodeoButton.style.right = '500px';
groceryRodeoButton.style.padding = '5px 15px';
groceryRodeoButton.style.zIndex = '10';
groceryRodeoButton.style.backgroundColor = '#4CAF50';
groceryRodeoButton.style.color = 'white';
groceryRodeoButton.style.border = 'none';
groceryRodeoButton.style.borderRadius = '4px';
groceryRodeoButton.style.cursor = 'pointer';
groceryRodeoButton.style.display = 'none';
groceryRodeoButton.onclick = () => fetchAndDisplayGroceryRodeo();
document.body.appendChild(groceryRodeoButton);

function updateGroceryRodeoButtonVisibility() {
    const selectedSite = document.getElementById('siteSelector').value;
    groceryRodeoButton.style.display = selectedSite === 'SAZ2' ? 'block' : 'none';
}

document.getElementById('siteSelector').addEventListener('change', updateGroceryRodeoButtonVisibility);
window.addEventListener('load', updateGroceryRodeoButtonVisibility);

function createGroceryRodeoPopup() {
    const popup = document.createElement('div');
    popup.id = 'groceryRodeoPopup';
    popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 30px;
        border: 2px solid #ddd;
        border-radius: 8px;
        z-index: 20000;
        width: 90vw;
        max-width: 1500px;
        max-height: 90vh;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    `;

    const closeButton = document.createElement('div');
    closeButton.textContent = '‚úï';
    closeButton.style.cssText = `
        position: absolute;
        right: 15px;
        top: 15px;
        color: red;
        font-size: 28px;
        cursor: pointer;
        font-weight: bold;
        width: 30px;
        height: 30px;
        line-height: 30px;
        text-align: center;
        border-radius: 50%;
        transition: background-color 0.3s;
    `;
    closeButton.onmouseover = () => {
        closeButton.style.backgroundColor = 'rgba(255,0,0,0.1)';
    };
    closeButton.onmouseout = () => {
        closeButton.style.backgroundColor = 'transparent';
    };
    closeButton.onclick = () => popup.remove();

    const title = document.createElement('h2');
    title.textContent = 'Grocery Rodeo Data';
    title.style.cssText = `
        margin: 0 0 20px 0;
        padding-bottom: 10px;
        border-bottom: 2px solid #eee;
        font-size: 24px;
        color: #333;
    `;

    const content = document.createElement('div');
    content.id = 'groceryRodeoContent';

    popup.appendChild(closeButton);
    popup.appendChild(title);
    popup.appendChild(content);

    return popup;
}

function fetchAndDisplayGroceryRodeo() {
    const site = document.getElementById('siteSelector').value;
    if (site !== 'SAZ2') return;

    // Close any existing popups
    const existingPopup = document.getElementById('groceryRodeoPopup');
    if (existingPopup) existingPopup.remove();

    const popup = createGroceryRodeoPopup();
    document.body.appendChild(popup);

    const url = generateGroceryRodeoURL(site);

    // Show loading indicator
    popup.querySelector('#groceryRodeoContent').innerHTML = '<p>Loading Grocery Rodeo data...</p>';

    GM_xmlhttpRequest({
        method: 'GET',
        url: url,
        onload: function(response) {
            if (response.status === 200) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(response.responseText, 'text/html');
                displayGroceryRodeoData(doc);
            } else {
                popup.querySelector('#groceryRodeoContent').innerHTML =
                    '<p>Error loading Grocery Rodeo data. Please try again.</p>';
            }
        },
        onerror: function(error) {
            popup.querySelector('#groceryRodeoContent').innerHTML =
                '<p>Error loading Grocery Rodeo data. Please try again.</p>';
            console.error('Error fetching Grocery Rodeo data:', error);
        }
    });
}

function displayGroceryRodeoData(doc) {
    const content = document.querySelector('#groceryRodeoContent');
    if (!content) return;

    content.innerHTML = '';

    function createWorkPoolTable(categoryName, tableSelector) {
        console.log(`Creating table for ${categoryName}`);
        let tableHtml = `<div class="category-header" style="
            font-size: 20px;
            font-weight: bold;
            margin: 15px 0;
            padding: 8px;
            background-color: #f0f0f0;
            border-left: 4px solid #3498db;
        ">${categoryName}</div>`;

        tableHtml += `<table style="
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            font-size: 14px;
            min-width: 1200px;
        ">`;

        const table = doc.querySelector(tableSelector);
        if (table) {
            // Get headers
            const headerRow = table.querySelector('tr.header-row');
            if (headerRow) {
                const headers = Array.from(headerRow.cells).map(cell => cell.textContent.trim());

                // Create header row
                tableHtml += `<tr style="background-color: #e6eff7;">`;
                tableHtml += `<th style="
                    text-align: left;
                    padding: 12px;
                    border: 1px solid #ddd;
                    font-weight: bold;
                    background-color: #f2f2f2;
                    position: sticky;
                    top: 0;
                ">Process Path</th>`;

                // Standard columns
                ['Total', 'Earlier Total', 'Range Total'].forEach(header => {
                    tableHtml += `<th style="
                        text-align: right;
                        padding: 12px;
                        border: 1px solid #ddd;
                        font-weight: bold;
                        background-color: #f2f2f2;
                        position: sticky;
                        top: 0;
                        min-width: 100px;
                    ">${header}</th>`;
                });

                // Dynamic CPT columns
                headers.slice(4).forEach(header => {
                    tableHtml += `<th style="
                        text-align: right;
                        padding: 12px;
                        border: 1px solid #ddd;
                        font-weight: bold;
                        background-color: #f2f2f2;
                        position: sticky;
                        top: 0;
                        min-width: 100px;
                    ">${header}</th>`;
                });
                tableHtml += '</tr>';

                // Add data rows
                const rows = table.querySelectorAll('tr:not(.header-row):not(.grand-total)');
                rows.forEach(row => {
                    const cells = row.cells;
                    if (cells.length >= 4) {
                        tableHtml += '<tr>';
                        // Process path cell
                        const processPath = cells[0].textContent.trim();
                        const isGroceryPath = processPath.includes('PPChilled') ||
                                           processPath.includes('PPAmbient') ||
                                           processPath.includes('PPFrozen');

                        tableHtml += `<td style="
                            padding: 8px;
                            border: 1px solid #ddd;
                            background-color: ${isGroceryPath ? '#e6eff7' : '#ffffff'};
                            font-weight: ${isGroceryPath ? 'bold' : 'normal'};
                        ">${processPath}</td>`;

                        // Data cells
                        for (let i = 1; i < cells.length; i++) {
                            const value = cells[i].textContent.trim();
                            tableHtml += `<td style="
                                text-align: right;
                                padding: 8px;
                                border: 1px solid #ddd;
                                background-color: #ffffff;
                            ">${value}</td>`;
                        }
                        tableHtml += '</tr>';
                    }
                });

                // Add grand total row
                const grandTotal = table.querySelector('tr.grand-total');
                if (grandTotal) {
                    tableHtml += `<tr style="
                        background-color: #f2f2f2;
                        font-weight: bold;
                    ">`;
                    Array.from(grandTotal.cells).forEach((cell, index) => {
                        tableHtml += `<td style="
                            text-align: ${index === 0 ? 'left' : 'right'};
                            padding: 8px;
                            border: 1px solid #ddd;
                        ">${cell.textContent.trim()}</td>`;
                    });
                    tableHtml += '</tr>';
                }
            }
        }

        tableHtml += '</table>';
        return tableHtml;
    }

    // Modify the popup style to be larger
    const popup = document.getElementById('groceryRodeoPopup');
    if (popup) {
        popup.style.width = '90vw';
        popup.style.maxWidth = '1500px';
        popup.style.maxHeight = '90vh';
        popup.style.padding = '30px';
    }

    // Create scroll container for tables
    const container = document.createElement('div');
    container.style.cssText = `
    padding: 10px;
`;
    // Add tables
    container.innerHTML += createWorkPoolTable('Total', '.result-table');
    container.innerHTML += createWorkPoolTable('ReadyToPick', '#ReadyToPickTable');
    container.innerHTML += createWorkPoolTable('PickingNotYetPicked', '#PickingNotYetPickedTable');
    content.appendChild(container);
}

function updatePlanSummaryWithGroceryVolumes() {
    const selectedSite = document.getElementById('siteSelector').value;
    if (selectedSite !== 'SAZ2') return;

    const currentCPT = document.getElementById('cptSelect').value;
    console.log('Current CPT:', currentCPT);

    const planSummaryTable = document.querySelector('#planSummary1Container table');
    if (!planSummaryTable) return;

    // Check if we've already updated with grocery volumes
    if (planSummaryTable.getAttribute('data-grocery-updated') === 'true') {
        console.log('Table already updated with grocery volumes');
        return;
    }

    const groceryTable = groceryRodeoData?.querySelector('.result-table');
    if (!groceryTable) return;

    // Get current date and time in Phoenix timezone
    const phoenixTime = new Date().toLocaleString("en-US", { timeZone: "America/Phoenix" });
    const currentDate = new Date(phoenixTime);
    const currentMonth = currentDate.getMonth();
    const currentDay = currentDate.getDate();

    const months = {
        'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
        'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
    };

    let targetValue = 0;

    // Find the correct column and get its value
    const headerRow = groceryTable.querySelector('tr.header-row');
    if (headerRow) {
        Array.from(headerRow.cells).forEach((cell, index) => {
            const match = cell.textContent.trim().match(/([A-Za-z]+)\s+(\d+)\s+(\d{2}:\d{2})/);
            if (match) {
                const [_, monthStr, dayStr, timeStr] = match;
                const cellMonth = months[monthStr];
                const cellDay = parseInt(dayStr);

                if (timeStr === currentCPT) {
                    if (cellMonth > currentMonth ||
                       (cellMonth === currentMonth && cellDay >= currentDay)) {

                        if (!targetValue) {
                            const totalRow = groceryTable.querySelector('tr.grand-total');
                            if (totalRow && totalRow.cells[index]) {
                                targetValue = parseInt(totalRow.cells[index].textContent) || 0;
                                console.log('Found grocery volume:', targetValue);
                            }
                        }
                    }
                }
            }
        });
    }

    // If we found a value, update all rows until OB Planned Volume
    if (targetValue > 0) {
        const rows = planSummaryTable.rows;
        for (let i = 1; i < rows.length; i++) {
            const row = rows[i];
            // Stop if we reach the OB Planned Volume row
            if (row.cells[0].textContent.includes('OB Planned Volume')) {
                break;
            }

            // Store original values if not already stored
            if (!row.hasAttribute('data-original-multis')) {
                row.setAttribute('data-original-multis', row.cells[1].textContent);
                row.setAttribute('data-original-total', row.cells[3].textContent);
            }

            // Update Multis Capacity (cell index 1)
            const multisCell = row.cells[1];
            if (multisCell) {
                const originalMultis = parseInt(row.getAttribute('data-original-multis')) || 0;
                const newMultis = originalMultis + targetValue;
                multisCell.textContent = newMultis;
                multisCell.style.color = 'red';
                multisCell.style.fontWeight = 'bold';
            }

            // Update Total Capacity (cell index 3)
            const totalCell = row.cells[3];
            if (totalCell) {
                const originalTotal = parseInt(row.getAttribute('data-original-total')) || 0;
                const newTotal = originalTotal + targetValue;
                totalCell.textContent = newTotal;
                totalCell.style.color = 'FF0000';
                totalCell.style.fontWeight = 'bold';
            }
        }

        // Mark the table as updated
        planSummaryTable.setAttribute('data-grocery-updated', 'true');
        console.log('Table updated with grocery volumes');

        // Add the message about grocery units
        const messageDiv = document.createElement('div');
        messageDiv.style.marginTop = '10px';
        messageDiv.style.fontStyle = 'italic';
        messageDiv.style.color = '#FF0000';
        messageDiv.style.fontWeight = 'bold';
        messageDiv.textContent = `${targetValue} units from Grocery was added to Multis Capacity`;
        planSummaryTable.parentElement.appendChild(messageDiv);

        // Mark the table as updated
        planSummaryTable.setAttribute('data-grocery-updated', 'true');
        console.log('Table updated with grocery volumes');

    }
}

let groceryRodeoData = null;

document.getElementById('siteSelector').addEventListener('change', function() {
    const selectedSite = this.value;
    if (selectedSite === 'SAZ2') {
        fetchGroceryRodeoDataBackground();
    }
    updateGroceryRodeoButtonVisibility();
});
window.addEventListener('load', function() {
    if (document.getElementById('siteSelector').value === 'SAZ2') {
        fetchGroceryRodeoDataBackground();
    }
});
// New function to fetch data in the background
function fetchGroceryRodeoDataBackground() {
    console.log('Fetching Grocery Rodeo data in background');
    const url = generateGroceryRodeoURL('SAZ2');

    GM_xmlhttpRequest({
        method: 'GET',
        url: url,
        onload: function(response) {
            if (response.status === 200) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(response.responseText, 'text/html');
                groceryRodeoData = doc;
                console.log('Grocery Rodeo data fetched and stored');
                updatePlanSummary1();
            } else {
                console.error('Failed to fetch Grocery Rodeo data:', response.status);
            }
        },
        onerror: function(error) {
            console.error('Error fetching Grocery Rodeo data:', error);
        }
    });
}
// Because I want to.
// Preload UFO gif at the start of your script
const preloadedUFO = new Image();
preloadedUFO.src = 'https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExZzJtdm4zNm1nNGJ4YXNpZjVnN3p1aHpzejk5bm40OWhjeHhtYXo3biZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/RghT6q0HUIvXDJGNda/giphy.gif';

// Preload quack sound
const preloadedQuack = new Audio('https://cdn.freesound.org/previews/515/515408_10319640-lq.mp3');
preloadedQuack.preload = 'auto';

const animationStyle = document.createElement('style');
animationStyle.textContent = `
    @keyframes flyLeftToRight {
        0% { transform: translateX(-200vw) scaleX(-1); }
        100% { transform: translateX(200vw) scaleX(-1); }
    }
    @keyframes flyRightToLeft {
        0% { transform: translateX(200vw); }
        100% { transform: translateX(-200vw); }
    }
    @keyframes flyTopToBottom {
        0% { transform: translateY(-200vh); }
        100% { transform: translateY(200vh); }
    }
    @keyframes flyBottomToTop {
        0% { transform: translateY(200vh) scaleX(-1); }
        100% { transform: translateY(-200vh) scaleX(-1); }
    }
`;
document.head.appendChild(animationStyle);

let ufoAnimationPlayed = false;
document.getElementById('packRate').addEventListener('input', function(e) {
    if (e.target.value.toLowerCase() === 'ducks' && !ufoAnimationPlayed) {
        setTimeout(() => {
            e.target.value = '300';
            createUFOAnimation();
            ufoAnimationPlayed = true;
        }, 100);
        setTimeout(() => {
            playMultipleQuacks();
        }, 3000);
    }
});

function playMultipleQuacks() {
    const numberOfQuacks = 9;
    const quacks = Array(numberOfQuacks).fill(null).map(() => preloadedQuack.cloneNode());

    quacks.forEach((quack, i) => {
        setTimeout(() => {
            quack.play().catch(err => console.log('Audio failed to play:', err));
            setTimeout(() => {
                quack.pause();
                quack.currentTime = 0;
            }, 3000);
        }, i * 700);
    });
}

window.addEventListener('load', function() {
    ufoAnimationPlayed = false;
});

function createUFOAnimation() {
    const numUFOs = 200;
    const container = document.createElement('div');
    container.style.position = 'fixed';
    container.style.top = '0';
    container.style.left = '0';
    container.style.width = '100vw';
    container.style.height = '100vh';
    container.style.pointerEvents = 'none';
    container.style.zIndex = '99999';
    container.style.overflow = 'hidden';

    // Create all UFO elements first
    const ufos = Array(numUFOs).fill(null).map(() => {
        const ufo = new Image();
        ufo.src = preloadedUFO.src;
        ufo.style.position = 'absolute';
        ufo.style.width = `${250 + Math.random() * 250}px`;
        ufo.style.pointerEvents = 'none';
        return ufo;
    });

    // Append and animate UFOs
    ufos.forEach(ufo => {
        const direction = Math.floor(Math.random() * 4);

        switch(direction) {
            case 0: // Left to Right
                ufo.style.left = '-100px';
                ufo.style.top = `${Math.random() * 100}vh`;
                ufo.style.animation = `flyLeftToRight ${8 + Math.random() * 4}s linear forwards`;
                break;
            case 1: // Right to Left
                ufo.style.right = '-100px';
                ufo.style.top = `${Math.random() * 100}vh`;
                ufo.style.animation = `flyRightToLeft ${8 + Math.random() * 4}s linear forwards`;
                break;
            case 2: // Top to Bottom
                ufo.style.top = '-100px';
                ufo.style.left = `${Math.random() * 100}vw`;
                ufo.style.animation = `flyTopToBottom ${8 + Math.random() * 4}s linear forwards`;
                break;
            case 3: // Bottom to Top
                ufo.style.bottom = '-100px';
                ufo.style.left = `${Math.random() * 100}vw`;
                ufo.style.animation = `flyBottomToTop ${8 + Math.random() * 4}s linear forwards`;
                break;
        }

        container.appendChild(ufo);
    });

    document.body.appendChild(container);

    setTimeout(() => {
        document.body.removeChild(container);
    }, 12000);
}

const spaceBackground = new Image();
spaceBackground.src = 'https://images.pexels.com/photos/1169754/pexels-photo-1169754.jpeg';

const darkModeStyles = document.createElement('style');
darkModeStyles.innerHTML = `
    .dark-mode {
        position: relative;
    }

    .dark-mode::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url('${spaceBackground.src}');
        background-size: cover;
        background-attachment: fixed;
        background-repeat: no-repeat;
        filter: brightness(0.6);
        z-index: -2;
    }

    .dark-mode::after {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        z-index: -1;
    }

    .dark-mode .container,
    .dark-mode #fullTableContainer,
    .dark-mode #nextCPTTableContainer,
    .dark-mode #planSummary1Container,
    .dark-mode #planSummary2Container,
    .dark-mode #planSummary3Container,
    .dark-mode #currentCPTInfoBox,
    .dark-mode #nextCPTInfoBox,
    .dark-mode #clockContainer,
    .dark-mode #cptInfoContainer,
    .dark-mode #timestampContainer,
    .dark-mode #dispatchRecommendationContainer,
    .dark-mode #mathTableContainer,
    .dark-mode #nextCPTMathTableContainer,
    .dark-mode #nextNextCPTMathTableContainer,
    .dark-mode #exSDBox,
    .dark-mode #maxWallsContainer,
    .dark-mode #groceryRodeoContainer,
    .dark-mode #timestampContainer {
        position: relative;
    }

    /* Add a semi-transparent overlay to containers */
    .dark-mode .container::before,
    .dark-mode #fullTableContainer::before,
    .dark-mode #nextCPTTableContainer::before,
    .dark-mode #planSummary1Container::before,
    .dark-mode #planSummary2Container::before,
    .dark-mode #planSummary3Container::before,
    .dark-mode #currentCPTInfoBox::before,
    .dark-mode #nextCPTInfoBox::before,
    .dark-mode #clockContainer::before,
    .dark-mode #cptInfoContainer::before,
    .dark-mode #timestampContainer::before,
    .dark-mode #dispatchRecommendationContainer::before,
    .dark-mode #mathTableContainer::before,
    .dark-mode #nextCPTMathTableContainer::before,
    .dark-mode #nextNextCPTMathTableContainer::before,
    .dark-mode #exSDBox::before,
    .dark-mode #maxWallsContainer::before,
    .dark-mode #groceryRodeoContainer::before,
    .dark-mode #timestampContainer::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.7);
        pointer-events: none;
        z-index: -1;
        border-radius: inherit;
    }

    /* Preserve colors for specific elements */
    .dark-mode td[style*="background-color"],
    .dark-mode th[style*="background-color"],
    .dark-mode div[style*="background-color"] {
        position: relative;
        z-index: 1;
    }

    .dark-mode td[style*="color: red"],
    .dark-mode td[style*="color: #ff0000"],
    .dark-mode td[style*="color: rgb(255, 0, 0)"] {
        color: red !important;
        font-weight: bold !important;
    }

    .dark-mode td[style*="background-color: yellow"],
    .dark-mode td[style*="background-color: #ffff00"] {
        background-color: rgba(255, 255, 0, 0.7) !important;
    }

    .dark-mode td[style*="background-color: red"],
    .dark-mode td[style*="background-color: #ff0000"] {
        background-color: rgba(255, 0, 0, 0.7) !important;
    }

    .dark-mode td[style*="background-color: lightgreen"],
    .dark-mode td[style*="background-color: #90EE90"] {
        background-color: rgba(144, 238, 144, 0.7) !important;
    }

    .toggle-dark-mode {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 10002;
        padding: 8px 16px;
        background-color: #333;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .toggle-dark-mode:hover {
        background-color: #555;
    }
`;
document.head.appendChild(darkModeStyles);

function addDarkModeToggle() {
    const siteHeader = document.getElementById('siteHeader');
    if (!siteHeader) return;
    if (document.querySelector('.toggle-dark-mode')) return;

    const toggleButton = document.createElement('button');
    toggleButton.className = 'toggle-dark-mode';
    toggleButton.innerHTML = 'üåô';
    toggleButton.style.cssText = `
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        padding: 8px 16px;
        background-color: #333;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 20px;
    `;

    toggleButton.addEventListener('mouseover', () => {
        toggleButton.style.backgroundColor = '#555';
    });

    toggleButton.addEventListener('mouseout', () => {
        toggleButton.style.backgroundColor = '#333';
    });

    toggleButton.addEventListener('click', toggleDarkMode);
    siteHeader.appendChild(toggleButton);
}


function toggleDarkMode() {
    const body = document.body;
    const button = document.querySelector('.toggle-dark-mode');
    const isDarkMode = body.classList.toggle('dark-mode');
    button.innerHTML = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
    localStorage.setItem('darkMode_UFO', isDarkMode);
}

function loadDarkModePreference() {
    if (!window.location.pathname.includes('/UFO')) return;

    const darkModeEnabled = localStorage.getItem('darkMode_UFO') === 'true';
    if (darkModeEnabled) {
        document.body.classList.add('dark-mode');
        const button = document.querySelector('.toggle-dark-mode');
        if (button) button.innerHTML = '‚òÄÔ∏è';
    }
}

document.getElementById('siteSelector').addEventListener('change', () => {
    setTimeout(addDarkModeToggle, 100);
});

window.addEventListener('load', () => {
    loadDarkModePreference();
    addDarkModeToggle();
});

})();
